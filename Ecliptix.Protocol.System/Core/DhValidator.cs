using Ecliptix.Utilities;
using Ecliptix.Utilities.Failures.EcliptixProtocol;

namespace Ecliptix.Protocol.System.Core;

public static class DhValidator
{
    public static Result<Unit, EcliptixProtocolFailure> ValidateX25519PublicKey(byte[] publicKey)
    {
        if (publicKey.Length != Constants.X25519PublicKeySize)
            return Result<Unit, EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.InvalidInput(
                    $"Invalid public key size: expected {Constants.X25519PublicKeySize}, got {publicKey.Length}"));

        if (HasSmallOrder(publicKey))
            return Result<Unit, EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.InvalidInput("Public key has small order"));

        if (!IsValidCurve25519Point(publicKey))
            return Result<Unit, EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.InvalidInput("Public key is not a valid Curve25519 point"));

        return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);
    }

    private static bool IsValidCurve25519Point(ReadOnlySpan<byte> publicKey)
    {
        if (publicKey.Length != 32)
            return false;

        return IsValidFieldElement(publicKey) && !HasSmallOrder(publicKey);
    }

    private static bool IsValidFieldElement(ReadOnlySpan<byte> element)
    {
        Span<byte> reduced = stackalloc byte[32];
        element.CopyTo(reduced);

        Span<uint> words = stackalloc uint[8];
        for (int i = 0; i < 8; i++)
        {
            words[i] = (uint)(reduced[i * 4] |
                              (reduced[i * 4 + 1] << 8) |
                              (reduced[i * 4 + 2] << 16) |
                              (reduced[i * 4 + 3] << 24));
        }

        const uint mask = 0x7FFFFFFF;

        words[7] &= mask;

        return CompareToFieldPrime(words) < 0;
    }

    private static int CompareToFieldPrime(ReadOnlySpan<uint> element)
    {
        ReadOnlySpan<uint> p =
        [
            0x7FFFFFED, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF,
            0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF
        ];

        for (int i = 7; i >= 0; i--)
        {
            if (element[i] < p[i]) return -1;
            if (element[i] > p[i]) return 1;
        }

        return 0;
    }

    private static readonly byte[][] SmallOrderPoints =
    [
        [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ],
        [
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ],
        [
            0xE0, 0xEB, 0x7A, 0x7C, 0x3B, 0x41, 0xB8, 0xAE, 0x16, 0x56, 0xE3, 0xFA, 0xF1, 0x9F, 0xC4, 0x6A, 0xDA, 0x09,
            0x8D, 0xEB, 0x9C, 0x32, 0xB1, 0xFD, 0x86, 0x62, 0x05, 0x16, 0x5F, 0x49, 0xB8, 0x00
        ],
        [
            0x5F, 0x9C, 0x95, 0xBC, 0xA3, 0x50, 0x8C, 0x24, 0xB1, 0xD0, 0xB1, 0x55, 0x9C, 0x83, 0xEF, 0x5B, 0x04, 0x44,
            0x5C, 0xC4, 0x58, 0x1C, 0x8E, 0x86, 0xD8, 0x22, 0x4E, 0xDD, 0xD0, 0x9F, 0x11, 0x57
        ],
        [
            0xEC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F
        ],
        [
            0xED, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F
        ],
        [
            0xEE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F
        ],
        [
            0xCD, 0xEB, 0x7A, 0x7C, 0x3B, 0x41, 0xB8, 0xAE, 0x16, 0x56, 0xE3, 0xFA, 0xF1, 0x9F, 0xC4, 0x6A, 0xDA, 0x09,
            0x8D, 0xEB, 0x9C, 0x32, 0xB1, 0xFD, 0x86, 0x62, 0x05, 0x16, 0x5F, 0x49, 0xB8, 0x80
        ]
    ];

    private static bool HasSmallOrder(ReadOnlySpan<byte> point)
    {
        foreach (byte[] smallOrderPoint in SmallOrderPoints)
        {
            if (ConstantTimeEquals(point, smallOrderPoint))
                return true;
        }

        return false;
    }

    private static bool ConstantTimeEquals(ReadOnlySpan<byte> a, ReadOnlySpan<byte> b)
    {
        if (a.Length != b.Length)
            return false;

        int result = 0;
        for (int i = 0; i < a.Length; i++)
        {
            result |= a[i] ^ b[i];
        }

        return result == 0;
    }
}