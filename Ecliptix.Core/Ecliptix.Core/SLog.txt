using System.Threading;
using System.Threading.Tasks;

namespace Ecliptix.Core.Core.Messaging.Subscriptions;

internal sealed class SubscriptionManager : IDisposable
{
    private readonly ConcurrentDictionary<string, SubscriptionList> _subscriptions = new();
    private readonly Timer _cleanupTimer;
    private readonly Lock _cleanupLock = new();
    private long _totalSubscriptions;
    private long _deadReferencesCleanedUp;
    private volatile bool _disposed;

    public SubscriptionManager()
    {
        _cleanupTimer = new Timer(CleanupDeadReferences, null, TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
    }

    public IDisposable Subscribe<T>(
        Func<T, bool> filter,
        Func<T, Task> handler,
        SubscriptionLifetime lifetime,
        int priority) where T : class
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(nameof(SubscriptionManager));
        }

        string messageTypeKey = GetMessageTypeKey<T>();
        SubscriptionList list = _subscriptions.GetOrAdd(messageTypeKey, _ => new SubscriptionList());

        ISubscription subscription = lifetime switch
        {
            SubscriptionLifetime.Weak => new WeakSubscription<T>(filter, handler, priority),
            SubscriptionLifetime.Strong => new StrongSubscription<T>(filter, handler, priority),
            SubscriptionLifetime.Scoped => new ScopedSubscription<T>(filter, handler, priority),
            _ => throw new ArgumentOutOfRangeException(nameof(lifetime))
        };

        list.Add(subscription);
        Interlocked.Increment(ref _totalSubscriptions);

        return new SubscriptionToken(() =>
        {
            list.Remove(subscription);
            Interlocked.Decrement(ref _totalSubscriptions);

            if (list.IsEmpty)
            {
                _subscriptions.TryRemove(messageTypeKey, out _);
            }
        });
    }

    public async Task PublishAsync<T>(T message, CancellationToken _) where T : class
    {
        if (_disposed || message == null)
        {
            return;
        }

        string messageTypeKey = GetMessageTypeKey<T>();

        if (!_subscriptions.TryGetValue(messageTypeKey, out SubscriptionList? list))
        {
            return;
        }

        ISubscription[] activeSubscriptions = list.GetActiveSubscriptions();
        if (activeSubscriptions.Length == 0)
        {
            return;
        }

        if (activeSubscriptions.Length > 1)
        {
            Array.Sort(activeSubscriptions, (x, y) => y.Priority.CompareTo(x.Priority));
        }

        List<Task> handlerTasks = new(activeSubscriptions.Length);

        foreach (ISubscription subscription in activeSubscriptions)
        {
            try
            {
                Task? handlerTask = subscription.HandleAsync(message);
                if (handlerTask != null)
                {
                    handlerTasks.Add(handlerTask);
                }
            }
            catch (Exception)
            {
                // Swallow handler invocation exceptions to allow other handlers to run
            }
        }

        if (handlerTasks.Count > 0)
        {
            try
            {
                await Task.WhenAll(handlerTasks);
            }
            catch (Exception)
            {
                // One or more handlers failed - individual handler exceptions are caught above
            }
        }
    }

    private void CleanupDeadReferences(object? state)
    {
        if (_disposed)
        {
            return;
        }

        lock (_cleanupLock)
        {
            if (_disposed)
            {
                return;
            }

            int cleanedUp = 0;
            List<string> emptyLists = [];

            foreach (KeyValuePair<string, SubscriptionList> kvp in _subscriptions)
            {
                cleanedUp += kvp.Value.CleanupDeadReferences();
                if (kvp.Value.IsEmpty)
                {
                    emptyLists.Add(kvp.Key);
                }
            }

            foreach (string key in emptyLists)
            {
                _subscriptions.TryRemove(key, out _);
            }

            Interlocked.Add(ref _deadReferencesCleanedUp, cleanedUp);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static string GetMessageTypeKey<T>() where T : class
    {
        return typeof(T).Name;
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;
            _cleanupTimer.Dispose();

            foreach (SubscriptionList list in _subscriptions.Values)
            {
                list.Dispose();
            }

            _subscriptions.Clear();
        }
    }
}

internal sealed class SubscriptionToken(Action disposeAction) : IDisposable
{
    private bool _disposed;

    public void Dispose()
    {
        if (!_disposed)
        {
            disposeAction();
            _disposed = true;
        }
    }
}

internal sealed class SubscriptionList : IDisposable
{
    private readonly List<ISubscription> _subscriptions = new();
    private readonly ReaderWriterLockSlim _lock = new();
    private bool _disposed;

    public void Add(ISubscription subscription)
    {
        _lock.EnterWriteLock();
        try
        {
            if (!_disposed)
            {
                _subscriptions.Add(subscription);
            }
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }

    public void Remove(ISubscription subscription)
    {
        _lock.EnterWriteLock();
        try
        {
            _subscriptions.Remove(subscription);
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }

    public ISubscription[] GetActiveSubscriptions()
    {
        _lock.EnterReadLock();
        try
        {
            return _subscriptions.Where(s => s.IsAlive).ToArray();
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    public int CleanupDeadReferences()
    {
        _lock.EnterWriteLock();
        try
        {
            int initialCount = _subscriptions.Count;
            _subscriptions.RemoveAll(s => !s.IsAlive);
            return initialCount - _subscriptions.Count;
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }

    public (int weak, int strong) GetSubscriptionCounts()
    {
        _lock.EnterReadLock();
        try
        {
            int weak = 0, strong = 0;
            foreach (ISubscription subscription in _subscriptions)
            {
                if (subscription.IsWeak)
                {
                    weak++;
                }
                else
                {
                    strong++;
                }
            }
            return (weak, strong);
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    public bool IsEmpty
    {
        get
        {
            _lock.EnterReadLock();
            try
            {
                return _subscriptions.Count == 0;
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _lock.EnterWriteLock();
            try
            {
                _subscriptions.Clear();
                _disposed = true;
            }
            finally
            {
                _lock.ExitWriteLock();
                _lock.Dispose();
            }
        }
    }
}

 [2025-11-04T12:57:46.511] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.4380ms) ************
{
  "Request_seq": 9261,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549589,
  "Type": "response"
}
 [2025-11-04T12:57:46.511] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9262,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Subscriptions/SubscriptionManager.cs"
  }
}
 [2025-11-04T12:57:46.681] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (169.9222ms) ************
{
  "Request_seq": 9262,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549593,
  "Type": "response"
}
 [2025-11-04T12:57:46.683] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9263,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/Ecliptix.Protobufs.GlobalUsings.g.cs",
    "Buffer": "// <auto-generated/>\nglobal using global::System;\nglobal using global::System.Collections.Generic;\nglobal using global::System.IO;\nglobal using global::System.Linq;\nglobal using global::System.Net.Http;\nglobal using global::System.Threading;\nglobal using global::System.Threading.Tasks;\n"
  }
}
 [2025-11-04T12:57:46.683] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/Ecliptix.Protobufs.GlobalUsings.g.cs with new text:
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

 [2025-11-04T12:57:46.683] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2013ms) ************
{
  "Request_seq": 9263,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549598,
  "Type": "response"
}
 [2025-11-04T12:57:46.683] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9264,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/Ecliptix.Protobufs.GlobalUsings.g.cs"
  }
}
 [2025-11-04T12:57:46.809] [sonarlint-finding-streamer] DEBUG sonarlint - Reporting 455 issues for configuration scope /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/.idea/.idea.Ecliptix-Desktop/.idea/misc.xml_rider.module
 [2025-11-04T12:57:46.962] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (278.6162ms) ************
{
  "Request_seq": 9264,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549602,
  "Type": "response"
}
 [2025-11-04T12:57:46.963] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9265,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/Constants/SecureKeyValidatorConstants.cs",
    "Buffer": "using System;\nusing System.Collections.Frozen;\n\nnamespace Ecliptix.Core.Services.Membership.Constants;\n\npublic static class SecureKeyValidatorConstants\n{\n    public static class LocalizationKeys\n    {\n        public const string NonEnglishLetters = \"ValidationErrors.SecureKey.NonEnglishLetters\";\n        public const string Required = \"ValidationErrors.SecureKey.Required\";\n        public const string MinLength = \"ValidationErrors.SecureKey.MinLength\";\n        public const string NoUppercase = \"ValidationErrors.SecureKey.NoUppercase\";\n        public const string NoLowercase = \"ValidationErrors.SecureKey.NoLowercase\";\n        public const string NoSpecialChar = \"ValidationErrors.SecureKey.NoSpecialChar\";\n        public const string NoDigit = \"ValidationErrors.SecureKey.NoDigit\";\n        public const string MaxLength = \"ValidationErrors.SecureKey.MaxLength\";\n        public const string NoSpaces = \"ValidationErrors.SecureKey.NoSpaces\";\n        public const string TooSimple = \"ValidationErrors.SecureKey.TooSimple\";\n        public const string TooCommon = \"ValidationErrors.SecureKey.TooCommon\";\n        public const string SequentialPattern = \"ValidationErrors.SecureKey.SequentialPattern\";\n        public const string RepeatedChars = \"ValidationErrors.SecureKey.RepeatedChars\";\n        public const string LacksDiversity = \"ValidationErrors.SecureKey.LacksDiversity\";\n        public const string ContainsAppName = \"ValidationErrors.SecureKey.ContainsAppName\";\n    }\n\n    public static class ValidationRules\n    {\n        public const int MinLength = 6;\n        public const int MaxLength = 21;\n        public const int MinCharClasses = 2;\n        public const double MinTotalEntropyBits = 30;\n    }\n\n    public static readonly FrozenSet<string> KeyboardRows = FrozenSet.ToFrozenSet(\n    [\n        \"qwertyuiop\",\n        \"asdfghjkl\",\n        \"zxcvbnm\",\n        \"1234567890\"\n    ]);\n\n    public static readonly FrozenSet<string> AppNameVariants = FrozenSet.ToFrozenSet(\n    [\n        \"ecliptix\",\n        \"eclip\",\n        \"opaque\"\n    ]);\n\n    public static readonly FrozenSet<string> CommonlyUsedSecureKeys = FrozenSet.ToFrozenSet(\n    [\n        \"123456\",\n        \"password\",\n        \"12345678\",\n        \"123456789\",\n        \"qwerty\"\n    ], StringComparer.OrdinalIgnoreCase);\n}\n"
  }
}
 [2025-11-04T12:57:46.963] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/Constants/SecureKeyValidatorConstants.cs with new text:
using System;
using System.Collections.Frozen;

namespace Ecliptix.Core.Services.Membership.Constants;

public static class SecureKeyValidatorConstants
{
    public static class LocalizationKeys
    {
        public const string NonEnglishLetters = "ValidationErrors.SecureKey.NonEnglishLetters";
        public const string Required = "ValidationErrors.SecureKey.Required";
        public const string MinLength = "ValidationErrors.SecureKey.MinLength";
        public const string NoUppercase = "ValidationErrors.SecureKey.NoUppercase";
        public const string NoLowercase = "ValidationErrors.SecureKey.NoLowercase";
        public const string NoSpecialChar = "ValidationErrors.SecureKey.NoSpecialChar";
        public const string NoDigit = "ValidationErrors.SecureKey.NoDigit";
        public const string MaxLength = "ValidationErrors.SecureKey.MaxLength";
        public const string NoSpaces = "ValidationErrors.SecureKey.NoSpaces";
        public const string TooSimple = "ValidationErrors.SecureKey.TooSimple";
        public const string TooCommon = "ValidationErrors.SecureKey.TooCommon";
        public const string SequentialPattern = "ValidationErrors.SecureKey.SequentialPattern";
        public const string RepeatedChars = "ValidationErrors.SecureKey.RepeatedChars";
        public const string LacksDiversity = "ValidationErrors.SecureKey.LacksDiversity";
        public const string ContainsAppName = "ValidationErrors.SecureKey.ContainsAppName";
    }

    public static class ValidationRules
    {
        public const int MinLength = 6;
        public const int MaxLength = 21;
        public const int MinCharClasses = 2;
        public const double MinTotalEntropyBits = 30;
    }

    public static readonly FrozenSet<string> KeyboardRows = FrozenSet.ToFrozenSet(
    [
        "qwertyuiop",
        "asdfghjkl",
        "zxcvbnm",
        "1234567890"
    ]);

    public static readonly FrozenSet<string> AppNameVariants = FrozenSet.ToFrozenSet(
    [
        "ecliptix",
        "eclip",
        "opaque"
    ]);

    public static readonly FrozenSet<string> CommonlyUsedSecureKeys = FrozenSet.ToFrozenSet(
    [
        "123456",
        "password",
        "12345678",
        "123456789",
        "qwerty"
    ], StringComparer.OrdinalIgnoreCase);
}

 [2025-11-04T12:57:46.963] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3591ms) ************
{
  "Request_seq": 9265,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549608,
  "Type": "response"
}
 [2025-11-04T12:57:46.963] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9266,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/Constants/SecureKeyValidatorConstants.cs"
  }
}
 [2025-11-04T12:57:47.075] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (111.8584ms) ************
{
  "Request_seq": 9266,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549612,
  "Type": "response"
}
 [2025-11-04T12:57:47.076] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9267,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/RatchetConfig.cs",
    "Buffer": "namespace Ecliptix.Protocol.System.Core;\n\ninternal sealed class RatchetConfig\n{\n    public static readonly RatchetConfig Default = new();\n\n    public uint DhRatchetEveryNMessages { get; init; } = 10;\n\n    public bool EnablePerMessageRatchet { get; init; } = false;\n\n    public bool RatchetOnNewDhKey { get; init; } = true;\n\n    public TimeSpan MaxChainAge { get; init; } = ProtocolSystemConstants.Timeouts.DefaultMaxChainAge;\n\n    public uint MaxMessagesWithoutRatchet { get; init; } = 1000;\n\n    public bool ShouldRatchet(uint messageIndex, DateTime lastRatchetTime, bool receivedNewDhKey, DateTime currentTime)\n    {\n        if (EnablePerMessageRatchet)\n        {\n            return true;\n        }\n\n        if (RatchetOnNewDhKey && receivedNewDhKey)\n        {\n            return true;\n        }\n\n        if (messageIndex > 0 && messageIndex % DhRatchetEveryNMessages == 0)\n        {\n            return true;\n        }\n\n        if (currentTime - lastRatchetTime > MaxChainAge)\n        {\n            return true;\n        }\n\n        if (messageIndex >= MaxMessagesWithoutRatchet)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public bool ShouldRatchet(uint messageIndex, DateTime lastRatchetTime, bool receivedNewDhKey)\n    {\n        return ShouldRatchet(messageIndex, lastRatchetTime, receivedNewDhKey, DateTime.UtcNow);\n    }\n}\n"
  }
}
 [2025-11-04T12:57:47.076] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/RatchetConfig.cs with new text:
namespace Ecliptix.Protocol.System.Core;

internal sealed class RatchetConfig
{
    public static readonly RatchetConfig Default = new();

    public uint DhRatchetEveryNMessages { get; init; } = 10;

    public bool EnablePerMessageRatchet { get; init; } = false;

    public bool RatchetOnNewDhKey { get; init; } = true;

    public TimeSpan MaxChainAge { get; init; } = ProtocolSystemConstants.Timeouts.DefaultMaxChainAge;

    public uint MaxMessagesWithoutRatchet { get; init; } = 1000;

    public bool ShouldRatchet(uint messageIndex, DateTime lastRatchetTime, bool receivedNewDhKey, DateTime currentTime)
    {
        if (EnablePerMessageRatchet)
        {
            return true;
        }

        if (RatchetOnNewDhKey && receivedNewDhKey)
        {
            return true;
        }

        if (messageIndex > 0 && messageIndex % DhRatchetEveryNMessages == 0)
        {
            return true;
        }

        if (currentTime - lastRatchetTime > MaxChainAge)
        {
            return true;
        }

        if (messageIndex >= MaxMessagesWithoutRatchet)
        {
            return true;
        }

        return false;
    }

    public bool ShouldRatchet(uint messageIndex, DateTime lastRatchetTime, bool receivedNewDhKey)
    {
        return ShouldRatchet(messageIndex, lastRatchetTime, receivedNewDhKey, DateTime.UtcNow);
    }
}

 [2025-11-04T12:57:47.076] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2072ms) ************
{
  "Request_seq": 9267,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549616,
  "Type": "response"
}
 [2025-11-04T12:57:47.076] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9268,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/RatchetConfig.cs"
  }
}
 [2025-11-04T12:57:47.139] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (62.5792ms) ************
{
  "Request_seq": 9268,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549620,
  "Type": "response"
}
 [2025-11-04T12:57:47.139] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9269,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleCatalog.cs",
    "Buffer": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Ecliptix.Core.Core.Abstractions;\nusing Ecliptix.Utilities;\n\nnamespace Ecliptix.Core.Core.Modularity;\n\npublic interface IModuleCatalog\n{\n    void AddModule<TModule>() where TModule : class, IModule, new();\n    void AddModule(IModule module);\n\n    IReadOnlyList<IModule> GetModules();\n    Option<IModule> GetModule(string name);\n}\n\npublic class ModuleCatalog : IModuleCatalog\n{\n    private readonly List<IModule> _modules = [];\n\n    public void AddModule<TModule>() where TModule : class, IModule, new()\n    {\n        IModule module = new TModule();\n        AddModule(module);\n    }\n\n    public void AddModule(IModule module)\n    {\n        if (_modules.Any(m => m.Id == module.Id))\n        {\n            return;\n        }\n\n        _modules.Add(module);\n    }\n\n    public IReadOnlyList<IModule> GetModules() => _modules.AsReadOnly();\n\n    public Option<IModule> GetModule(string name) =>\n        _modules.FirstOrDefault(m => string.Equals(m.Id.ToName(), name, StringComparison.OrdinalIgnoreCase))\n            .ToOption();\n}\n"
  }
}
 [2025-11-04T12:57:47.139] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleCatalog.cs with new text:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Ecliptix.Core.Core.Abstractions;
using Ecliptix.Utilities;

namespace Ecliptix.Core.Core.Modularity;

public interface IModuleCatalog
{
    void AddModule<TModule>() where TModule : class, IModule, new();
    void AddModule(IModule module);

    IReadOnlyList<IModule> GetModules();
    Option<IModule> GetModule(string name);
}

public class ModuleCatalog : IModuleCatalog
{
    private readonly List<IModule> _modules = [];

    public void AddModule<TModule>() where TModule : class, IModule, new()
    {
        IModule module = new TModule();
        AddModule(module);
    }

    public void AddModule(IModule module)
    {
        if (_modules.Any(m => m.Id == module.Id))
        {
            return;
        }

        _modules.Add(module);
    }

    public IReadOnlyList<IModule> GetModules() => _modules.AsReadOnly();

    public Option<IModule> GetModule(string name) =>
        _modules.FirstOrDefault(m => string.Equals(m.Id.ToName(), name, StringComparison.OrdinalIgnoreCase))
            .ToOption();
}

 [2025-11-04T12:57:47.14] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3261ms) ************
{
  "Request_seq": 9269,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549624,
  "Type": "response"
}
 [2025-11-04T12:57:47.14] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9270,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleCatalog.cs"
  }
}
 [2025-11-04T12:57:47.252] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (112.3255ms) ************
{
  "Request_seq": 9270,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549628,
  "Type": "response"
}
 [2025-11-04T12:57:47.26] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9271,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/EcliptixProtocolSystem.cs",
    "Buffer": "using System.Diagnostics;\nusing System.Security.Cryptography;\nusing Ecliptix.Protobuf.Common;\nusing Ecliptix.Protobuf.Protocol;\nusing Ecliptix.Protobuf.ProtocolState;\nusing Ecliptix.Protocol.System.Sodium;\nusing Ecliptix.Protocol.System.Utilities;\nusing Ecliptix.Utilities;\nusing Ecliptix.Utilities.Failures.EcliptixProtocol;\nusing Ecliptix.Utilities.Failures.Sodium;\nusing Google.Protobuf;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace Ecliptix.Protocol.System.Core;\n\ninternal sealed class EcliptixProtocolSystem(EcliptixSystemIdentityKeys ecliptixSystemIdentityKeys)\n    : IDisposable\n{\n    private readonly Lock _lock = new();\n\n    private EcliptixProtocolConnection? _protocolConnection;\n    private IProtocolEventHandler? _eventHandler;\n\n    public EcliptixSystemIdentityKeys GetIdentityKeys() => ecliptixSystemIdentityKeys;\n\n    public void SetEventHandler(IProtocolEventHandler? handler)\n    {\n        EcliptixProtocolConnection? connectionToUpdate;\n\n        lock (_lock)\n        {\n            _eventHandler = handler;\n            connectionToUpdate = _protocolConnection;\n        }\n\n        connectionToUpdate?.SetEventHandler(handler);\n    }\n\n    public void Dispose()\n    {\n        EcliptixProtocolConnection? connectionToDispose;\n\n        lock (_lock)\n        {\n            connectionToDispose = _protocolConnection;\n            _protocolConnection = null;\n        }\n\n        connectionToDispose?.Dispose();\n    }\n\n    private EcliptixProtocolConnection? GetConnectionSafe()\n    {\n        lock (_lock)\n        {\n            return _protocolConnection;\n        }\n    }\n\n    private static Timestamp GetProtoTimestamp()\n    {\n        return Timestamp.FromDateTimeOffset(DateTimeOffset.UtcNow);\n    }\n\n    public Result<PubKeyExchange, EcliptixProtocolFailure> BeginDataCenterPubKeyExchange(\n        uint connectId,\n        PubKeyExchangeType exchangeType)\n    {\n        ecliptixSystemIdentityKeys.GenerateEphemeralKeyPair();\n\n        Result<LocalPublicKeyBundle, EcliptixProtocolFailure> bundleResult =\n            ecliptixSystemIdentityKeys.CreatePublicBundle();\n        if (bundleResult.IsErr)\n        {\n            return Result<PubKeyExchange, EcliptixProtocolFailure>.Err(bundleResult.UnwrapErr());\n        }\n\n        LocalPublicKeyBundle bundle = bundleResult.Unwrap();\n\n        Result<EcliptixProtocolConnection, EcliptixProtocolFailure> sessionResult =\n            EcliptixProtocolConnection.Create(connectId, true, RatchetConfig.Default, exchangeType);\n        if (sessionResult.IsErr)\n        {\n            return Result<PubKeyExchange, EcliptixProtocolFailure>.Err(sessionResult.UnwrapErr());\n        }\n\n        EcliptixProtocolConnection session = sessionResult.Unwrap();\n\n        IProtocolEventHandler? currentHandler;\n        lock (_lock)\n        {\n            _protocolConnection = session;\n            currentHandler = _eventHandler;\n        }\n\n        session.SetEventHandler(currentHandler);\n\n        Result<byte[]?, EcliptixProtocolFailure> dhKeyResult = session.GetCurrentSenderDhPublicKey();\n        if (dhKeyResult.IsErr)\n        {\n            return Result<PubKeyExchange, EcliptixProtocolFailure>.Err(dhKeyResult.UnwrapErr());\n        }\n\n        byte[]? dhPublicKey = dhKeyResult.Unwrap();\n        if (dhPublicKey == null)\n        {\n            return Result<PubKeyExchange, EcliptixProtocolFailure>.Err(\n                EcliptixProtocolFailure.PrepareLocal(ProtocolSystemConstants.ProtocolSystem.DhPublicKeyNullMessage));\n        }\n\n        PubKeyExchange pubKeyExchange = new()\n        {\n            State = PubKeyExchangeState.Init,\n            OfType = exchangeType,\n            Payload = bundle.ToProtobufExchange().ToByteString(),\n            InitialDhPublicKey = ByteString.CopyFrom(dhPublicKey)\n        };\n\n        return Result<PubKeyExchange, EcliptixProtocolFailure>.Ok(pubKeyExchange);\n    }\n\n    public Result<Unit, EcliptixProtocolFailure> CompleteAuthenticatedPubKeyExchange(PubKeyExchange peerMessage,\n        byte[] rootKey)\n    {\n        Result<byte[]?, EcliptixProtocolFailure> ourDhKeyResult = _protocolConnection?.GetCurrentSenderDhPublicKey() ??\n                                                                  Result<byte[]?, EcliptixProtocolFailure>.Err(\n                                                                      EcliptixProtocolFailure.Generic(\n                                                                          ProtocolSystemConstants.ProtocolSystem\n                                                                              .NoConnectionMessage));\n        if (ourDhKeyResult.IsOk)\n        {\n            byte[]? ourDhKey = ourDhKeyResult.Unwrap();\n            if (ourDhKey != null)\n            {\n                Result<bool, SodiumFailure> comparisonResult =\n                    SodiumInterop.ConstantTimeEquals(peerMessage.InitialDhPublicKey.Span, ourDhKey);\n                if (comparisonResult.IsOk && comparisonResult.Unwrap())\n                {\n                    return Result<Unit, EcliptixProtocolFailure>.Err(\n                        EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem\n                            .ReflectionAttackMessage));\n                }\n            }\n        }\n\n        Result<PublicKeyBundle, EcliptixProtocolFailure> parseResult =\n            Result<PublicKeyBundle, EcliptixProtocolFailure>.Try(\n                () =>\n                {\n                    SecureByteStringInterop.SecureCopyWithCleanup(peerMessage.Payload, out byte[] payloadBytes);\n                    try\n                    {\n                        return Helpers.ParseFromBytes<PublicKeyBundle>(payloadBytes);\n                    }\n                    finally\n                    {\n                        SodiumInterop.SecureWipe(payloadBytes);\n                    }\n                },\n                ex => EcliptixProtocolFailure.Decode(ProtocolSystemConstants.ProtocolSystem.ParseProtobufFailedMessage,\n                    ex));\n\n        if (parseResult.IsErr)\n        {\n            return Result<Unit, EcliptixProtocolFailure>.Err(parseResult.UnwrapErr());\n        }\n\n        PublicKeyBundle protobufBundle = parseResult.Unwrap();\n\n        Result<LocalPublicKeyBundle, EcliptixProtocolFailure> bundleResult =\n            LocalPublicKeyBundle.FromProtobufExchange(protobufBundle);\n        if (bundleResult.IsErr)\n        {\n            return Result<Unit, EcliptixProtocolFailure>.Err(bundleResult.UnwrapErr());\n        }\n\n        LocalPublicKeyBundle peerBundle = bundleResult.Unwrap();\n\n        Result<bool, EcliptixProtocolFailure> signatureResult = EcliptixSystemIdentityKeys.VerifyRemoteSpkSignature(\n            peerBundle.IdentityEd25519, peerBundle.SignedPreKeyPublic, peerBundle.SignedPreKeySignature);\n        if (signatureResult.IsErr)\n        {\n            return Result<Unit, EcliptixProtocolFailure>.Err(signatureResult.UnwrapErr());\n        }\n\n        bool spkValid = signatureResult.Unwrap();\n        if (!spkValid)\n        {\n            return Result<Unit, EcliptixProtocolFailure>.Err(\n                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem.SignedPreKeyFailedMessage));\n        }\n\n        byte[]? dhKeyBytes = null;\n        try\n        {\n            SecureByteStringInterop.SecureCopyWithCleanup(peerMessage.InitialDhPublicKey, out dhKeyBytes);\n\n            Result<Unit, EcliptixProtocolFailure> dhValidationResult =\n                DhValidator.ValidateX25519PublicKey(dhKeyBytes);\n            if (dhValidationResult.IsErr)\n            {\n                return Result<Unit, EcliptixProtocolFailure>.Err(dhValidationResult.UnwrapErr());\n            }\n\n            Result<Unit, EcliptixProtocolFailure> finalizeResult =\n                _protocolConnection?.FinalizeChainAndDhKeys(rootKey, dhKeyBytes)\n                ?? Result<Unit, EcliptixProtocolFailure>.Err(\n                    EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem\n                        .ProtocolConnectionNotInitializedMessage));\n            if (finalizeResult.IsErr)\n            {\n                return Result<Unit, EcliptixProtocolFailure>.Err(finalizeResult.UnwrapErr());\n            }\n\n            Result<Unit, EcliptixProtocolFailure> setPeerResult = _protocolConnection?.SetPeerBundle(peerBundle)\n                                                                  ?? Result<Unit, EcliptixProtocolFailure>.Err(\n                                                                      EcliptixProtocolFailure.Generic(\n                                                                          ProtocolSystemConstants.ProtocolSystem\n                                                                              .ProtocolConnectionNotInitializedMessage));\n            return setPeerResult.IsErr\n                ? Result<Unit, EcliptixProtocolFailure>.Err(setPeerResult.UnwrapErr())\n                : Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);\n        }\n        finally\n        {\n            if (dhKeyBytes != null)\n            {\n                SodiumInterop.SecureWipe(dhKeyBytes);\n            }\n        }\n    }\n\n    public Result<Unit, EcliptixProtocolFailure> CompleteDataCenterPubKeyExchange(PubKeyExchange peerMessage)\n    {\n        Result<Unit, EcliptixProtocolFailure> reflectionCheck = CheckReflectionAttack(peerMessage);\n        if (reflectionCheck.IsErr)\n        {\n            return reflectionCheck;\n        }\n\n        SodiumSecureMemoryHandle? rootKeyHandle = null;\n        try\n        {\n            Result<LocalPublicKeyBundle, EcliptixProtocolFailure> peerBundleResult = ParseAndValidatePeerBundle(peerMessage);\n            if (peerBundleResult.IsErr)\n            {\n                return Result<Unit, EcliptixProtocolFailure>.Err(peerBundleResult.UnwrapErr());\n            }\n\n            LocalPublicKeyBundle peerBundle = peerBundleResult.Unwrap();\n\n            Result<SodiumSecureMemoryHandle, EcliptixProtocolFailure> secretResult = DeriveSharedSecretKey(peerBundle);\n            if (secretResult.IsErr)\n            {\n                return Result<Unit, EcliptixProtocolFailure>.Err(secretResult.UnwrapErr());\n            }\n\n            rootKeyHandle = secretResult.Unwrap();\n\n            return FinalizeExchange(rootKeyHandle, peerMessage.InitialDhPublicKey, peerBundle);\n        }\n        finally\n        {\n            rootKeyHandle?.Dispose();\n        }\n    }\n\n    private Result<Unit, EcliptixProtocolFailure> CheckReflectionAttack(PubKeyExchange peerMessage)\n    {\n        Result<byte[]?, EcliptixProtocolFailure> ourDhKeyResult = _protocolConnection?.GetCurrentSenderDhPublicKey() ??\n                                                                  Result<byte[]?, EcliptixProtocolFailure>.Err(\n                                                                      EcliptixProtocolFailure.Generic(\n                                                                          ProtocolSystemConstants.ProtocolSystem\n                                                                              .NoConnectionMessage));\n        if (!ourDhKeyResult.IsOk)\n        {\n            return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);\n        }\n\n        byte[]? ourDhKey = ourDhKeyResult.Unwrap();\n        if (ourDhKey == null)\n        {\n            return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);\n        }\n\n        Result<bool, SodiumFailure> comparisonResult =\n            SodiumInterop.ConstantTimeEquals(peerMessage.InitialDhPublicKey.Span, ourDhKey);\n\n        if (comparisonResult.IsOk && comparisonResult.Unwrap())\n        {\n            return Result<Unit, EcliptixProtocolFailure>.Err(\n                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem.ReflectionAttackMessage));\n        }\n\n        return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);\n    }\n\n    private static Result<LocalPublicKeyBundle, EcliptixProtocolFailure> ParseAndValidatePeerBundle(PubKeyExchange peerMessage)\n    {\n        Result<PublicKeyBundle, EcliptixProtocolFailure> parseResult =\n            Result<PublicKeyBundle, EcliptixProtocolFailure>.Try(\n                () =>\n                {\n                    SecureByteStringInterop.SecureCopyWithCleanup(peerMessage.Payload, out byte[] payloadBytes);\n                    try\n                    {\n                        return Helpers.ParseFromBytes<PublicKeyBundle>(payloadBytes);\n                    }\n                    finally\n                    {\n                        SodiumInterop.SecureWipe(payloadBytes);\n                    }\n                },\n                ex => EcliptixProtocolFailure.Decode(\n                    ProtocolSystemConstants.ProtocolSystem.ParseProtobufFailedMessage, ex));\n\n        if (parseResult.IsErr)\n        {\n            return Result<LocalPublicKeyBundle, EcliptixProtocolFailure>.Err(parseResult.UnwrapErr());\n        }\n\n        PublicKeyBundle protobufBundle = parseResult.Unwrap();\n\n        Result<LocalPublicKeyBundle, EcliptixProtocolFailure> bundleResult =\n            LocalPublicKeyBundle.FromProtobufExchange(protobufBundle);\n        if (bundleResult.IsErr)\n        {\n            return bundleResult;\n        }\n\n        LocalPublicKeyBundle peerBundle = bundleResult.Unwrap();\n\n        Result<bool, EcliptixProtocolFailure> signatureResult = EcliptixSystemIdentityKeys.VerifyRemoteSpkSignature(\n            peerBundle.IdentityEd25519, peerBundle.SignedPreKeyPublic, peerBundle.SignedPreKeySignature);\n        if (signatureResult.IsErr)\n        {\n            return Result<LocalPublicKeyBundle, EcliptixProtocolFailure>.Err(signatureResult.UnwrapErr());\n        }\n\n        bool spkValid = signatureResult.Unwrap();\n        if (!spkValid)\n        {\n            return Result<LocalPublicKeyBundle, EcliptixProtocolFailure>.Err(\n                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem.SignedPreKeyFailedMessage));\n        }\n\n        return Result<LocalPublicKeyBundle, EcliptixProtocolFailure>.Ok(peerBundle);\n    }\n\n    private Result<SodiumSecureMemoryHandle, EcliptixProtocolFailure> DeriveSharedSecretKey(LocalPublicKeyBundle peerBundle)\n    {\n        Result<SodiumSecureMemoryHandle, EcliptixProtocolFailure> secretResult =\n            ecliptixSystemIdentityKeys.X3dhDeriveSharedSecret(peerBundle, Constants.X3dhInfo);\n\n        return secretResult.IsErr\n            ? Result<SodiumSecureMemoryHandle, EcliptixProtocolFailure>.Err(secretResult.UnwrapErr())\n            : Result<SodiumSecureMemoryHandle, EcliptixProtocolFailure>.Ok(secretResult.Unwrap());\n    }\n\n    private Result<Unit, EcliptixProtocolFailure> FinalizeExchange(\n        SodiumSecureMemoryHandle derivedKeyHandle,\n        ByteString peerDhPublicKey,\n        LocalPublicKeyBundle peerBundle)\n    {\n        byte[] rootKeyBytes = new byte[Constants.X25519KeySize];\n        byte[]? dhKeyBytes = null;\n\n        try\n        {\n            Result<Unit, EcliptixProtocolFailure> readResult =\n                derivedKeyHandle.Read(rootKeyBytes).MapSodiumFailure();\n            if (readResult.IsErr)\n            {\n                return readResult;\n            }\n\n            SecureByteStringInterop.SecureCopyWithCleanup(peerDhPublicKey, out dhKeyBytes);\n\n            Result<Unit, EcliptixProtocolFailure> dhValidationResult =\n                DhValidator.ValidateX25519PublicKey(dhKeyBytes);\n            if (dhValidationResult.IsErr)\n            {\n                return dhValidationResult;\n            }\n\n            Result<Unit, EcliptixProtocolFailure> finalizeResult =\n                _protocolConnection?.FinalizeChainAndDhKeys(rootKeyBytes, dhKeyBytes)\n                ?? Result<Unit, EcliptixProtocolFailure>.Err(\n                    EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem\n                        .ProtocolConnectionNotInitializedMessage));\n            if (finalizeResult.IsErr)\n            {\n                return finalizeResult;\n            }\n\n            Result<Unit, EcliptixProtocolFailure> setPeerResult = _protocolConnection?.SetPeerBundle(peerBundle)\n                                                                  ?? Result<Unit, EcliptixProtocolFailure>.Err(\n                                                                      EcliptixProtocolFailure.Generic(\n                                                                          ProtocolSystemConstants.ProtocolSystem\n                                                                              .ProtocolConnectionNotInitializedMessage));\n\n            return setPeerResult.IsErr\n                ? setPeerResult\n                : Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);\n        }\n        finally\n        {\n            SodiumInterop.SecureWipe(rootKeyBytes);\n            if (dhKeyBytes != null)\n            {\n                SodiumInterop.SecureWipe(dhKeyBytes);\n            }\n        }\n    }\n\n    public Result<SecureEnvelope, EcliptixProtocolFailure> ProduceOutboundEnvelope(byte[] plainPayload)\n    {\n        if (plainPayload.Length > ProtocolSystemConstants.ProtocolSystem.MaxPayloadSize)\n        {\n            return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(\n                EcliptixProtocolFailure.InvalidInput(\n                    $\"Payload size ({plainPayload.Length} bytes) exceeds maximum allowed ({ProtocolSystemConstants.ProtocolSystem.MaxPayloadSize} bytes)\"));\n        }\n\n        EcliptixProtocolConnection? connection = GetConnectionSafe();\n        if (connection == null)\n        {\n            return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(\n                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem\n                    .ProtocolConnectionNotInitializedMessage));\n        }\n\n        return ProduceSingleEnvelope(plainPayload, connection);\n    }\n\n    private Result<SecureEnvelope, EcliptixProtocolFailure> ProduceSingleEnvelope(byte[] plainPayload,\n        EcliptixProtocolConnection connection)\n    {\n        byte[]? nonce = null;\n        byte[]? ad = null;\n        byte[]? encrypted = null;\n        byte[]? newSenderDhPublicKey = null;\n        byte[]? metadataKey = null;\n        byte[]? encryptedMetadata = null;\n        try\n        {\n            Result<(RatchetChainKey RatchetKey, bool IncludeDhKey), EcliptixProtocolFailure> prepResult =\n                connection.PrepareNextSendMessage();\n            if (prepResult.IsErr)\n            {\n                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(prepResult.UnwrapErr());\n            }\n\n            (RatchetChainKey RatchetKey, bool IncludeDhKey) prep = prepResult.Unwrap();\n\n            Result<byte[], EcliptixProtocolFailure> nonceResult = connection.GenerateNextNonce();\n            if (nonceResult.IsErr)\n            {\n                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(nonceResult.UnwrapErr());\n            }\n\n            nonce = nonceResult.Unwrap();\n\n            Result<byte[], EcliptixProtocolFailure> dhKeyResult = GetOptionalSenderDhKey(prep.IncludeDhKey);\n            if (dhKeyResult.IsErr)\n            {\n                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(dhKeyResult.UnwrapErr());\n            }\n\n            newSenderDhPublicKey = dhKeyResult.Unwrap();\n\n            RatchetChainKey? messageKey = prep.RatchetKey;\n\n            Result<LocalPublicKeyBundle, EcliptixProtocolFailure> peerBundleResult = connection.GetPeerBundle();\n            if (peerBundleResult.IsErr)\n            {\n                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(peerBundleResult.UnwrapErr());\n            }\n\n            LocalPublicKeyBundle peerBundle = peerBundleResult.Unwrap();\n\n            bool connectionIsInitiator = connection.IsInitiator();\n            ad = connectionIsInitiator\n                ? CreateAssociatedData(ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy(),\n                    peerBundle.IdentityX25519)\n                : CreateAssociatedData(peerBundle.IdentityX25519,\n                    ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy());\n\n            Result<byte[], EcliptixProtocolFailure> encryptResult =\n                Encrypt(messageKey!, nonce, plainPayload, ad);\n            if (encryptResult.IsErr)\n            {\n                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(encryptResult.UnwrapErr());\n            }\n\n            encrypted = encryptResult.Unwrap();\n\n            uint requestId = Helpers.GenerateRandomUInt32(true);\n\n            EnvelopeMetadata metadata = EnvelopeBuilder.CreateEnvelopeMetadata(\n                requestId,\n                ByteString.CopyFrom(nonce),\n                messageKey!.Index);\n\n            Result<byte[], EcliptixProtocolFailure> metadataKeyResult = connection.GetMetadataEncryptionKey();\n            if (metadataKeyResult.IsErr)\n            {\n                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(metadataKeyResult.UnwrapErr());\n            }\n\n            metadataKey = metadataKeyResult.Unwrap();\n\n            byte[] metadataNonce = new byte[Constants.AesGcmNonceSize];\n            RandomNumberGenerator.Fill(metadataNonce);\n\n            Result<byte[], EcliptixProtocolFailure> encryptMetadataResult =\n                EnvelopeBuilder.EncryptMetadata(metadata, metadataKey, metadataNonce, ad);\n            if (encryptMetadataResult.IsErr)\n            {\n                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(encryptMetadataResult.UnwrapErr());\n            }\n\n            encryptedMetadata = encryptMetadataResult.Unwrap();\n\n            SecureEnvelope envelope = new()\n            {\n                MetaData = ByteString.CopyFrom(encryptedMetadata),\n                EncryptedPayload = ByteString.CopyFrom(encrypted),\n                HeaderNonce = ByteString.CopyFrom(metadataNonce),\n                Timestamp = GetProtoTimestamp(),\n                ResultCode = ByteString.CopyFrom(BitConverter.GetBytes((int)EnvelopeResultCode.Success)),\n                DhPublicKey = newSenderDhPublicKey is\n                { Length: > ProtocolSystemConstants.ProtocolSystem.EmptyArrayLength }\n                    ? ByteString.CopyFrom(newSenderDhPublicKey)\n                    : ByteString.Empty\n            };\n\n            return Result<SecureEnvelope, EcliptixProtocolFailure>.Ok(envelope);\n        }\n        finally\n        {\n            if (nonce != null)\n            {\n                SodiumInterop.SecureWipe(nonce);\n            }\n\n            if (ad != null)\n            {\n                SodiumInterop.SecureWipe(ad);\n            }\n\n            if (encrypted != null)\n            {\n                SodiumInterop.SecureWipe(encrypted);\n            }\n\n            if (newSenderDhPublicKey != null)\n            {\n                SodiumInterop.SecureWipe(newSenderDhPublicKey);\n            }\n\n            if (metadataKey != null)\n            {\n                SodiumInterop.SecureWipe(metadataKey);\n            }\n\n            if (encryptedMetadata != null)\n            {\n                Array.Clear(encryptedMetadata);\n            }\n        }\n    }\n\n    public Result<byte[], EcliptixProtocolFailure> ProcessInboundEnvelope(SecureEnvelope secureEnvelope)\n    {\n        EcliptixProtocolConnection? connection = GetConnectionSafe();\n        if (connection == null)\n        {\n            return Result<byte[], EcliptixProtocolFailure>.Err(\n                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem\n                    .ProtocolConnectionNotInitializedMessage));\n        }\n\n        return ProcessInboundEnvelopeInternal(secureEnvelope, connection);\n    }\n\n    private Result<byte[], EcliptixProtocolFailure> ProcessInboundEnvelopeInternal(SecureEnvelope secureEnvelope,\n        EcliptixProtocolConnection connection)\n    {\n        byte[]? dhPublicKey = null;\n        byte[]? headerNonce = null;\n        byte[]? metadataKey = null;\n        byte[]? ad = null;\n        byte[]? encryptedMetadata = null;\n        try\n        {\n            Result<Unit, EcliptixProtocolFailure> ratchetResult = HandleDhRatchet(secureEnvelope, out dhPublicKey);\n            if (ratchetResult.IsErr)\n            {\n                return Result<byte[], EcliptixProtocolFailure>.Err(ratchetResult.UnwrapErr());\n            }\n\n            Result<DecryptionMaterials, EcliptixProtocolFailure> materialsResult =\n                ExtractDecryptionMaterials(secureEnvelope, connection, out headerNonce, out metadataKey, out ad, out encryptedMetadata);\n            if (materialsResult.IsErr)\n            {\n                return Result<byte[], EcliptixProtocolFailure>.Err(materialsResult.UnwrapErr());\n            }\n\n            Result<EnvelopeMetadata, EcliptixProtocolFailure> metadataResult =\n                EnvelopeBuilder.DecryptMetadata(encryptedMetadata!, metadataKey!, headerNonce!, ad!);\n            if (metadataResult.IsErr)\n            {\n                return Result<byte[], EcliptixProtocolFailure>.Err(metadataResult.UnwrapErr());\n            }\n\n            EnvelopeMetadata metadata = metadataResult.Unwrap();\n            byte[] encryptedPayload = secureEnvelope.EncryptedPayload.ToByteArray();\n\n            return ProcessInboundEnvelopeFromMaterials(metadata, encryptedPayload, connection);\n        }\n        finally\n        {\n            CleanupDecryptionMaterials(dhPublicKey, headerNonce, metadataKey, ad, encryptedMetadata);\n        }\n    }\n\n    private Result<Unit, EcliptixProtocolFailure> HandleDhRatchet(SecureEnvelope secureEnvelope, out byte[]? dhPublicKey)\n    {\n        dhPublicKey = null;\n\n        if (secureEnvelope.DhPublicKey == null || secureEnvelope.DhPublicKey.IsEmpty)\n        {\n            return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);\n        }\n\n        dhPublicKey = secureEnvelope.DhPublicKey.ToByteArray();\n        Result<Unit, EcliptixProtocolFailure> ratchetResult = PerformRatchetIfNeeded(dhPublicKey);\n\n        return ratchetResult.IsErr\n            ? Result<Unit, EcliptixProtocolFailure>.Err(ratchetResult.UnwrapErr())\n            : Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);\n    }\n\n    private readonly record struct DecryptionMaterials(byte[] MetadataKey, byte[] Ad);\n\n    private Result<DecryptionMaterials, EcliptixProtocolFailure> ExtractDecryptionMaterials(\n        SecureEnvelope secureEnvelope,\n        EcliptixProtocolConnection connection,\n        out byte[]? headerNonce,\n        out byte[]? metadataKey,\n        out byte[]? ad,\n        out byte[]? encryptedMetadata)\n    {\n        headerNonce = null;\n        metadataKey = null;\n        ad = null;\n        encryptedMetadata = null;\n\n        if (secureEnvelope.HeaderNonce == null || secureEnvelope.HeaderNonce.IsEmpty ||\n            secureEnvelope.HeaderNonce.Length != Constants.AesGcmNonceSize)\n        {\n            return Result<DecryptionMaterials, EcliptixProtocolFailure>.Err(\n                EcliptixProtocolFailure.Decode(\"Invalid or missing header nonce for metadata decryption\"));\n        }\n\n        headerNonce = secureEnvelope.HeaderNonce.ToByteArray();\n\n        Result<byte[], EcliptixProtocolFailure> metadataKeyResult = connection.GetMetadataEncryptionKey();\n        if (metadataKeyResult.IsErr)\n        {\n            return Result<DecryptionMaterials, EcliptixProtocolFailure>.Err(metadataKeyResult.UnwrapErr());\n        }\n\n        metadataKey = metadataKeyResult.Unwrap();\n\n        Result<LocalPublicKeyBundle, EcliptixProtocolFailure> peerBundleResult = connection.GetPeerBundle();\n        if (peerBundleResult.IsErr)\n        {\n            return Result<DecryptionMaterials, EcliptixProtocolFailure>.Err(peerBundleResult.UnwrapErr());\n        }\n\n        LocalPublicKeyBundle peerBundle = peerBundleResult.Unwrap();\n\n        bool connectionIsInitiator = connection.IsInitiator();\n        ad = connectionIsInitiator\n            ? CreateAssociatedData(ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy(), peerBundle.IdentityX25519)\n            : CreateAssociatedData(peerBundle.IdentityX25519, ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy());\n\n        encryptedMetadata = secureEnvelope.MetaData.ToByteArray();\n\n        return Result<DecryptionMaterials, EcliptixProtocolFailure>.Ok(new DecryptionMaterials(metadataKey, ad));\n    }\n\n    private static void CleanupDecryptionMaterials(byte[]? dhPublicKey, byte[]? headerNonce, byte[]? metadataKey, byte[]? ad, byte[]? encryptedMetadata)\n    {\n        if (dhPublicKey != null)\n        {\n            SodiumInterop.SecureWipe(dhPublicKey);\n        }\n\n        if (headerNonce != null)\n        {\n            SodiumInterop.SecureWipe(headerNonce);\n        }\n\n        if (metadataKey != null)\n        {\n            SodiumInterop.SecureWipe(metadataKey);\n        }\n\n        if (ad != null)\n        {\n            SodiumInterop.SecureWipe(ad);\n        }\n\n        if (encryptedMetadata != null)\n        {\n            Array.Clear(encryptedMetadata);\n        }\n    }\n\n    private Result<Unit, EcliptixProtocolFailure> PerformRatchetIfNeeded(byte[]? receivedDhKey)\n    {\n        EcliptixProtocolConnection? connection = GetConnectionSafe();\n        if (receivedDhKey == null || connection == null)\n        {\n            return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);\n        }\n\n        Result<byte[]?, EcliptixProtocolFailure> currentKeyResult = connection.GetCurrentPeerDhPublicKey();\n        if (currentKeyResult.IsErr)\n        {\n            return Result<Unit, EcliptixProtocolFailure>.Err(currentKeyResult.UnwrapErr());\n        }\n\n        byte[]? currentPeerDhKey = currentKeyResult.Unwrap();\n\n        if (currentPeerDhKey != null)\n        {\n            Result<bool, SodiumFailure> comparisonResult =\n                SodiumInterop.ConstantTimeEquals(receivedDhKey.AsSpan(), currentPeerDhKey);\n            if (comparisonResult.IsOk && comparisonResult.Unwrap())\n            {\n                return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);\n            }\n        }\n\n        return PerformAtomicRatchet(receivedDhKey);\n    }\n\n    private Result<Unit, EcliptixProtocolFailure> PerformAtomicRatchet(byte[] receivedDhKey)\n    {\n        EcliptixProtocolConnection? connection = GetConnectionSafe();\n        if (connection == null)\n        {\n            return Result<Unit, EcliptixProtocolFailure>.Err(\n                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem\n                    .ProtocolConnectionNotInitializedMessage));\n        }\n\n        connection.NotifyRatchetRotation();\n\n        Result<Unit, EcliptixProtocolFailure> ratchetResult = connection.PerformReceivingRatchet(receivedDhKey);\n        if (ratchetResult.IsErr)\n        {\n            return ratchetResult;\n        }\n\n        connection.NotifyRatchetRotation();\n        return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);\n    }\n\n    private Result<byte[], EcliptixProtocolFailure> GetOptionalSenderDhKey(bool include)\n    {\n        EcliptixProtocolConnection? connection = GetConnectionSafe();\n\n        if (!include || connection == null)\n        {\n            return Result<byte[], EcliptixProtocolFailure>.Ok([]);\n        }\n\n        Result<byte[]?, EcliptixProtocolFailure> keyResult = connection.GetCurrentSenderDhPublicKey();\n        if (keyResult.IsErr)\n        {\n            return Result<byte[], EcliptixProtocolFailure>.Err(keyResult.UnwrapErr());\n        }\n\n        byte[]? key = keyResult.Unwrap();\n\n        return Result<byte[], EcliptixProtocolFailure>.Ok(key ?? []);\n    }\n\n    private static byte[] CreateAssociatedData(byte[] id1, byte[] id2)\n    {\n        int maxIdLength = ProtocolSystemConstants.ProtocolSystem.MaxIdentityKeyLength;\n        if (id1.Length > maxIdLength || id2.Length > maxIdLength)\n        {\n            throw new ArgumentException(\n                string.Format(ProtocolSystemConstants.ProtocolSystem.IdentityKeysTooLargeMessage, maxIdLength));\n        }\n\n        if (id1.Length + id2.Length > int.MaxValue / ProtocolSystemConstants.ProtocolSystem.IntegerOverflowDivisor)\n        {\n            throw new ArgumentException(ProtocolSystemConstants.ProtocolSystem.IntegerOverflowMessage);\n        }\n\n        byte[] ad = new byte[id1.Length + id2.Length];\n        Buffer.BlockCopy(id1, ProtocolSystemConstants.ProtocolSystem.BufferCopyStartOffset, ad,\n            ProtocolSystemConstants.ProtocolSystem.BufferCopyStartOffset, id1.Length);\n        Buffer.BlockCopy(id2, ProtocolSystemConstants.ProtocolSystem.BufferCopyStartOffset, ad, id1.Length, id2.Length);\n        return ad;\n    }\n\n    private static Result<byte[], EcliptixProtocolFailure> Encrypt(RatchetChainKey key, byte[] nonce,\n        byte[] plaintext, byte[] ad)\n    {\n        using SecurePooledArray<byte> keyMaterial = SecureArrayPool.Rent<byte>(Constants.AesKeySize);\n        byte[]? ciphertext = null;\n        try\n        {\n            Span<byte> keySpan = keyMaterial.AsSpan();\n            Result<Unit, EcliptixProtocolFailure> readResult = key.ReadKeyMaterial(keySpan);\n            if (readResult.IsErr)\n            {\n                return Result<byte[], EcliptixProtocolFailure>.Err(readResult.UnwrapErr());\n            }\n\n            ciphertext = new byte[plaintext.Length];\n            Span<byte> tag = stackalloc byte[Constants.AesGcmTagSize];\n\n            using (AesGcm aesGcm = new(keySpan, Constants.AesGcmTagSize))\n            {\n                aesGcm.Encrypt(nonce, plaintext, ciphertext, tag, ad);\n            }\n\n            byte[] result = new byte[ciphertext.Length + tag.Length];\n            Buffer.BlockCopy(ciphertext, ProtocolSystemConstants.ProtocolSystem.BufferCopyStartOffset, result,\n                ProtocolSystemConstants.ProtocolSystem.BufferCopyStartOffset, ciphertext.Length);\n            tag.CopyTo(result.AsSpan(ciphertext.Length));\n\n            return Result<byte[], EcliptixProtocolFailure>.Ok(result);\n        }\n        catch (Exception ex)\n        {\n            if (ciphertext != null)\n            {\n                SodiumInterop.SecureWipe(ciphertext);\n            }\n\n            return Result<byte[], EcliptixProtocolFailure>.Err(\n                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem.AesGcmEncryptionFailedMessage,\n                    ex));\n        }\n    }\n\n    public static Result<EcliptixProtocolSystem, EcliptixProtocolFailure> CreateFrom(EcliptixSystemIdentityKeys keys,\n        EcliptixProtocolConnection connection)\n    {\n        EcliptixProtocolSystem system = new(keys) { _protocolConnection = connection };\n        return Result<EcliptixProtocolSystem, EcliptixProtocolFailure>.Ok(system);\n    }\n\n    public EcliptixProtocolConnection? GetConnection() => GetConnectionSafe();\n\n    private Result<byte[], EcliptixProtocolFailure> ProcessInboundEnvelopeFromMaterials(EnvelopeMetadata metadata,\n        byte[] encryptedPayload,\n        EcliptixProtocolConnection connection)\n    {\n        byte[]? ad = null;\n        try\n        {\n            Result<Unit, EcliptixProtocolFailure> replayCheck = connection.CheckReplayProtection(\n                [.. metadata.Nonce],\n                metadata.RatchetIndex);\n            if (replayCheck.IsErr)\n            {\n                return Result<byte[], EcliptixProtocolFailure>.Err(replayCheck.UnwrapErr());\n            }\n\n            Result<RatchetChainKey, EcliptixProtocolFailure> messageResult =\n                connection.ProcessReceivedMessage(metadata.RatchetIndex);\n            if (messageResult.IsErr)\n            {\n                return Result<byte[], EcliptixProtocolFailure>.Err(messageResult.UnwrapErr());\n            }\n\n            RatchetChainKey messageKey = messageResult.Unwrap();\n\n            Result<LocalPublicKeyBundle, EcliptixProtocolFailure> peerBundleResult = connection.GetPeerBundle();\n            if (peerBundleResult.IsErr)\n            {\n                return Result<byte[], EcliptixProtocolFailure>.Err(peerBundleResult.UnwrapErr());\n            }\n\n            LocalPublicKeyBundle peerBundle = peerBundleResult.Unwrap();\n\n            bool isInitiator = connection.IsInitiator();\n            ad = isInitiator\n                ? CreateAssociatedData(ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy(),\n                    peerBundle.IdentityX25519)\n                : CreateAssociatedData(peerBundle.IdentityX25519,\n                    ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy());\n\n            Result<byte[], EcliptixProtocolFailure> result =\n                DecryptFromMaterials(messageKey, metadata, encryptedPayload, ad);\n\n            return result;\n        }\n        finally\n        {\n            if (ad != null)\n            {\n                SodiumInterop.SecureWipe(ad);\n            }\n        }\n    }\n\n    private static Result<byte[], EcliptixProtocolFailure> DecryptFromMaterials(RatchetChainKey key,\n        EnvelopeMetadata metadata,\n        byte[] encryptedPayload, byte[] ad)\n    {\n        ReadOnlySpan<byte> fullCipherSpan = encryptedPayload.AsSpan();\n        const int tagSize = Constants.AesGcmTagSize;\n        int cipherLength = fullCipherSpan.Length - tagSize;\n\n        if (cipherLength < ProtocolSystemConstants.ProtocolSystem.CipherLengthMinimumThreshold)\n        {\n            return Result<byte[], EcliptixProtocolFailure>.Err(EcliptixProtocolFailure.BufferTooSmall(\n                string.Format(ProtocolSystemConstants.ProtocolSystem.CiphertextTooSmallMessage, fullCipherSpan.Length,\n                    tagSize)));\n        }\n\n        using SecurePooledArray<byte> keyMaterial = SecureArrayPool.Rent<byte>(Constants.AesKeySize);\n        byte[]? plaintext = null;\n        byte[]? nonce = null;\n\n        try\n        {\n            Span<byte> keySpan = keyMaterial.AsSpan();\n            Result<Unit, EcliptixProtocolFailure> readResult = key.ReadKeyMaterial(keySpan);\n            if (readResult.IsErr)\n            {\n                return Result<byte[], EcliptixProtocolFailure>.Err(readResult.UnwrapErr());\n            }\n\n            ReadOnlySpan<byte> ciphertextSpan = fullCipherSpan[..cipherLength];\n            ReadOnlySpan<byte> tagSpan = fullCipherSpan[cipherLength..];\n\n            SecureByteStringInterop.SecureCopyWithCleanup(metadata.Nonce, out nonce);\n\n            plaintext = new byte[cipherLength];\n\n            using (AesGcm aesGcm = new(keySpan, Constants.AesGcmTagSize))\n            {\n                aesGcm.Decrypt(nonce, ciphertextSpan, tagSpan, plaintext, ad);\n            }\n\n            byte[] result = new byte[plaintext.Length];\n            plaintext.CopyTo(result, 0);\n\n            return Result<byte[], EcliptixProtocolFailure>.Ok(result);\n        }\n        catch (Exception ex)\n        {\n            return Result<byte[], EcliptixProtocolFailure>.Err(\n                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem.AesGcmDecryptionFailedMessage,\n                    ex));\n        }\n        finally\n        {\n            if (plaintext != null)\n            {\n                SodiumInterop.SecureWipe(plaintext);\n            }\n\n            if (nonce != null)\n            {\n                SodiumInterop.SecureWipe(nonce);\n            }\n        }\n    }\n}\n"
  }
}
 [2025-11-04T12:57:47.26] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/EcliptixProtocolSystem.cs with new text:
using System.Diagnostics;
using System.Security.Cryptography;
using Ecliptix.Protobuf.Common;
using Ecliptix.Protobuf.Protocol;
using Ecliptix.Protobuf.ProtocolState;
using Ecliptix.Protocol.System.Sodium;
using Ecliptix.Protocol.System.Utilities;
using Ecliptix.Utilities;
using Ecliptix.Utilities.Failures.EcliptixProtocol;
using Ecliptix.Utilities.Failures.Sodium;
using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;

namespace Ecliptix.Protocol.System.Core;

internal sealed class EcliptixProtocolSystem(EcliptixSystemIdentityKeys ecliptixSystemIdentityKeys)
    : IDisposable
{
    private readonly Lock _lock = new();

    private EcliptixProtocolConnection? _protocolConnection;
    private IProtocolEventHandler? _eventHandler;

    public EcliptixSystemIdentityKeys GetIdentityKeys() => ecliptixSystemIdentityKeys;

    public void SetEventHandler(IProtocolEventHandler? handler)
    {
        EcliptixProtocolConnection? connectionToUpdate;

        lock (_lock)
        {
            _eventHandler = handler;
            connectionToUpdate = _protocolConnection;
        }

        connectionToUpdate?.SetEventHandler(handler);
    }

    public void Dispose()
    {
        EcliptixProtocolConnection? connectionToDispose;

        lock (_lock)
        {
            connectionToDispose = _protocolConnection;
            _protocolConnection = null;
        }

        connectionToDispose?.Dispose();
    }

    private EcliptixProtocolConnection? GetConnectionSafe()
    {
        lock (_lock)
        {
            return _protocolConnection;
        }
    }

    private static Timestamp GetProtoTimestamp()
    {
        return Timestamp.FromDateTimeOffset(DateTimeOffset.UtcNow);
    }

    public Result<PubKeyExchange, EcliptixProtocolFailure> BeginDataCenterPubKeyExchange(
        uint connectId,
        PubKeyExchangeType exchangeType)
    {
        ecliptixSystemIdentityKeys.GenerateEphemeralKeyPair();

        Result<LocalPublicKeyBundle, EcliptixProtocolFailure> bundleResult =
            ecliptixSystemIdentityKeys.CreatePublicBundle();
        if (bundleResult.IsErr)
        {
            return Result<PubKeyExchange, EcliptixProtocolFailure>.Err(bundleResult.UnwrapErr());
        }

        LocalPublicKeyBundle bundle = bundleResult.Unwrap();

        Result<EcliptixProtocolConnection, EcliptixProtocolFailure> sessionResult =
            EcliptixProtocolConnection.Create(connectId, true, RatchetConfig.Default, exchangeType);
        if (sessionResult.IsErr)
        {
            return Result<PubKeyExchange, EcliptixProtocolFailure>.Err(sessionResult.UnwrapErr());
        }

        EcliptixProtocolConnection session = sessionResult.Unwrap();

        IProtocolEventHandler? currentHandler;
        lock (_lock)
        {
            _protocolConnection = session;
            currentHandler = _eventHandler;
        }

        session.SetEventHandler(currentHandler);

        Result<byte[]?, EcliptixProtocolFailure> dhKeyResult = session.GetCurrentSenderDhPublicKey();
        if (dhKeyResult.IsErr)
        {
            return Result<PubKeyExchange, EcliptixProtocolFailure>.Err(dhKeyResult.UnwrapErr());
        }

        byte[]? dhPublicKey = dhKeyResult.Unwrap();
        if (dhPublicKey == null)
        {
            return Result<PubKeyExchange, EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.PrepareLocal(ProtocolSystemConstants.ProtocolSystem.DhPublicKeyNullMessage));
        }

        PubKeyExchange pubKeyExchange = new()
        {
            State = PubKeyExchangeState.Init,
            OfType = exchangeType,
            Payload = bundle.ToProtobufExchange().ToByteString(),
            InitialDhPublicKey = ByteString.CopyFrom(dhPublicKey)
        };

        return Result<PubKeyExchange, EcliptixProtocolFailure>.Ok(pubKeyExchange);
    }

    public Result<Unit, EcliptixProtocolFailure> CompleteAuthenticatedPubKeyExchange(PubKeyExchange peerMessage,
        byte[] rootKey)
    {
        Result<byte[]?, EcliptixProtocolFailure> ourDhKeyResult = _protocolConnection?.GetCurrentSenderDhPublicKey() ??
                                                                  Result<byte[]?, EcliptixProtocolFailure>.Err(
                                                                      EcliptixProtocolFailure.Generic(
                                                                          ProtocolSystemConstants.ProtocolSystem
                                                                              .NoConnectionMessage));
        if (ourDhKeyResult.IsOk)
        {
            byte[]? ourDhKey = ourDhKeyResult.Unwrap();
            if (ourDhKey != null)
            {
                Result<bool, SodiumFailure> comparisonResult =
                    SodiumInterop.ConstantTimeEquals(peerMessage.InitialDhPublicKey.Span, ourDhKey);
                if (comparisonResult.IsOk && comparisonResult.Unwrap())
                {
                    return Result<Unit, EcliptixProtocolFailure>.Err(
                        EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem
                            .ReflectionAttackMessage));
                }
            }
        }

        Result<PublicKeyBundle, EcliptixProtocolFailure> parseResult =
            Result<PublicKeyBundle, EcliptixProtocolFailure>.Try(
                () =>
                {
                    SecureByteStringInterop.SecureCopyWithCleanup(peerMessage.Payload, out byte[] payloadBytes);
                    try
                    {
                        return Helpers.ParseFromBytes<PublicKeyBundle>(payloadBytes);
                    }
                    finally
                    {
                        SodiumInterop.SecureWipe(payloadBytes);
                    }
                },
                ex => EcliptixProtocolFailure.Decode(ProtocolSystemConstants.ProtocolSystem.ParseProtobufFailedMessage,
                    ex));

        if (parseResult.IsErr)
        {
            return Result<Unit, EcliptixProtocolFailure>.Err(parseResult.UnwrapErr());
        }

        PublicKeyBundle protobufBundle = parseResult.Unwrap();

        Result<LocalPublicKeyBundle, EcliptixProtocolFailure> bundleResult =
            LocalPublicKeyBundle.FromProtobufExchange(protobufBundle);
        if (bundleResult.IsErr)
        {
            return Result<Unit, EcliptixProtocolFailure>.Err(bundleResult.UnwrapErr());
        }

        LocalPublicKeyBundle peerBundle = bundleResult.Unwrap();

        Result<bool, EcliptixProtocolFailure> signatureResult = EcliptixSystemIdentityKeys.VerifyRemoteSpkSignature(
            peerBundle.IdentityEd25519, peerBundle.SignedPreKeyPublic, peerBundle.SignedPreKeySignature);
        if (signatureResult.IsErr)
        {
            return Result<Unit, EcliptixProtocolFailure>.Err(signatureResult.UnwrapErr());
        }

        bool spkValid = signatureResult.Unwrap();
        if (!spkValid)
        {
            return Result<Unit, EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem.SignedPreKeyFailedMessage));
        }

        byte[]? dhKeyBytes = null;
        try
        {
            SecureByteStringInterop.SecureCopyWithCleanup(peerMessage.InitialDhPublicKey, out dhKeyBytes);

            Result<Unit, EcliptixProtocolFailure> dhValidationResult =
                DhValidator.ValidateX25519PublicKey(dhKeyBytes);
            if (dhValidationResult.IsErr)
            {
                return Result<Unit, EcliptixProtocolFailure>.Err(dhValidationResult.UnwrapErr());
            }

            Result<Unit, EcliptixProtocolFailure> finalizeResult =
                _protocolConnection?.FinalizeChainAndDhKeys(rootKey, dhKeyBytes)
                ?? Result<Unit, EcliptixProtocolFailure>.Err(
                    EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem
                        .ProtocolConnectionNotInitializedMessage));
            if (finalizeResult.IsErr)
            {
                return Result<Unit, EcliptixProtocolFailure>.Err(finalizeResult.UnwrapErr());
            }

            Result<Unit, EcliptixProtocolFailure> setPeerResult = _protocolConnection?.SetPeerBundle(peerBundle)
                                                                  ?? Result<Unit, EcliptixProtocolFailure>.Err(
                                                                      EcliptixProtocolFailure.Generic(
                                                                          ProtocolSystemConstants.ProtocolSystem
                                                                              .ProtocolConnectionNotInitializedMessage));
            return setPeerResult.IsErr
                ? Result<Unit, EcliptixProtocolFailure>.Err(setPeerResult.UnwrapErr())
                : Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);
        }
        finally
        {
            if (dhKeyBytes != null)
            {
                SodiumInterop.SecureWipe(dhKeyBytes);
            }
        }
    }

    public Result<Unit, EcliptixProtocolFailure> CompleteDataCenterPubKeyExchange(PubKeyExchange peerMessage)
    {
        Result<Unit, EcliptixProtocolFailure> reflectionCheck = CheckReflectionAttack(peerMessage);
        if (reflectionCheck.IsErr)
        {
            return reflectionCheck;
        }

        SodiumSecureMemoryHandle? rootKeyHandle = null;
        try
        {
            Result<LocalPublicKeyBundle, EcliptixProtocolFailure> peerBundleResult = ParseAndValidatePeerBundle(peerMessage);
            if (peerBundleResult.IsErr)
            {
                return Result<Unit, EcliptixProtocolFailure>.Err(peerBundleResult.UnwrapErr());
            }

            LocalPublicKeyBundle peerBundle = peerBundleResult.Unwrap();

            Result<SodiumSecureMemoryHandle, EcliptixProtocolFailure> secretResult = DeriveSharedSecretKey(peerBundle);
            if (secretResult.IsErr)
            {
                return Result<Unit, EcliptixProtocolFailure>.Err(secretResult.UnwrapErr());
            }

            rootKeyHandle = secretResult.Unwrap();

            return FinalizeExchange(rootKeyHandle, peerMessage.InitialDhPublicKey, peerBundle);
        }
        finally
        {
            rootKeyHandle?.Dispose();
        }
    }

    private Result<Unit, EcliptixProtocolFailure> CheckReflectionAttack(PubKeyExchange peerMessage)
    {
        Result<byte[]?, EcliptixProtocolFailure> ourDhKeyResult = _protocolConnection?.GetCurrentSenderDhPublicKey() ??
                                                                  Result<byte[]?, EcliptixProtocolFailure>.Err(
                                                                      EcliptixProtocolFailure.Generic(
                                                                          ProtocolSystemConstants.ProtocolSystem
                                                                              .NoConnectionMessage));
        if (!ourDhKeyResult.IsOk)
        {
            return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);
        }

        byte[]? ourDhKey = ourDhKeyResult.Unwrap();
        if (ourDhKey == null)
        {
            return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);
        }

        Result<bool, SodiumFailure> comparisonResult =
            SodiumInterop.ConstantTimeEquals(peerMessage.InitialDhPublicKey.Span, ourDhKey);

        if (comparisonResult.IsOk && comparisonResult.Unwrap())
        {
            return Result<Unit, EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem.ReflectionAttackMessage));
        }

        return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);
    }

    private static Result<LocalPublicKeyBundle, EcliptixProtocolFailure> ParseAndValidatePeerBundle(PubKeyExchange peerMessage)
    {
        Result<PublicKeyBundle, EcliptixProtocolFailure> parseResult =
            Result<PublicKeyBundle, EcliptixProtocolFailure>.Try(
                () =>
                {
                    SecureByteStringInterop.SecureCopyWithCleanup(peerMessage.Payload, out byte[] payloadBytes);
                    try
                    {
                        return Helpers.ParseFromBytes<PublicKeyBundle>(payloadBytes);
                    }
                    finally
                    {
                        SodiumInterop.SecureWipe(payloadBytes);
                    }
                },
                ex => EcliptixProtocolFailure.Decode(
                    ProtocolSystemConstants.ProtocolSystem.ParseProtobufFailedMessage, ex));

        if (parseResult.IsErr)
        {
            return Result<LocalPublicKeyBundle, EcliptixProtocolFailure>.Err(parseResult.UnwrapErr());
        }

        PublicKeyBundle protobufBundle = parseResult.Unwrap();

        Result<LocalPublicKeyBundle, EcliptixProtocolFailure> bundleResult =
            LocalPublicKeyBundle.FromProtobufExchange(protobufBundle);
        if (bundleResult.IsErr)
        {
            return bundleResult;
        }

        LocalPublicKeyBundle peerBundle = bundleResult.Unwrap();

        Result<bool, EcliptixProtocolFailure> signatureResult = EcliptixSystemIdentityKeys.VerifyRemoteSpkSignature(
            peerBundle.IdentityEd25519, peerBundle.SignedPreKeyPublic, peerBundle.SignedPreKeySignature);
        if (signatureResult.IsErr)
        {
            return Result<LocalPublicKeyBundle, EcliptixProtocolFailure>.Err(signatureResult.UnwrapErr());
        }

        bool spkValid = signatureResult.Unwrap();
        if (!spkValid)
        {
            return Result<LocalPublicKeyBundle, EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem.SignedPreKeyFailedMessage));
        }

        return Result<LocalPublicKeyBundle, EcliptixProtocolFailure>.Ok(peerBundle);
    }

    private Result<SodiumSecureMemoryHandle, EcliptixProtocolFailure> DeriveSharedSecretKey(LocalPublicKeyBundle peerBundle)
    {
        Result<SodiumSecureMemoryHandle, EcliptixProtocolFailure> secretResult =
            ecliptixSystemIdentityKeys.X3dhDeriveSharedSecret(peerBundle, Constants.X3dhInfo);

        return secretResult.IsErr
            ? Result<SodiumSecureMemoryHandle, EcliptixProtocolFailure>.Err(secretResult.UnwrapErr())
            : Result<SodiumSecureMemoryHandle, EcliptixProtocolFailure>.Ok(secretResult.Unwrap());
    }

    private Result<Unit, EcliptixProtocolFailure> FinalizeExchange(
        SodiumSecureMemoryHandle derivedKeyHandle,
        ByteString peerDhPublicKey,
        LocalPublicKeyBundle peerBundle)
    {
        byte[] rootKeyBytes = new byte[Constants.X25519KeySize];
        byte[]? dhKeyBytes = null;

        try
        {
            Result<Unit, EcliptixProtocolFailure> readResult =
                derivedKeyHandle.Read(rootKeyBytes).MapSodiumFailure();
            if (readResult.IsErr)
            {
                return readResult;
            }

            SecureByteStringInterop.SecureCopyWithCleanup(peerDhPublicKey, out dhKeyBytes);

            Result<Unit, EcliptixProtocolFailure> dhValidationResult =
                DhValidator.ValidateX25519PublicKey(dhKeyBytes);
            if (dhValidationResult.IsErr)
            {
                return dhValidationResult;
            }

            Result<Unit, EcliptixProtocolFailure> finalizeResult =
                _protocolConnection?.FinalizeChainAndDhKeys(rootKeyBytes, dhKeyBytes)
                ?? Result<Unit, EcliptixProtocolFailure>.Err(
                    EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem
                        .ProtocolConnectionNotInitializedMessage));
            if (finalizeResult.IsErr)
            {
                return finalizeResult;
            }

            Result<Unit, EcliptixProtocolFailure> setPeerResult = _protocolConnection?.SetPeerBundle(peerBundle)
                                                                  ?? Result<Unit, EcliptixProtocolFailure>.Err(
                                                                      EcliptixProtocolFailure.Generic(
                                                                          ProtocolSystemConstants.ProtocolSystem
                                                                              .ProtocolConnectionNotInitializedMessage));

            return setPeerResult.IsErr
                ? setPeerResult
                : Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);
        }
        finally
        {
            SodiumInterop.SecureWipe(rootKeyBytes);
            if (dhKeyBytes != null)
            {
                SodiumInterop.SecureWipe(dhKeyBytes);
            }
        }
    }

    public Result<SecureEnvelope, EcliptixProtocolFailure> ProduceOutboundEnvelope(byte[] plainPayload)
    {
        if (plainPayload.Length > ProtocolSystemConstants.ProtocolSystem.MaxPayloadSize)
        {
            return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.InvalidInput(
                    $"Payload size ({plainPayload.Length} bytes) exceeds maximum allowed ({ProtocolSystemConstants.ProtocolSystem.MaxPayloadSize} bytes)"));
        }

        EcliptixProtocolConnection? connection = GetConnectionSafe();
        if (connection == null)
        {
            return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem
                    .ProtocolConnectionNotInitializedMessage));
        }

        return ProduceSingleEnvelope(plainPayload, connection);
    }

    private Result<SecureEnvelope, EcliptixProtocolFailure> ProduceSingleEnvelope(byte[] plainPayload,
        EcliptixProtocolConnection connection)
    {
        byte[]? nonce = null;
        byte[]? ad = null;
        byte[]? encrypted = null;
        byte[]? newSenderDhPublicKey = null;
        byte[]? metadataKey = null;
        byte[]? encryptedMetadata = null;
        try
        {
            Result<(RatchetChainKey RatchetKey, bool IncludeDhKey), EcliptixProtocolFailure> prepResult =
                connection.PrepareNextSendMessage();
            if (prepResult.IsErr)
            {
                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(prepResult.UnwrapErr());
            }

            (RatchetChainKey RatchetKey, bool IncludeDhKey) prep = prepResult.Unwrap();

            Result<byte[], EcliptixProtocolFailure> nonceResult = connection.GenerateNextNonce();
            if (nonceResult.IsErr)
            {
                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(nonceResult.UnwrapErr());
            }

            nonce = nonceResult.Unwrap();

            Result<byte[], EcliptixProtocolFailure> dhKeyResult = GetOptionalSenderDhKey(prep.IncludeDhKey);
            if (dhKeyResult.IsErr)
            {
                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(dhKeyResult.UnwrapErr());
            }

            newSenderDhPublicKey = dhKeyResult.Unwrap();

            RatchetChainKey? messageKey = prep.RatchetKey;

            Result<LocalPublicKeyBundle, EcliptixProtocolFailure> peerBundleResult = connection.GetPeerBundle();
            if (peerBundleResult.IsErr)
            {
                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(peerBundleResult.UnwrapErr());
            }

            LocalPublicKeyBundle peerBundle = peerBundleResult.Unwrap();

            bool connectionIsInitiator = connection.IsInitiator();
            ad = connectionIsInitiator
                ? CreateAssociatedData(ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy(),
                    peerBundle.IdentityX25519)
                : CreateAssociatedData(peerBundle.IdentityX25519,
                    ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy());

            Result<byte[], EcliptixProtocolFailure> encryptResult =
                Encrypt(messageKey!, nonce, plainPayload, ad);
            if (encryptResult.IsErr)
            {
                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(encryptResult.UnwrapErr());
            }

            encrypted = encryptResult.Unwrap();

            uint requestId = Helpers.GenerateRandomUInt32(true);

            EnvelopeMetadata metadata = EnvelopeBuilder.CreateEnvelopeMetadata(
                requestId,
                ByteString.CopyFrom(nonce),
                messageKey!.Index);

            Result<byte[], EcliptixProtocolFailure> metadataKeyResult = connection.GetMetadataEncryptionKey();
            if (metadataKeyResult.IsErr)
            {
                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(metadataKeyResult.UnwrapErr());
            }

            metadataKey = metadataKeyResult.Unwrap();

            byte[] metadataNonce = new byte[Constants.AesGcmNonceSize];
            RandomNumberGenerator.Fill(metadataNonce);

            Result<byte[], EcliptixProtocolFailure> encryptMetadataResult =
                EnvelopeBuilder.EncryptMetadata(metadata, metadataKey, metadataNonce, ad);
            if (encryptMetadataResult.IsErr)
            {
                return Result<SecureEnvelope, EcliptixProtocolFailure>.Err(encryptMetadataResult.UnwrapErr());
            }

            encryptedMetadata = encryptMetadataResult.Unwrap();

            SecureEnvelope envelope = new()
            {
                MetaData = ByteString.CopyFrom(encryptedMetadata),
                EncryptedPayload = ByteString.CopyFrom(encrypted),
                HeaderNonce = ByteString.CopyFrom(metadataNonce),
                Timestamp = GetProtoTimestamp(),
                ResultCode = ByteString.CopyFrom(BitConverter.GetBytes((int)EnvelopeResultCode.Success)),
                DhPublicKey = newSenderDhPublicKey is
                { Length: > ProtocolSystemConstants.ProtocolSystem.EmptyArrayLength }
                    ? ByteString.CopyFrom(newSenderDhPublicKey)
                    : ByteString.Empty
            };

            return Result<SecureEnvelope, EcliptixProtocolFailure>.Ok(envelope);
        }
        finally
        {
            if (nonce != null)
            {
                SodiumInterop.SecureWipe(nonce);
            }

            if (ad != null)
            {
                SodiumInterop.SecureWipe(ad);
            }

            if (encrypted != null)
            {
                SodiumInterop.SecureWipe(encrypted);
            }

            if (newSenderDhPublicKey != null)
            {
                SodiumInterop.SecureWipe(newSenderDhPublicKey);
            }

            if (metadataKey != null)
            {
                SodiumInterop.SecureWipe(metadataKey);
            }

            if (encryptedMetadata != null)
            {
                Array.Clear(encryptedMetadata);
            }
        }
    }

    public Result<byte[], EcliptixProtocolFailure> ProcessInboundEnvelope(SecureEnvelope secureEnvelope)
    {
        EcliptixProtocolConnection? connection = GetConnectionSafe();
        if (connection == null)
        {
            return Result<byte[], EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem
                    .ProtocolConnectionNotInitializedMessage));
        }

        return ProcessInboundEnvelopeInternal(secureEnvelope, connection);
    }

    private Result<byte[], EcliptixProtocolFailure> ProcessInboundEnvelopeInternal(SecureEnvelope secureEnvelope,
        EcliptixProtocolConnection connection)
    {
        byte[]? dhPublicKey = null;
        byte[]? headerNonce = null;
        byte[]? metadataKey = null;
        byte[]? ad = null;
        byte[]? encryptedMetadata = null;
        try
        {
            Result<Unit, EcliptixProtocolFailure> ratchetResult = HandleDhRatchet(secureEnvelope, out dhPublicKey);
            if (ratchetResult.IsErr)
            {
                return Result<byte[], EcliptixProtocolFailure>.Err(ratchetResult.UnwrapErr());
            }

            Result<DecryptionMaterials, EcliptixProtocolFailure> materialsResult =
                ExtractDecryptionMaterials(secureEnvelope, connection, out headerNonce, out metadataKey, out ad, out encryptedMetadata);
            if (materialsResult.IsErr)
            {
                return Result<byte[], EcliptixProtocolFailure>.Err(materialsResult.UnwrapErr());
            }

            Result<EnvelopeMetadata, EcliptixProtocolFailure> metadataResult =
                EnvelopeBuilder.DecryptMetadata(encryptedMetadata!, metadataKey!, headerNonce!, ad!);
            if (metadataResult.IsErr)
            {
                return Result<byte[], EcliptixProtocolFailure>.Err(metadataResult.UnwrapErr());
            }

            EnvelopeMetadata metadata = metadataResult.Unwrap();
            byte[] encryptedPayload = secureEnvelope.EncryptedPayload.ToByteArray();

            return ProcessInboundEnvelopeFromMaterials(metadata, encryptedPayload, connection);
        }
        finally
        {
            CleanupDecryptionMaterials(dhPublicKey, headerNonce, metadataKey, ad, encryptedMetadata);
        }
    }

    private Result<Unit, EcliptixProtocolFailure> HandleDhRatchet(SecureEnvelope secureEnvelope, out byte[]? dhPublicKey)
    {
        dhPublicKey = null;

        if (secureEnvelope.DhPublicKey == null || secureEnvelope.DhPublicKey.IsEmpty)
        {
            return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);
        }

        dhPublicKey = secureEnvelope.DhPublicKey.ToByteArray();
        Result<Unit, EcliptixProtocolFailure> ratchetResult = PerformRatchetIfNeeded(dhPublicKey);

        return ratchetResult.IsErr
            ? Result<Unit, EcliptixProtocolFailure>.Err(ratchetResult.UnwrapErr())
            : Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);
    }

    private readonly record struct DecryptionMaterials(byte[] MetadataKey, byte[] Ad);

    private Result<DecryptionMaterials, EcliptixProtocolFailure> ExtractDecryptionMaterials(
        SecureEnvelope secureEnvelope,
        EcliptixProtocolConnection connection,
        out byte[]? headerNonce,
        out byte[]? metadataKey,
        out byte[]? ad,
        out byte[]? encryptedMetadata)
    {
        headerNonce = null;
        metadataKey = null;
        ad = null;
        encryptedMetadata = null;

        if (secureEnvelope.HeaderNonce == null || secureEnvelope.HeaderNonce.IsEmpty ||
            secureEnvelope.HeaderNonce.Length != Constants.AesGcmNonceSize)
        {
            return Result<DecryptionMaterials, EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.Decode("Invalid or missing header nonce for metadata decryption"));
        }

        headerNonce = secureEnvelope.HeaderNonce.ToByteArray();

        Result<byte[], EcliptixProtocolFailure> metadataKeyResult = connection.GetMetadataEncryptionKey();
        if (metadataKeyResult.IsErr)
        {
            return Result<DecryptionMaterials, EcliptixProtocolFailure>.Err(metadataKeyResult.UnwrapErr());
        }

        metadataKey = metadataKeyResult.Unwrap();

        Result<LocalPublicKeyBundle, EcliptixProtocolFailure> peerBundleResult = connection.GetPeerBundle();
        if (peerBundleResult.IsErr)
        {
            return Result<DecryptionMaterials, EcliptixProtocolFailure>.Err(peerBundleResult.UnwrapErr());
        }

        LocalPublicKeyBundle peerBundle = peerBundleResult.Unwrap();

        bool connectionIsInitiator = connection.IsInitiator();
        ad = connectionIsInitiator
            ? CreateAssociatedData(ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy(), peerBundle.IdentityX25519)
            : CreateAssociatedData(peerBundle.IdentityX25519, ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy());

        encryptedMetadata = secureEnvelope.MetaData.ToByteArray();

        return Result<DecryptionMaterials, EcliptixProtocolFailure>.Ok(new DecryptionMaterials(metadataKey, ad));
    }

    private static void CleanupDecryptionMaterials(byte[]? dhPublicKey, byte[]? headerNonce, byte[]? metadataKey, byte[]? ad, byte[]? encryptedMetadata)
    {
        if (dhPublicKey != null)
        {
            SodiumInterop.SecureWipe(dhPublicKey);
        }

        if (headerNonce != null)
        {
            SodiumInterop.SecureWipe(headerNonce);
        }

        if (metadataKey != null)
        {
            SodiumInterop.SecureWipe(metadataKey);
        }

        if (ad != null)
        {
            SodiumInterop.SecureWipe(ad);
        }

        if (encryptedMetadata != null)
        {
            Array.Clear(encryptedMetadata);
        }
    }

    private Result<Unit, EcliptixProtocolFailure> PerformRatchetIfNeeded(byte[]? receivedDhKey)
    {
        EcliptixProtocolConnection? connection = GetConnectionSafe();
        if (receivedDhKey == null || connection == null)
        {
            return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);
        }

        Result<byte[]?, EcliptixProtocolFailure> currentKeyResult = connection.GetCurrentPeerDhPublicKey();
        if (currentKeyResult.IsErr)
        {
            return Result<Unit, EcliptixProtocolFailure>.Err(currentKeyResult.UnwrapErr());
        }

        byte[]? currentPeerDhKey = currentKeyResult.Unwrap();

        if (currentPeerDhKey != null)
        {
            Result<bool, SodiumFailure> comparisonResult =
                SodiumInterop.ConstantTimeEquals(receivedDhKey.AsSpan(), currentPeerDhKey);
            if (comparisonResult.IsOk && comparisonResult.Unwrap())
            {
                return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);
            }
        }

        return PerformAtomicRatchet(receivedDhKey);
    }

    private Result<Unit, EcliptixProtocolFailure> PerformAtomicRatchet(byte[] receivedDhKey)
    {
        EcliptixProtocolConnection? connection = GetConnectionSafe();
        if (connection == null)
        {
            return Result<Unit, EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem
                    .ProtocolConnectionNotInitializedMessage));
        }

        connection.NotifyRatchetRotation();

        Result<Unit, EcliptixProtocolFailure> ratchetResult = connection.PerformReceivingRatchet(receivedDhKey);
        if (ratchetResult.IsErr)
        {
            return ratchetResult;
        }

        connection.NotifyRatchetRotation();
        return Result<Unit, EcliptixProtocolFailure>.Ok(Unit.Value);
    }

    private Result<byte[], EcliptixProtocolFailure> GetOptionalSenderDhKey(bool include)
    {
        EcliptixProtocolConnection? connection = GetConnectionSafe();

        if (!include || connection == null)
        {
            return Result<byte[], EcliptixProtocolFailure>.Ok([]);
        }

        Result<byte[]?, EcliptixProtocolFailure> keyResult = connection.GetCurrentSenderDhPublicKey();
        if (keyResult.IsErr)
        {
            return Result<byte[], EcliptixProtocolFailure>.Err(keyResult.UnwrapErr());
        }

        byte[]? key = keyResult.Unwrap();

        return Result<byte[], EcliptixProtocolFailure>.Ok(key ?? []);
    }

    private static byte[] CreateAssociatedData(byte[] id1, byte[] id2)
    {
        int maxIdLength = ProtocolSystemConstants.ProtocolSystem.MaxIdentityKeyLength;
        if (id1.Length > maxIdLength || id2.Length > maxIdLength)
        {
            throw new ArgumentException(
                string.Format(ProtocolSystemConstants.ProtocolSystem.IdentityKeysTooLargeMessage, maxIdLength));
        }

        if (id1.Length + id2.Length > int.MaxValue / ProtocolSystemConstants.ProtocolSystem.IntegerOverflowDivisor)
        {
            throw new ArgumentException(ProtocolSystemConstants.ProtocolSystem.IntegerOverflowMessage);
        }

        byte[] ad = new byte[id1.Length + id2.Length];
        Buffer.BlockCopy(id1, ProtocolSystemConstants.ProtocolSystem.BufferCopyStartOffset, ad,
            ProtocolSystemConstants.ProtocolSystem.BufferCopyStartOffset, id1.Length);
        Buffer.BlockCopy(id2, ProtocolSystemConstants.ProtocolSystem.BufferCopyStartOffset, ad, id1.Length, id2.Length);
        return ad;
    }

    private static Result<byte[], EcliptixProtocolFailure> Encrypt(RatchetChainKey key, byte[] nonce,
        byte[] plaintext, byte[] ad)
    {
        using SecurePooledArray<byte> keyMaterial = SecureArrayPool.Rent<byte>(Constants.AesKeySize);
        byte[]? ciphertext = null;
        try
        {
            Span<byte> keySpan = keyMaterial.AsSpan();
            Result<Unit, EcliptixProtocolFailure> readResult = key.ReadKeyMaterial(keySpan);
            if (readResult.IsErr)
            {
                return Result<byte[], EcliptixProtocolFailure>.Err(readResult.UnwrapErr());
            }

            ciphertext = new byte[plaintext.Length];
            Span<byte> tag = stackalloc byte[Constants.AesGcmTagSize];

            using (AesGcm aesGcm = new(keySpan, Constants.AesGcmTagSize))
            {
                aesGcm.Encrypt(nonce, plaintext, ciphertext, tag, ad);
            }

            byte[] result = new byte[ciphertext.Length + tag.Length];
            Buffer.BlockCopy(ciphertext, ProtocolSystemConstants.ProtocolSystem.BufferCopyStartOffset, result,
                ProtocolSystemConstants.ProtocolSystem.BufferCopyStartOffset, ciphertext.Length);
            tag.CopyTo(result.AsSpan(ciphertext.Length));

            return Result<byte[], EcliptixProtocolFailure>.Ok(result);
        }
        catch (Exception ex)
        {
            if (ciphertext != null)
            {
                SodiumInterop.SecureWipe(ciphertext);
            }

            return Result<byte[], EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem.AesGcmEncryptionFailedMessage,
                    ex));
        }
    }

    public static Result<EcliptixProtocolSystem, EcliptixProtocolFailure> CreateFrom(EcliptixSystemIdentityKeys keys,
        EcliptixProtocolConnection connection)
    {
        EcliptixProtocolSystem system = new(keys) { _protocolConnection = connection };
        return Result<EcliptixProtocolSystem, EcliptixProtocolFailure>.Ok(system);
    }

    public EcliptixProtocolConnection? GetConnection() => GetConnectionSafe();

    private Result<byte[], EcliptixProtocolFailure> ProcessInboundEnvelopeFromMaterials(EnvelopeMetadata metadata,
        byte[] encryptedPayload,
        EcliptixProtocolConnection connection)
    {
        byte[]? ad = null;
        try
        {
            Result<Unit, EcliptixProtocolFailure> replayCheck = connection.CheckReplayProtection(
                [.. metadata.Nonce],
                metadata.RatchetIndex);
            if (replayCheck.IsErr)
            {
                return Result<byte[], EcliptixProtocolFailure>.Err(replayCheck.UnwrapErr());
            }

            Result<RatchetChainKey, EcliptixProtocolFailure> messageResult =
                connection.ProcessReceivedMessage(metadata.RatchetIndex);
            if (messageResult.IsErr)
            {
                return Result<byte[], EcliptixProtocolFailure>.Err(messageResult.UnwrapErr());
            }

            RatchetChainKey messageKey = messageResult.Unwrap();

            Result<LocalPublicKeyBundle, EcliptixProtocolFailure> peerBundleResult = connection.GetPeerBundle();
            if (peerBundleResult.IsErr)
            {
                return Result<byte[], EcliptixProtocolFailure>.Err(peerBundleResult.UnwrapErr());
            }

            LocalPublicKeyBundle peerBundle = peerBundleResult.Unwrap();

            bool isInitiator = connection.IsInitiator();
            ad = isInitiator
                ? CreateAssociatedData(ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy(),
                    peerBundle.IdentityX25519)
                : CreateAssociatedData(peerBundle.IdentityX25519,
                    ecliptixSystemIdentityKeys.GetIdentityX25519PublicKeyCopy());

            Result<byte[], EcliptixProtocolFailure> result =
                DecryptFromMaterials(messageKey, metadata, encryptedPayload, ad);

            return result;
        }
        finally
        {
            if (ad != null)
            {
                SodiumInterop.SecureWipe(ad);
            }
        }
    }

    private static Result<byte[], EcliptixProtocolFailure> DecryptFromMaterials(RatchetChainKey key,
        EnvelopeMetadata metadata,
        byte[] encryptedPayload, byte[] ad)
    {
        ReadOnlySpan<byte> fullCipherSpan = encryptedPayload.AsSpan();
        const int tagSize = Constants.AesGcmTagSize;
        int cipherLength = fullCipherSpan.Length - tagSize;

        if (cipherLength < ProtocolSystemConstants.ProtocolSystem.CipherLengthMinimumThreshold)
        {
            return Result<byte[], EcliptixProtocolFailure>.Err(EcliptixProtocolFailure.BufferTooSmall(
                string.Format(ProtocolSystemConstants.ProtocolSystem.CiphertextTooSmallMessage, fullCipherSpan.Length,
                    tagSize)));
        }

        using SecurePooledArray<byte> keyMaterial = SecureArrayPool.Rent<byte>(Constants.AesKeySize);
        byte[]? plaintext = null;
        byte[]? nonce = null;

        try
        {
            Span<byte> keySpan = keyMaterial.AsSpan();
            Result<Unit, EcliptixProtocolFailure> readResult = key.ReadKeyMaterial(keySpan);
            if (readResult.IsErr)
            {
                return Result<byte[], EcliptixProtocolFailure>.Err(readResult.UnwrapErr());
            }

            ReadOnlySpan<byte> ciphertextSpan = fullCipherSpan[..cipherLength];
            ReadOnlySpan<byte> tagSpan = fullCipherSpan[cipherLength..];

            SecureByteStringInterop.SecureCopyWithCleanup(metadata.Nonce, out nonce);

            plaintext = new byte[cipherLength];

            using (AesGcm aesGcm = new(keySpan, Constants.AesGcmTagSize))
            {
                aesGcm.Decrypt(nonce, ciphertextSpan, tagSpan, plaintext, ad);
            }

            byte[] result = new byte[plaintext.Length];
            plaintext.CopyTo(result, 0);

            return Result<byte[], EcliptixProtocolFailure>.Ok(result);
        }
        catch (Exception ex)
        {
            return Result<byte[], EcliptixProtocolFailure>.Err(
                EcliptixProtocolFailure.Generic(ProtocolSystemConstants.ProtocolSystem.AesGcmDecryptionFailedMessage,
                    ex));
        }
        finally
        {
            if (plaintext != null)
            {
                SodiumInterop.SecureWipe(plaintext);
            }

            if (nonce != null)
            {
                SodiumInterop.SecureWipe(nonce);
            }
        }
    }
}

 [2025-11-04T12:57:47.26] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (6.8766ms) ************
{
  "Request_seq": 9271,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549632,
  "Type": "response"
}
 [2025-11-04T12:57:47.26] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9272,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/EcliptixProtocolSystem.cs"
  }
}
 [2025-11-04T12:57:47.539] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (278.8410ms) ************
{
  "Request_seq": 9272,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549636,
  "Type": "response"
}
 [2025-11-04T12:57:47.54] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9273,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Welcome/WelcomeView.axaml.cs",
    "Buffer": "using Avalonia.Markup.Xaml;\nusing Avalonia.ReactiveUI;\nusing Ecliptix.Core.Features.Authentication.ViewModels.Welcome;\nusing ReactiveUI;\n\nnamespace Ecliptix.Core.Features.Authentication.Views.Welcome;\n\npublic partial class WelcomeView : ReactiveUserControl<WelcomeViewModel>\n{\n    public WelcomeView()\n    {\n        AvaloniaXamlLoader.Load(this);\n    }\n}\n"
  }
}
 [2025-11-04T12:57:47.54] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Welcome/WelcomeView.axaml.cs with new text:
using Avalonia.Markup.Xaml;
using Avalonia.ReactiveUI;
using Ecliptix.Core.Features.Authentication.ViewModels.Welcome;
using ReactiveUI;

namespace Ecliptix.Core.Features.Authentication.Views.Welcome;

public partial class WelcomeView : ReactiveUserControl<WelcomeViewModel>
{
    public WelcomeView()
    {
        AvaloniaXamlLoader.Load(this);
    }
}

 [2025-11-04T12:57:47.541] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3564ms) ************
{
  "Request_seq": 9273,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549641,
  "Type": "response"
}
 [2025-11-04T12:57:47.541] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9274,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Welcome/WelcomeView.axaml.cs"
  }
}
 [2025-11-04T12:57:47.637] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (96.7103ms) ************
{
  "Request_seq": 9274,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549645,
  "Type": "response"
}
 [2025-11-04T12:57:47.638] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9275,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/App.axaml.cs",
    "Buffer": "using System;\nusing System.Reactive;\nusing System.Threading.Tasks;\nusing Avalonia;\nusing Avalonia.Controls.ApplicationLifetimes;\nusing Avalonia.Markup.Xaml;\nusing Ecliptix.Core.Core.Abstractions;\nusing Ecliptix.Core.Settings;\nusing ReactiveUI;\nusing Serilog;\nusing Splat;\n\nnamespace Ecliptix.Core;\n\npublic class App : Application\n{\n    public override void Initialize()\n    {\n        RxApp.DefaultExceptionHandler = Observer.Create<Exception>(ex =>\n        {\n            var context = new\n            {\n                ExceptionType = ex.GetType().Name,\n                InnerException = ex.InnerException?.GetType().Name,\n                Timestamp = DateTime.UtcNow\n            };\n\n\n            Log.Error(ex, \"ReactiveUI Unhandled Exception: {@Context}\", context);\n        });\n        AvaloniaXamlLoader.Load(this);\n    }\n\n    public override void OnFrameworkInitializationCompleted()\n    {\n        DefaultSystemSettings defaultSystemSettings = Locator.Current.GetService<DefaultSystemSettings>()!;\n\n        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)\n        {\n            Locator.CurrentMutable.RegisterConstant(desktop, typeof(IClassicDesktopStyleApplicationLifetime));\n\n            Task.Run(async () =>\n            {\n                try\n                {\n                    await InitializeModulesAsync();\n\n                    Avalonia.Threading.Dispatcher.UIThread.Post(async () =>\n                    {\n                        try\n                        {\n                            ApplicationStartup applicationStartup = Locator.Current.GetService<ApplicationStartup>()!;\n                            await applicationStartup.RunAsync(defaultSystemSettings);\n                        }\n                        catch (Exception ex)\n                        {\n                            Serilog.Log.Fatal(ex, \"[APP-STARTUP] Critical failure during application startup execution\");\n                            Environment.Exit(1);\n                        }\n                    });\n                }\n                catch (Exception ex)\n                {\n                    Serilog.Log.Fatal(ex, \"[APP-STARTUP] Critical failure during module initialization\");\n                    Environment.Exit(1);\n                }\n            }).ContinueWith(\n                task =>\n                {\n                    if (task.IsFaulted && task.Exception != null)\n                    {\n                        Serilog.Log.Fatal(task.Exception, \"[APP-STARTUP] Unhandled exception in application initialization\");\n                        Environment.Exit(1);\n                    }\n                },\n                TaskScheduler.Default);\n        }\n\n        base.OnFrameworkInitializationCompleted();\n    }\n\n    private static async Task InitializeModulesAsync()\n    {\n        IModuleManager moduleManager = Locator.Current.GetService<IModuleManager>()!;\n        await moduleManager.LoadEagerModulesAsync();\n    }\n}\n"
  }
}
 [2025-11-04T12:57:47.638] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/App.axaml.cs with new text:
using System;
using System.Reactive;
using System.Threading.Tasks;
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml;
using Ecliptix.Core.Core.Abstractions;
using Ecliptix.Core.Settings;
using ReactiveUI;
using Serilog;
using Splat;

namespace Ecliptix.Core;

public class App : Application
{
    public override void Initialize()
    {
        RxApp.DefaultExceptionHandler = Observer.Create<Exception>(ex =>
        {
            var context = new
            {
                ExceptionType = ex.GetType().Name,
                InnerException = ex.InnerException?.GetType().Name,
                Timestamp = DateTime.UtcNow
            };


            Log.Error(ex, "ReactiveUI Unhandled Exception: {@Context}", context);
        });
        AvaloniaXamlLoader.Load(this);
    }

    public override void OnFrameworkInitializationCompleted()
    {
        DefaultSystemSettings defaultSystemSettings = Locator.Current.GetService<DefaultSystemSettings>()!;

        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            Locator.CurrentMutable.RegisterConstant(desktop, typeof(IClassicDesktopStyleApplicationLifetime));

            Task.Run(async () =>
            {
                try
                {
                    await InitializeModulesAsync();

                    Avalonia.Threading.Dispatcher.UIThread.Post(async () =>
                    {
                        try
                        {
                            ApplicationStartup applicationStartup = Locator.Current.GetService<ApplicationStartup>()!;
                            await applicationStartup.RunAsync(defaultSystemSettings);
                        }
                        catch (Exception ex)
                        {
                            Serilog.Log.Fatal(ex, "[APP-STARTUP] Critical failure during application startup execution");
                            Environment.Exit(1);
                        }
                    });
                }
                catch (Exception ex)
                {
                    Serilog.Log.Fatal(ex, "[APP-STARTUP] Critical failure during module initialization");
                    Environment.Exit(1);
                }
            }).ContinueWith(
                task =>
                {
                    if (task.IsFaulted && task.Exception != null)
                    {
                        Serilog.Log.Fatal(task.Exception, "[APP-STARTUP] Unhandled exception in application initialization");
                        Environment.Exit(1);
                    }
                },
                TaskScheduler.Default);
        }

        base.OnFrameworkInitializationCompleted();
    }

    private static async Task InitializeModulesAsync()
    {
        IModuleManager moduleManager = Locator.Current.GetService<IModuleManager>()!;
        await moduleManager.LoadEagerModulesAsync();
    }
}

 [2025-11-04T12:57:47.638] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3586ms) ************
{
  "Request_seq": 9275,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549649,
  "Type": "response"
}
 [2025-11-04T12:57:47.638] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9276,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/App.axaml.cs"
  }
}
 [2025-11-04T12:57:47.75] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (111.6992ms) ************
{
  "Request_seq": 9276,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549653,
  "Type": "response"
}
 [2025-11-04T12:57:47.757] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9277,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/VersionHelper.cs",
    "Buffer": "using System;\nusing System.Diagnostics.CodeAnalysis;\nusing System.IO;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing Ecliptix.Utilities;\n\nnamespace Ecliptix.Core;\n\n[JsonSourceGenerationOptions(\n    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,\n    WriteIndented = false,\n    GenerationMode = JsonSourceGenerationMode.Metadata | JsonSourceGenerationMode.Serialization)]\n[JsonSerializable(typeof(BuildInfo))]\npublic partial class EcliptixJsonContext : JsonSerializerContext;\n\npublic static class VersionHelper\n{\n    private static readonly Lazy<string> ApplicationVersion = new(CalculateApplicationVersion);\n\n    [UnconditionalSuppressMessage(\"Trimming\", \"IL2026\",\n        Justification = \"InformationalVersion is only used for display purposes and has fallback to ApplicationVersion\")]\n    private static readonly Lazy<string> InformationalVersion = new(CalculateInformationalVersion);\n\n    private static readonly Lazy<Option<BuildInfo>> BuildInfo = new(LoadBuildInfo);\n    private static readonly Lazy<string> DisplayVersion = new(CalculateDisplayVersion);\n\n    public static string GetApplicationVersion() => ApplicationVersion.Value;\n\n    public static string GetInformationalVersion() => InformationalVersion.Value;\n\n    public static Option<BuildInfo> GetBuildInfo() => BuildInfo.Value;\n\n    public static string GetDisplayVersion() => DisplayVersion.Value;\n\n    private static string CalculateApplicationVersion()\n    {\n        return typeof(VersionHelper).Assembly.GetName().Version?.ToString(3) ?? \"1.0.0\";\n    }\n\n    [RequiresUnreferencedCode(\"Reads assembly attributes which may be trimmed\")]\n    private static string CalculateInformationalVersion()\n    {\n        try\n        {\n            string informationalVersion = typeof(VersionHelper).Assembly\n                    .GetCustomAttributes(typeof(System.Reflection.AssemblyInformationalVersionAttribute), false)\n                is System.Reflection.AssemblyInformationalVersionAttribute[] { Length: > 0 } attrs\n                ? attrs[0].InformationalVersion\n                : GetApplicationVersion();\n            return informationalVersion;\n        }\n        catch\n        {\n            return GetApplicationVersion();\n        }\n    }\n\n    private static Option<BuildInfo> LoadBuildInfo()\n    {\n        try\n        {\n            string buildInfoPath = Path.Combine(AppContext.BaseDirectory, \"build-info.json\");\n            if (!File.Exists(buildInfoPath))\n            {\n                return Option<BuildInfo>.None;\n            }\n\n            string json = File.ReadAllText(buildInfoPath);\n            return JsonSerializer.Deserialize(json, EcliptixJsonContext.Default.BuildInfo).ToOption();\n        }\n        catch\n        {\n            return Option<BuildInfo>.None;\n        }\n    }\n\n    private static string CalculateDisplayVersion()\n    {\n        return GetBuildInfo()\n            .Select(info => info.FullVersion)\n            .ValueOr(GetInformationalVersion());\n    }\n}\n\npublic record BuildInfo(\n    string Version,\n    string BuildNumber,\n    string FullVersion,\n    string Timestamp,\n    string GitCommit,\n    string GitBranch\n);\n"
  }
}
 [2025-11-04T12:57:47.757] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/VersionHelper.cs with new text:
using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using Ecliptix.Utilities;

namespace Ecliptix.Core;

[JsonSourceGenerationOptions(
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,
    WriteIndented = false,
    GenerationMode = JsonSourceGenerationMode.Metadata | JsonSourceGenerationMode.Serialization)]
[JsonSerializable(typeof(BuildInfo))]
public partial class EcliptixJsonContext : JsonSerializerContext;

public static class VersionHelper
{
    private static readonly Lazy<string> ApplicationVersion = new(CalculateApplicationVersion);

    [UnconditionalSuppressMessage("Trimming", "IL2026",
        Justification = "InformationalVersion is only used for display purposes and has fallback to ApplicationVersion")]
    private static readonly Lazy<string> InformationalVersion = new(CalculateInformationalVersion);

    private static readonly Lazy<Option<BuildInfo>> BuildInfo = new(LoadBuildInfo);
    private static readonly Lazy<string> DisplayVersion = new(CalculateDisplayVersion);

    public static string GetApplicationVersion() => ApplicationVersion.Value;

    public static string GetInformationalVersion() => InformationalVersion.Value;

    public static Option<BuildInfo> GetBuildInfo() => BuildInfo.Value;

    public static string GetDisplayVersion() => DisplayVersion.Value;

    private static string CalculateApplicationVersion()
    {
        return typeof(VersionHelper).Assembly.GetName().Version?.ToString(3) ?? "1.0.0";
    }

    [RequiresUnreferencedCode("Reads assembly attributes which may be trimmed")]
    private static string CalculateInformationalVersion()
    {
        try
        {
            string informationalVersion = typeof(VersionHelper).Assembly
                    .GetCustomAttributes(typeof(System.Reflection.AssemblyInformationalVersionAttribute), false)
                is System.Reflection.AssemblyInformationalVersionAttribute[] { Length: > 0 } attrs
                ? attrs[0].InformationalVersion
                : GetApplicationVersion();
            return informationalVersion;
        }
        catch
        {
            return GetApplicationVersion();
        }
    }

    private static Option<BuildInfo> LoadBuildInfo()
    {
        try
        {
            string buildInfoPath = Path.Combine(AppContext.BaseDirectory, "build-info.json");
            if (!File.Exists(buildInfoPath))
            {
                return Option<BuildInfo>.None;
            }

            string json = File.ReadAllText(buildInfoPath);
            return JsonSerializer.Deserialize(json, EcliptixJsonContext.Default.BuildInfo).ToOption();
        }
        catch
        {
            return Option<BuildInfo>.None;
        }
    }

    private static string CalculateDisplayVersion()
    {
        return GetBuildInfo()
            .Select(info => info.FullVersion)
            .ValueOr(GetInformationalVersion());
    }
}

public record BuildInfo(
    string Version,
    string BuildNumber,
    string FullVersion,
    string Timestamp,
    string GitCommit,
    string GitBranch
);

 [2025-11-04T12:57:47.757] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (6.4942ms) ************
{
  "Request_seq": 9277,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549657,
  "Type": "response"
}
 [2025-11-04T12:57:47.757] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9278,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/VersionHelper.cs"
  }
}
 [2025-11-04T12:57:47.879] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (121.4537ms) ************
{
  "Request_seq": 9278,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549662,
  "Type": "response"
}
 [2025-11-04T12:57:47.882] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9279,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Core/Constants/NetworkConstants.cs",
    "Buffer": "using System;\n\nnamespace Ecliptix.Core.Infrastructure.Network.Core.Constants;\n\npublic static class NetworkConstants\n{\n    public static class Protocol\n    {\n        public const int DefaultOneTimeKeyCount = 5;\n        public const uint OperationIdMinValue = 10;\n        public const uint OperationIdReservedRange = 10;\n        public const int RequestKeyHexPrefixLength = 16;\n    }\n\n    public static class Cryptography\n    {\n        public const int Sha256HashSize = 32;\n    }\n\n    public static class Timeouts\n    {\n        public static readonly TimeSpan OutageRecoveryTimeout = TimeSpan.FromSeconds(5);\n    }\n\n    public static class ErrorMessages\n    {\n        public const string SessionNotFoundOnServer = \"Session not found on server\";\n    }\n}\n"
  }
}
 [2025-11-04T12:57:47.882] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Core/Constants/NetworkConstants.cs with new text:
using System;

namespace Ecliptix.Core.Infrastructure.Network.Core.Constants;

public static class NetworkConstants
{
    public static class Protocol
    {
        public const int DefaultOneTimeKeyCount = 5;
        public const uint OperationIdMinValue = 10;
        public const uint OperationIdReservedRange = 10;
        public const int RequestKeyHexPrefixLength = 16;
    }

    public static class Cryptography
    {
        public const int Sha256HashSize = 32;
    }

    public static class Timeouts
    {
        public static readonly TimeSpan OutageRecoveryTimeout = TimeSpan.FromSeconds(5);
    }

    public static class ErrorMessages
    {
        public const string SessionNotFoundOnServer = "Session not found on server";
    }
}

 [2025-11-04T12:57:47.882] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3667ms) ************
{
  "Request_seq": 9279,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549666,
  "Type": "response"
}
 [2025-11-04T12:57:47.882] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9280,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Core/Constants/NetworkConstants.cs"
  }
}
 [2025-11-04T12:57:47.978] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (95.9804ms) ************
{
  "Request_seq": 9280,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549670,
  "Type": "response"
}
 [2025-11-04T12:57:47.978] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9281,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModulePriorityQueue.cs",
    "Buffer": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Ecliptix.Core.Core.Abstractions;\n\nnamespace Ecliptix.Core.Core.Modularity;\n\ninternal class ModulePriorityQueue\n{\n    private const int MaxRetryAttempts = 100;\n\n    private readonly SortedList<int, Queue<IModule>> _priorityQueues = new();\n    private readonly HashSet<string> _processedModules = new();\n    private readonly Dictionary<string, IModule> _moduleMap = new();\n    private readonly Dictionary<string, int> _retryAttempts = new();\n\n    public void EnqueueModules(IEnumerable<IModule> modules)\n    {\n        IModule[] moduleArray = modules.ToArray();\n\n        foreach (IModule module in moduleArray)\n        {\n            _moduleMap[module.Id.ToName()] = module;\n            _retryAttempts[module.Id.ToName()] = 0;\n        }\n\n        List<IModule> sortedModules = TopologicalSort(moduleArray);\n\n        foreach (IModule module in sortedModules)\n        {\n            int priority = module.Manifest.Priority;\n\n            if (!_priorityQueues.ContainsKey(priority))\n            {\n                _priorityQueues[priority] = new Queue<IModule>();\n            }\n\n            _priorityQueues[priority].Enqueue(module);\n        }\n    }\n\n    public IModule? DequeueNext()\n    {\n        foreach (int priority in _priorityQueues.Keys.OrderByDescending(p => p))\n        {\n            if (!_priorityQueues.TryGetValue(priority, out Queue<IModule>? queue))\n            {\n                continue;\n            }\n\n            if (queue.Count == 0)\n            {\n                continue;\n            }\n\n            IModule module = queue.Dequeue();\n            string moduleName = module.Id.ToName();\n\n            if (AreDependenciesLoaded(module))\n            {\n                _processedModules.Add(moduleName);\n                _retryAttempts.Remove(moduleName);\n                return module;\n            }\n\n            _retryAttempts[moduleName]++;\n\n            if (_retryAttempts[moduleName] >= MaxRetryAttempts)\n            {\n                string missingDeps = string.Join(\", \",\n                    module.Manifest.Dependencies\n                        .Where(dep => !_processedModules.Contains(dep.ToName()))\n                        .Select(dep => dep.ToName()));\n\n                throw new InvalidOperationException(\n                    $\"Module '{moduleName}' dependencies not satisfied after {MaxRetryAttempts} attempts. Missing: {missingDeps}\");\n            }\n\n            queue.Enqueue(module);\n        }\n\n        return null;\n    }\n\n    public int Count => _priorityQueues.Values.Sum(q => q.Count);\n\n    private bool AreDependenciesLoaded(IModule module) =>\n        module.Manifest.Dependencies.All(dep => _processedModules.Contains(dep.ToName()));\n\n    private List<IModule> TopologicalSort(IModule[] modules)\n    {\n        List<IModule> result = new(modules.Length);\n        HashSet<string> visited = new();\n        HashSet<string> visiting = new();\n\n        void Visit(IModule module)\n        {\n            string moduleName = module.Id.ToName();\n\n            if (visiting.Contains(moduleName))\n            {\n                throw new InvalidOperationException($\"Circular dependency detected involving module: {moduleName}\");\n            }\n\n            if (visited.Contains(moduleName))\n            {\n                return;\n            }\n\n            visiting.Add(moduleName);\n\n            foreach (ModuleIdentifier dependency in module.Manifest.Dependencies)\n            {\n                if (_moduleMap.TryGetValue(dependency.ToName(), out IModule? depModule))\n                {\n                    Visit(depModule);\n                }\n            }\n\n            visiting.Remove(moduleName);\n            visited.Add(moduleName);\n            result.Add(module);\n        }\n\n        foreach (IModule module in modules)\n        {\n            Visit(module);\n        }\n\n        return result;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:47.978] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModulePriorityQueue.cs with new text:
using System;
using System.Collections.Generic;
using System.Linq;
using Ecliptix.Core.Core.Abstractions;

namespace Ecliptix.Core.Core.Modularity;

internal class ModulePriorityQueue
{
    private const int MaxRetryAttempts = 100;

    private readonly SortedList<int, Queue<IModule>> _priorityQueues = new();
    private readonly HashSet<string> _processedModules = new();
    private readonly Dictionary<string, IModule> _moduleMap = new();
    private readonly Dictionary<string, int> _retryAttempts = new();

    public void EnqueueModules(IEnumerable<IModule> modules)
    {
        IModule[] moduleArray = modules.ToArray();

        foreach (IModule module in moduleArray)
        {
            _moduleMap[module.Id.ToName()] = module;
            _retryAttempts[module.Id.ToName()] = 0;
        }

        List<IModule> sortedModules = TopologicalSort(moduleArray);

        foreach (IModule module in sortedModules)
        {
            int priority = module.Manifest.Priority;

            if (!_priorityQueues.ContainsKey(priority))
            {
                _priorityQueues[priority] = new Queue<IModule>();
            }

            _priorityQueues[priority].Enqueue(module);
        }
    }

    public IModule? DequeueNext()
    {
        foreach (int priority in _priorityQueues.Keys.OrderByDescending(p => p))
        {
            if (!_priorityQueues.TryGetValue(priority, out Queue<IModule>? queue))
            {
                continue;
            }

            if (queue.Count == 0)
            {
                continue;
            }

            IModule module = queue.Dequeue();
            string moduleName = module.Id.ToName();

            if (AreDependenciesLoaded(module))
            {
                _processedModules.Add(moduleName);
                _retryAttempts.Remove(moduleName);
                return module;
            }

            _retryAttempts[moduleName]++;

            if (_retryAttempts[moduleName] >= MaxRetryAttempts)
            {
                string missingDeps = string.Join(", ",
                    module.Manifest.Dependencies
                        .Where(dep => !_processedModules.Contains(dep.ToName()))
                        .Select(dep => dep.ToName()));

                throw new InvalidOperationException(
                    $"Module '{moduleName}' dependencies not satisfied after {MaxRetryAttempts} attempts. Missing: {missingDeps}");
            }

            queue.Enqueue(module);
        }

        return null;
    }

    public int Count => _priorityQueues.Values.Sum(q => q.Count);

    private bool AreDependenciesLoaded(IModule module) =>
        module.Manifest.Dependencies.All(dep => _processedModules.Contains(dep.ToName()));

    private List<IModule> TopologicalSort(IModule[] modules)
    {
        List<IModule> result = new(modules.Length);
        HashSet<string> visited = new();
        HashSet<string> visiting = new();

        void Visit(IModule module)
        {
            string moduleName = module.Id.ToName();

            if (visiting.Contains(moduleName))
            {
                throw new InvalidOperationException($"Circular dependency detected involving module: {moduleName}");
            }

            if (visited.Contains(moduleName))
            {
                return;
            }

            visiting.Add(moduleName);

            foreach (ModuleIdentifier dependency in module.Manifest.Dependencies)
            {
                if (_moduleMap.TryGetValue(dependency.ToName(), out IModule? depModule))
                {
                    Visit(depModule);
                }
            }

            visiting.Remove(moduleName);
            visited.Add(moduleName);
            result.Add(module);
        }

        foreach (IModule module in modules)
        {
            Visit(module);
        }

        return result;
    }
}

 [2025-11-04T12:57:47.979] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3785ms) ************
{
  "Request_seq": 9281,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549674,
  "Type": "response"
}
 [2025-11-04T12:57:47.979] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9282,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModulePriorityQueue.cs"
  }
}
 [2025-11-04T12:57:48.184] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (205.1239ms) ************
{
  "Request_seq": 9282,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549678,
  "Type": "response"
}
 [2025-11-04T12:57:48.187] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9283,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/PendingLogoutProcessor.cs",
    "Buffer": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Ecliptix.Core.Infrastructure.Data;\nusing Ecliptix.Core.Infrastructure.Network.Core.Providers;\nusing Ecliptix.Core.Services.Network.Rpc;\nusing Ecliptix.Protobuf.Membership;\nusing Ecliptix.Protobuf.Protocol;\nusing Ecliptix.Utilities;\nusing Ecliptix.Utilities.Failures.Membership;\nusing Ecliptix.Utilities.Failures.Network;\nusing Google.Protobuf;\nusing Serilog;\n\nnamespace Ecliptix.Core.Services.Network;\n\ninternal sealed class PendingLogoutProcessor(\n    NetworkProvider networkProvider,\n    PendingLogoutRequestStorage pendingLogoutStorage)\n{\n    public async Task ProcessPendingLogoutAsync(\n        uint connectId,\n        CancellationToken cancellationToken = default)\n    {\n        try\n        {\n            Result<Option<LogoutRequest>, LogoutFailure> getResult =\n                await pendingLogoutStorage.GetPendingLogoutAsync().ConfigureAwait(false);\n\n            if (getResult.IsErr || !getResult.Unwrap().IsSome)\n            {\n                return;\n            }\n\n            LogoutRequest pendingRequest = getResult.Unwrap().Value!;\n\n            TaskCompletionSource<bool> responseCompletionSource =\n                new(TaskCreationOptions.RunContinuationsAsynchronously);\n\n            Result<Unit, NetworkFailure> networkResult = await networkProvider.ExecuteUnaryRequestAsync(\n                connectId,\n                RpcServiceType.AnonymousLogout,\n                pendingRequest.ToByteArray(),\n                async responsePayload =>\n                {\n                    AnonymousLogoutResponse logoutResponse = AnonymousLogoutResponse.Parser.ParseFrom(responsePayload);\n\n                    // Complete the response regardless of logout result (both success and failure handled the same)\n                    responseCompletionSource.TrySetResult(true);\n\n                    return await Task.FromResult(Result<Unit, NetworkFailure>.Ok(Unit.Value));\n                },\n                allowDuplicates: false,\n                token: cancellationToken).ConfigureAwait(false);\n\n            if (networkResult.IsOk)\n            {\n                await responseCompletionSource.Task.ConfigureAwait(false);\n                pendingLogoutStorage.ClearPendingLogout();\n            }\n            else\n            {\n                Log.Warning(\"[PENDING-LOGOUT-RETRY] Failed to send pending logout request: {Error}. Deleting corrupted expired pending logout\",\n                    networkResult.UnwrapErr().Message);\n                pendingLogoutStorage.ClearPendingLogout();\n                Task.Run(async () =>\n                {\n                    try\n                    {\n                        await EnsureProtocolInBackground();\n                    }\n                    catch (Exception ex)\n                    {\n                        Log.Warning(ex, \"[VERIFY-OTP] Background secrecy channel establishment failed\");\n                    }\n                }).ContinueWith(\n                    task =>\n                    {\n                        if (task.IsFaulted && task.Exception != null)\n                        {\n                            Log.Error(task.Exception, \"[PENDING-LOGOUT-RETRY] Unhandled exception ensuring protocol\");\n                        }\n                    },\n                    TaskScheduler.Default);\n            }\n        }\n        catch (Exception ex)\n        {\n            Log.Error(ex, \"[PENDING-LOGOUT-RETRY] Unexpected error processing pending logout\");\n        }\n    }\n\n    private async Task EnsureProtocolInBackground()\n    {\n        Result<uint, NetworkFailure> ensureResult = await networkProvider.EnsureProtocolForTypeAsync(\n            PubKeyExchangeType.DataCenterEphemeralConnect);\n\n        if (ensureResult.IsErr)\n        {\n            Log.Error(\"[VERIFY-OTP] Failed to ensure protocol: {Error}\",\n                ensureResult.UnwrapErr().Message);\n        }\n    }\n}\n"
  }
}
 [2025-11-04T12:57:48.187] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/PendingLogoutProcessor.cs with new text:
using System;
using System.Threading;
using System.Threading.Tasks;
using Ecliptix.Core.Infrastructure.Data;
using Ecliptix.Core.Infrastructure.Network.Core.Providers;
using Ecliptix.Core.Services.Network.Rpc;
using Ecliptix.Protobuf.Membership;
using Ecliptix.Protobuf.Protocol;
using Ecliptix.Utilities;
using Ecliptix.Utilities.Failures.Membership;
using Ecliptix.Utilities.Failures.Network;
using Google.Protobuf;
using Serilog;

namespace Ecliptix.Core.Services.Network;

internal sealed class PendingLogoutProcessor(
    NetworkProvider networkProvider,
    PendingLogoutRequestStorage pendingLogoutStorage)
{
    public async Task ProcessPendingLogoutAsync(
        uint connectId,
        CancellationToken cancellationToken = default)
    {
        try
        {
            Result<Option<LogoutRequest>, LogoutFailure> getResult =
                await pendingLogoutStorage.GetPendingLogoutAsync().ConfigureAwait(false);

            if (getResult.IsErr || !getResult.Unwrap().IsSome)
            {
                return;
            }

            LogoutRequest pendingRequest = getResult.Unwrap().Value!;

            TaskCompletionSource<bool> responseCompletionSource =
                new(TaskCreationOptions.RunContinuationsAsynchronously);

            Result<Unit, NetworkFailure> networkResult = await networkProvider.ExecuteUnaryRequestAsync(
                connectId,
                RpcServiceType.AnonymousLogout,
                pendingRequest.ToByteArray(),
                async responsePayload =>
                {
                    AnonymousLogoutResponse logoutResponse = AnonymousLogoutResponse.Parser.ParseFrom(responsePayload);

                    // Complete the response regardless of logout result (both success and failure handled the same)
                    responseCompletionSource.TrySetResult(true);

                    return await Task.FromResult(Result<Unit, NetworkFailure>.Ok(Unit.Value));
                },
                allowDuplicates: false,
                token: cancellationToken).ConfigureAwait(false);

            if (networkResult.IsOk)
            {
                await responseCompletionSource.Task.ConfigureAwait(false);
                pendingLogoutStorage.ClearPendingLogout();
            }
            else
            {
                Log.Warning("[PENDING-LOGOUT-RETRY] Failed to send pending logout request: {Error}. Deleting corrupted expired pending logout",
                    networkResult.UnwrapErr().Message);
                pendingLogoutStorage.ClearPendingLogout();
                Task.Run(async () =>
                {
                    try
                    {
                        await EnsureProtocolInBackground();
                    }
                    catch (Exception ex)
                    {
                        Log.Warning(ex, "[VERIFY-OTP] Background secrecy channel establishment failed");
                    }
                }).ContinueWith(
                    task =>
                    {
                        if (task.IsFaulted && task.Exception != null)
                        {
                            Log.Error(task.Exception, "[PENDING-LOGOUT-RETRY] Unhandled exception ensuring protocol");
                        }
                    },
                    TaskScheduler.Default);
            }
        }
        catch (Exception ex)
        {
            Log.Error(ex, "[PENDING-LOGOUT-RETRY] Unexpected error processing pending logout");
        }
    }

    private async Task EnsureProtocolInBackground()
    {
        Result<uint, NetworkFailure> ensureResult = await networkProvider.EnsureProtocolForTypeAsync(
            PubKeyExchangeType.DataCenterEphemeralConnect);

        if (ensureResult.IsErr)
        {
            Log.Error("[VERIFY-OTP] Failed to ensure protocol: {Error}",
                ensureResult.UnwrapErr().Message);
        }
    }
}

 [2025-11-04T12:57:48.187] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (2.7892ms) ************
{
  "Request_seq": 9283,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549683,
  "Type": "response"
}
 [2025-11-04T12:57:48.187] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9284,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/PendingLogoutProcessor.cs"
  }
}
 [2025-11-04T12:57:48.437] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (249.4825ms) ************
{
  "Request_seq": 9284,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": [
      {
        "AdditionalLocations": [],
        "QuickFixes": [],
        "LogLevel": "Warning",
        "Id": "S1481",
        "Tags": [],
        "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/PendingLogoutProcessor.cs",
        "Line": 46,
        "Column": 45,
        "EndLine": 46,
        "EndColumn": 59,
        "Text": "Remove the unused local variable 'logoutResponse'.",
        "Projects": [
          "Ecliptix.Core"
        ]
      }
    ]
  },
  "Seq": 549687,
  "Type": "response"
}
 [2025-11-04T12:57:48.438] [sonarlint-analysis-scheduler] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/PendingLogoutProcessor.cs
 [2025-11-04T12:57:48.439] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9285,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Connectivity/ConnectivityReason.cs",
    "Buffer": "namespace Ecliptix.Core.Core.Messaging.Connectivity;\n\npublic enum ConnectivityReason\n{\n    None,\n    HandshakeStarted,\n    HandshakeSucceeded,\n    RpcFailure,\n    ManualRetry,\n    Backoff,\n    NoInternet,\n    InternetRecovered,\n    ServerShutdown,\n    RetryLimitReached,\n    OperationCancelled,\n    HandshakeFailed,\n    SecurityError,\n    Unknown\n}\n"
  }
}
 [2025-11-04T12:57:48.44] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Connectivity/ConnectivityReason.cs with new text:
namespace Ecliptix.Core.Core.Messaging.Connectivity;

public enum ConnectivityReason
{
    None,
    HandshakeStarted,
    HandshakeSucceeded,
    RpcFailure,
    ManualRetry,
    Backoff,
    NoInternet,
    InternetRecovered,
    ServerShutdown,
    RetryLimitReached,
    OperationCancelled,
    HandshakeFailed,
    SecurityError,
    Unknown
}

 [2025-11-04T12:57:48.44] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.5074ms) ************
{
  "Request_seq": 9285,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549692,
  "Type": "response"
}
 [2025-11-04T12:57:48.446] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9286,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Connectivity/ConnectivityReason.cs"
  }
}
 [2025-11-04T12:57:48.534] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (88.0400ms) ************
{
  "Request_seq": 9286,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549696,
  "Type": "response"
}
 [2025-11-04T12:57:48.536] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9287,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/CryptographicHelpers.cs",
    "Buffer": "using System;\nusing System.Security.Cryptography;\n\nnamespace Ecliptix.Utilities;\n\npublic static class CryptographicHelpers\n{\n    public static string ComputeSha256Fingerprint(byte[] data)\n    {\n        byte[] hash = SHA256.HashData(data);\n        return Convert.ToHexString(hash)[..CryptographicConstants.HashFingerprintLength];\n    }\n\n    public static string ComputeSha256Fingerprint(ReadOnlySpan<byte> data)\n    {\n        Span<byte> hash = stackalloc byte[CryptographicConstants.Sha256HashSize];\n        SHA256.HashData(data, hash);\n        return Convert.ToHexString(hash)[..CryptographicConstants.HashFingerprintLength];\n    }\n}\n"
  }
}
 [2025-11-04T12:57:48.536] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/CryptographicHelpers.cs with new text:
using System;
using System.Security.Cryptography;

namespace Ecliptix.Utilities;

public static class CryptographicHelpers
{
    public static string ComputeSha256Fingerprint(byte[] data)
    {
        byte[] hash = SHA256.HashData(data);
        return Convert.ToHexString(hash)[..CryptographicConstants.HashFingerprintLength];
    }

    public static string ComputeSha256Fingerprint(ReadOnlySpan<byte> data)
    {
        Span<byte> hash = stackalloc byte[CryptographicConstants.Sha256HashSize];
        SHA256.HashData(data, hash);
        return Convert.ToHexString(hash)[..CryptographicConstants.HashFingerprintLength];
    }
}

 [2025-11-04T12:57:48.536] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2617ms) ************
{
  "Request_seq": 9287,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549700,
  "Type": "response"
}
 [2025-11-04T12:57:48.536] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9288,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/CryptographicHelpers.cs"
  }
}
 [2025-11-04T12:57:48.593] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (56.2209ms) ************
{
  "Request_seq": 9288,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549704,
  "Type": "response"
}
 [2025-11-04T12:57:48.593] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9289,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/UserRequestErrorViewModel.cs",
    "Buffer": "using System;\nusing Ecliptix.Core.Services.Abstractions.Core;\nusing ReactiveUI;\n\nnamespace Ecliptix.Core.Controls.Modals;\n\npublic sealed class UserRequestErrorViewModel : ReactiveObject, IActivatableViewModel\n{\n    public ViewModelActivator Activator { get; } = new();\n\n    public UserRequestErrorViewModel(string errorMessage, ILocalizationService localizationService)\n    {\n        _ = localizationService ?? throw new ArgumentNullException(nameof(localizationService));\n        ErrorMessage = string.IsNullOrWhiteSpace(errorMessage)\n            ? localizationService[\"Common.UnexpectedError\"]\n            : errorMessage;\n    }\n\n    public string ErrorMessage { get; }\n}\n"
  }
}
 [2025-11-04T12:57:48.593] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/UserRequestErrorViewModel.cs with new text:
using System;
using Ecliptix.Core.Services.Abstractions.Core;
using ReactiveUI;

namespace Ecliptix.Core.Controls.Modals;

public sealed class UserRequestErrorViewModel : ReactiveObject, IActivatableViewModel
{
    public ViewModelActivator Activator { get; } = new();

    public UserRequestErrorViewModel(string errorMessage, ILocalizationService localizationService)
    {
        _ = localizationService ?? throw new ArgumentNullException(nameof(localizationService));
        ErrorMessage = string.IsNullOrWhiteSpace(errorMessage)
            ? localizationService["Common.UnexpectedError"]
            : errorMessage;
    }

    public string ErrorMessage { get; }
}

 [2025-11-04T12:57:48.594] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3144ms) ************
{
  "Request_seq": 9289,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549708,
  "Type": "response"
}
 [2025-11-04T12:57:48.594] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9290,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/UserRequestErrorViewModel.cs"
  }
}
 [2025-11-04T12:57:48.701] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (107.2969ms) ************
{
  "Request_seq": 9290,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549712,
  "Type": "response"
}
 [2025-11-04T12:57:48.702] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9291,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Core/StateCleanupService.cs",
    "Buffer": "using System;\nusing System.Threading.Tasks;\nusing Ecliptix.Core.Infrastructure.Data.Abstractions;\nusing Ecliptix.Core.Infrastructure.Network.Core.Providers;\nusing Ecliptix.Core.Infrastructure.Security.Abstractions;\nusing Ecliptix.Core.Infrastructure.Security.Storage;\nusing Ecliptix.Core.Services.Abstractions.Authentication;\nusing Ecliptix.Core.Services.Abstractions.Core;\nusing Ecliptix.Utilities;\nusing Serilog;\n\nnamespace Ecliptix.Core.Services.Core;\n\ninternal sealed class StateCleanupService(\n    IIdentityService identityService,\n    IApplicationSecureStorageProvider applicationSecureStorageProvider,\n    ISecureProtocolStateStorage secureProtocolStateStorage,\n    NetworkProvider networkProvider) : IStateCleanupService\n{\n    public async Task<Result<Unit, Exception>> CleanupMembershipStateAsync(string membershipId, uint connectId)\n    {\n        try\n        {\n            Result<Unit, SecureStorageFailure> deleteResult = await secureProtocolStateStorage.DeleteStateAsync(connectId.ToString()).ConfigureAwait(false);\n\n            if (deleteResult.IsErr)\n            {\n                Log.Warning(\"[STATE-CLEANUP-DELETE] Failed to delete protocol state file for ConnectId: {ConnectId}, Error: {Error}\",\n                    connectId, deleteResult.UnwrapErr().Message);\n            }\n\n            await applicationSecureStorageProvider.SetApplicationMembershipAsync(null).ConfigureAwait(false);\n\n            networkProvider.ClearConnection(connectId);\n\n            return Result<Unit, Exception>.Ok(Unit.Value);\n        }\n        catch (Exception ex)\n        {\n            Log.Error(ex, \"[STATE-CLEANUP] Cleanup failed for MembershipId: {MembershipId}\", membershipId);\n            return Result<Unit, Exception>.Err(ex);\n        }\n    }\n\n    public async Task<Result<Unit, Exception>> CleanupMembershipStateWithKeysAsync(string membershipId, uint connectId)\n    {\n        try\n        {\n            Result<Unit, SecureStorageFailure> deleteResult = await secureProtocolStateStorage.DeleteStateAsync(connectId.ToString()).ConfigureAwait(false);\n\n            if (deleteResult.IsErr)\n            {\n                Log.Warning(\"[STATE-CLEANUP-FULL-DELETE] Failed to delete protocol state file for ConnectId: {ConnectId}, Error: {Error}\",\n                    connectId, deleteResult.UnwrapErr().Message);\n            }\n\n            Result<Unit, Ecliptix.Utilities.Failures.Authentication.AuthenticationFailure> clearResult =\n                await identityService.ClearAllCacheAsync(membershipId).ConfigureAwait(false);\n\n            if (clearResult.IsErr)\n            {\n                Log.Warning(\"[STATE-CLEANUP-FULL] Identity cache clear failed: {Error}\",\n                    clearResult.UnwrapErr().Message);\n            }\n\n            await applicationSecureStorageProvider.SetApplicationMembershipAsync(null).ConfigureAwait(false);\n\n            networkProvider.ClearConnection(connectId);\n\n            return Result<Unit, Exception>.Ok(Unit.Value);\n        }\n        catch (Exception ex)\n        {\n            Log.Error(ex, \"[STATE-CLEANUP-FULL] Full cleanup failed for MembershipId: {MembershipId}\", membershipId);\n            return Result<Unit, Exception>.Err(ex);\n        }\n    }\n}\n"
  }
}
 [2025-11-04T12:57:48.702] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Core/StateCleanupService.cs with new text:
using System;
using System.Threading.Tasks;
using Ecliptix.Core.Infrastructure.Data.Abstractions;
using Ecliptix.Core.Infrastructure.Network.Core.Providers;
using Ecliptix.Core.Infrastructure.Security.Abstractions;
using Ecliptix.Core.Infrastructure.Security.Storage;
using Ecliptix.Core.Services.Abstractions.Authentication;
using Ecliptix.Core.Services.Abstractions.Core;
using Ecliptix.Utilities;
using Serilog;

namespace Ecliptix.Core.Services.Core;

internal sealed class StateCleanupService(
    IIdentityService identityService,
    IApplicationSecureStorageProvider applicationSecureStorageProvider,
    ISecureProtocolStateStorage secureProtocolStateStorage,
    NetworkProvider networkProvider) : IStateCleanupService
{
    public async Task<Result<Unit, Exception>> CleanupMembershipStateAsync(string membershipId, uint connectId)
    {
        try
        {
            Result<Unit, SecureStorageFailure> deleteResult = await secureProtocolStateStorage.DeleteStateAsync(connectId.ToString()).ConfigureAwait(false);

            if (deleteResult.IsErr)
            {
                Log.Warning("[STATE-CLEANUP-DELETE] Failed to delete protocol state file for ConnectId: {ConnectId}, Error: {Error}",
                    connectId, deleteResult.UnwrapErr().Message);
            }

            await applicationSecureStorageProvider.SetApplicationMembershipAsync(null).ConfigureAwait(false);

            networkProvider.ClearConnection(connectId);

            return Result<Unit, Exception>.Ok(Unit.Value);
        }
        catch (Exception ex)
        {
            Log.Error(ex, "[STATE-CLEANUP] Cleanup failed for MembershipId: {MembershipId}", membershipId);
            return Result<Unit, Exception>.Err(ex);
        }
    }

    public async Task<Result<Unit, Exception>> CleanupMembershipStateWithKeysAsync(string membershipId, uint connectId)
    {
        try
        {
            Result<Unit, SecureStorageFailure> deleteResult = await secureProtocolStateStorage.DeleteStateAsync(connectId.ToString()).ConfigureAwait(false);

            if (deleteResult.IsErr)
            {
                Log.Warning("[STATE-CLEANUP-FULL-DELETE] Failed to delete protocol state file for ConnectId: {ConnectId}, Error: {Error}",
                    connectId, deleteResult.UnwrapErr().Message);
            }

            Result<Unit, Ecliptix.Utilities.Failures.Authentication.AuthenticationFailure> clearResult =
                await identityService.ClearAllCacheAsync(membershipId).ConfigureAwait(false);

            if (clearResult.IsErr)
            {
                Log.Warning("[STATE-CLEANUP-FULL] Identity cache clear failed: {Error}",
                    clearResult.UnwrapErr().Message);
            }

            await applicationSecureStorageProvider.SetApplicationMembershipAsync(null).ConfigureAwait(false);

            networkProvider.ClearConnection(connectId);

            return Result<Unit, Exception>.Ok(Unit.Value);
        }
        catch (Exception ex)
        {
            Log.Error(ex, "[STATE-CLEANUP-FULL] Full cleanup failed for MembershipId: {MembershipId}", membershipId);
            return Result<Unit, Exception>.Err(ex);
        }
    }
}

 [2025-11-04T12:57:48.702] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.4017ms) ************
{
  "Request_seq": 9291,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549716,
  "Type": "response"
}
 [2025-11-04T12:57:48.702] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9292,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Core/StateCleanupService.cs"
  }
}
 [2025-11-04T12:57:48.745] [sonarlint-finding-streamer] DEBUG sonarlint - Reporting 455 issues for configuration scope /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/.idea/.idea.Ecliptix-Desktop/.idea/misc.xml_rider.module
 [2025-11-04T12:57:48.815] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (113.1722ms) ************
{
  "Request_seq": 9292,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549720,
  "Type": "response"
}
 [2025-11-04T12:57:48.816] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9293,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Common/AuthenticationFlowContext.cs",
    "Buffer": "namespace Ecliptix.Core.Features.Authentication.Common;\n\npublic enum AuthenticationFlowContext\n{\n    Registration,\n    SecureKeyRecovery\n}\n"
  }
}
 [2025-11-04T12:57:48.816] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Common/AuthenticationFlowContext.cs with new text:
namespace Ecliptix.Core.Features.Authentication.Common;

public enum AuthenticationFlowContext
{
    Registration,
    SecureKeyRecovery
}

 [2025-11-04T12:57:48.816] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3393ms) ************
{
  "Request_seq": 9293,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549724,
  "Type": "response"
}
 [2025-11-04T12:57:48.816] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9294,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Common/AuthenticationFlowContext.cs"
  }
}
 [2025-11-04T12:57:48.912] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (96.0689ms) ************
{
  "Request_seq": 9294,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549728,
  "Type": "response"
}
 [2025-11-04T12:57:48.913] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9295,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/MembershipCoreGrpc.cs",
    "Buffer": ""
  }
}
 [2025-11-04T12:57:48.913] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/MembershipCoreGrpc.cs with new text:

 [2025-11-04T12:57:48.913] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.1749ms) ************
{
  "Request_seq": 9295,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549732,
  "Type": "response"
}
 [2025-11-04T12:57:48.913] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9296,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/MembershipCoreGrpc.cs"
  }
}
 [2025-11-04T12:57:48.96] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (47.5800ms) ************
{
  "Request_seq": 9296,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549736,
  "Type": "response"
}
 [2025-11-04T12:57:48.961] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9297,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/RpcRequestContext.cs",
    "Buffer": "using System;\n\nnamespace Ecliptix.Core.Services.Network.Rpc;\n\npublic sealed class RpcRequestContext(string correlationId, string idempotencyKey, int attempt = 1)\n{\n    public string CorrelationId { get; } = correlationId;\n\n    public string IdempotencyKey { get; } = idempotencyKey;\n\n    public int Attempt { get; } = attempt;\n\n    public bool ReinitAttempted { get; private set; }\n\n    public static RpcRequestContext CreateNew(int attempt = 1)\n    {\n        return new RpcRequestContext(\n            Guid.NewGuid().ToString(\"N\"),\n            Guid.NewGuid().ToString(\"N\"),\n            attempt);\n    }\n\n    public static RpcRequestContext CreateNewWithStableKey(string stableIdempotencyKey, int attempt = 1)\n    {\n        return new RpcRequestContext(\n            Guid.NewGuid().ToString(\"N\"),\n            stableIdempotencyKey,\n            attempt);\n    }\n\n    public void MarkReinitAttempted()\n    {\n        ReinitAttempted = true;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:48.961] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/RpcRequestContext.cs with new text:
using System;

namespace Ecliptix.Core.Services.Network.Rpc;

public sealed class RpcRequestContext(string correlationId, string idempotencyKey, int attempt = 1)
{
    public string CorrelationId { get; } = correlationId;

    public string IdempotencyKey { get; } = idempotencyKey;

    public int Attempt { get; } = attempt;

    public bool ReinitAttempted { get; private set; }

    public static RpcRequestContext CreateNew(int attempt = 1)
    {
        return new RpcRequestContext(
            Guid.NewGuid().ToString("N"),
            Guid.NewGuid().ToString("N"),
            attempt);
    }

    public static RpcRequestContext CreateNewWithStableKey(string stableIdempotencyKey, int attempt = 1)
    {
        return new RpcRequestContext(
            Guid.NewGuid().ToString("N"),
            stableIdempotencyKey,
            attempt);
    }

    public void MarkReinitAttempted()
    {
        ReinitAttempted = true;
    }
}

 [2025-11-04T12:57:48.962] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3557ms) ************
{
  "Request_seq": 9297,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549739,
  "Type": "response"
}
 [2025-11-04T12:57:48.962] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9298,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/RpcRequestContext.cs"
  }
}
 [2025-11-04T12:57:49.075] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (113.0122ms) ************
{
  "Request_seq": 9298,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549743,
  "Type": "response"
}
 [2025-11-04T12:57:49.075] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9299,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleLoadingContext.cs",
    "Buffer": "using System;\nusing System.Collections.Concurrent;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Ecliptix.Core.Core.Abstractions;\nusing Ecliptix.Utilities;\n\nnamespace Ecliptix.Core.Core.Modularity;\n\ninternal class ModuleLoadingContext\n{\n    private readonly record struct ModuleState(IModule Module, DateTime LoadTime);\n\n    private readonly ConcurrentDictionary<string, TaskCompletionSource<IModule>> _loadingTasks = new();\n    private readonly ConcurrentDictionary<string, ModuleState> _loadedModules = new();\n    private readonly SemaphoreSlim _loadingSemaphore;\n\n    public ModuleLoadingContext(int maxConcurrentLoads = 4)\n    {\n        _loadingSemaphore = new SemaphoreSlim(maxConcurrentLoads, maxConcurrentLoads);\n    }\n\n    public Task<IModule> GetOrCreateLoadingTask(string moduleName, Func<Task<IModule>> loadFactory)\n    {\n        if (_loadedModules.TryGetValue(moduleName, out ModuleState cached))\n        {\n            return Task.FromResult(cached.Module);\n        }\n\n        TaskCompletionSource<IModule> tcs = _loadingTasks.GetOrAdd(moduleName, key =>\n        {\n            TaskCompletionSource<IModule> newTcs = new(TaskCreationOptions.RunContinuationsAsynchronously);\n\n            _ = ExecuteModuleLoadAsync(key, loadFactory, newTcs);\n\n            return newTcs;\n        });\n\n        return tcs.Task;\n    }\n\n    private async Task ExecuteModuleLoadAsync(string moduleName, Func<Task<IModule>> loadFactory, TaskCompletionSource<IModule> tcs)\n    {\n        try\n        {\n            await _loadingSemaphore.WaitAsync();\n            try\n            {\n                if (_loadedModules.TryGetValue(moduleName, out ModuleState cached))\n                {\n                    tcs.TrySetResult(cached.Module);\n                    return;\n                }\n\n                IModule module = await loadFactory();\n\n                ModuleState state = new(module, DateTime.UtcNow);\n                _loadedModules[moduleName] = state;\n\n                tcs.TrySetResult(module);\n            }\n            finally\n            {\n                _loadingSemaphore.Release();\n                _loadingTasks.TryRemove(moduleName, out _);\n            }\n        }\n        catch (Exception ex)\n        {\n            tcs.TrySetException(ex);\n            _loadingTasks.TryRemove(moduleName, out _);\n        }\n    }\n\n    public Option<IModule> GetCachedModule(string moduleName)\n    {\n        return _loadedModules.TryGetValue(moduleName, out ModuleState state)\n            ? Option<IModule>.Some(state.Module)\n            : Option<IModule>.None;\n    }\n\n    public ModuleLoadingStats GetStats()\n    {\n        return new ModuleLoadingStats\n        {\n            LoadedModulesCount = _loadedModules.Count,\n            ActiveLoadingTasks = _loadingTasks.Count,\n            AverageLoadTime = _loadedModules.Count > 0\n                ? _loadedModules.Values.Select(s => (DateTime.UtcNow - s.LoadTime).TotalMilliseconds).Average()\n                : 0\n        };\n    }\n\n    public void Release()\n    {\n        _loadingSemaphore?.Dispose();\n    }\n}\n\npublic record ModuleLoadingStats\n{\n    public int LoadedModulesCount { get; init; }\n    public int ActiveLoadingTasks { get; init; }\n    public double AverageLoadTime { get; init; }\n}\n"
  }
}
 [2025-11-04T12:57:49.075] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleLoadingContext.cs with new text:
using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Ecliptix.Core.Core.Abstractions;
using Ecliptix.Utilities;

namespace Ecliptix.Core.Core.Modularity;

internal class ModuleLoadingContext
{
    private readonly record struct ModuleState(IModule Module, DateTime LoadTime);

    private readonly ConcurrentDictionary<string, TaskCompletionSource<IModule>> _loadingTasks = new();
    private readonly ConcurrentDictionary<string, ModuleState> _loadedModules = new();
    private readonly SemaphoreSlim _loadingSemaphore;

    public ModuleLoadingContext(int maxConcurrentLoads = 4)
    {
        _loadingSemaphore = new SemaphoreSlim(maxConcurrentLoads, maxConcurrentLoads);
    }

    public Task<IModule> GetOrCreateLoadingTask(string moduleName, Func<Task<IModule>> loadFactory)
    {
        if (_loadedModules.TryGetValue(moduleName, out ModuleState cached))
        {
            return Task.FromResult(cached.Module);
        }

        TaskCompletionSource<IModule> tcs = _loadingTasks.GetOrAdd(moduleName, key =>
        {
            TaskCompletionSource<IModule> newTcs = new(TaskCreationOptions.RunContinuationsAsynchronously);

            _ = ExecuteModuleLoadAsync(key, loadFactory, newTcs);

            return newTcs;
        });

        return tcs.Task;
    }

    private async Task ExecuteModuleLoadAsync(string moduleName, Func<Task<IModule>> loadFactory, TaskCompletionSource<IModule> tcs)
    {
        try
        {
            await _loadingSemaphore.WaitAsync();
            try
            {
                if (_loadedModules.TryGetValue(moduleName, out ModuleState cached))
                {
                    tcs.TrySetResult(cached.Module);
                    return;
                }

                IModule module = await loadFactory();

                ModuleState state = new(module, DateTime.UtcNow);
                _loadedModules[moduleName] = state;

                tcs.TrySetResult(module);
            }
            finally
            {
                _loadingSemaphore.Release();
                _loadingTasks.TryRemove(moduleName, out _);
            }
        }
        catch (Exception ex)
        {
            tcs.TrySetException(ex);
            _loadingTasks.TryRemove(moduleName, out _);
        }
    }

    public Option<IModule> GetCachedModule(string moduleName)
    {
        return _loadedModules.TryGetValue(moduleName, out ModuleState state)
            ? Option<IModule>.Some(state.Module)
            : Option<IModule>.None;
    }

    public ModuleLoadingStats GetStats()
    {
        return new ModuleLoadingStats
        {
            LoadedModulesCount = _loadedModules.Count,
            ActiveLoadingTasks = _loadingTasks.Count,
            AverageLoadTime = _loadedModules.Count > 0
                ? _loadedModules.Values.Select(s => (DateTime.UtcNow - s.LoadTime).TotalMilliseconds).Average()
                : 0
        };
    }

    public void Release()
    {
        _loadingSemaphore?.Dispose();
    }
}

public record ModuleLoadingStats
{
    public int LoadedModulesCount { get; init; }
    public int ActiveLoadingTasks { get; init; }
    public double AverageLoadTime { get; init; }
}

 [2025-11-04T12:57:49.075] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3454ms) ************
{
  "Request_seq": 9299,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549747,
  "Type": "response"
}
 [2025-11-04T12:57:49.075] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9300,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleLoadingContext.cs"
  }
}
 [2025-11-04T12:57:49.199] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (123.5985ms) ************
{
  "Request_seq": 9300,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549751,
  "Type": "response"
}
 [2025-11-04T12:57:49.2] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9301,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/MVVM/ViewLocator.cs",
    "Buffer": "using System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing Ecliptix.Core.Core.Abstractions;\nusing Ecliptix.Utilities;\nusing ReactiveUI;\nusing IViewLocator = Ecliptix.Core.Core.Abstractions.IViewLocator;\n\nnamespace Ecliptix.Core.Core.MVVM;\n\npublic sealed class ViewLocator : IViewLocator\n{\n    private readonly ConcurrentDictionary<Type, Func<object>> _viewFactories = new();\n\n    public void Register<TViewModel, TView>()\n        where TViewModel : class, IRoutableViewModel\n        where TView : class, new()\n    {\n        RegisterFactory<TViewModel>(() => new TView());\n    }\n\n    public void RegisterFactory<TViewModel>(Func<object> factory)\n        where TViewModel : class, IRoutableViewModel\n    {\n        _viewFactories[typeof(TViewModel)] = factory;\n    }\n\n    public Option<object> ResolveView<TViewModel>(TViewModel? viewModel = null)\n        where TViewModel : class, IRoutableViewModel\n    {\n        if (viewModel == null)\n        {\n            return Option<object>.None;\n        }\n\n        Type viewModelType = typeof(TViewModel);\n\n        if (_viewFactories.TryGetValue(viewModelType, out Func<object>? factory))\n        {\n            object view = factory();\n            return Option<object>.Some(view);\n        }\n\n        Type actualType = viewModel.GetType();\n        if (actualType != viewModelType && _viewFactories.TryGetValue(actualType, out factory))\n        {\n            object view = factory();\n            return Option<object>.Some(view);\n        }\n\n        object? staticView = StaticViewMapper.CreateView(actualType);\n        return staticView.ToOption();\n    }\n\n    public Option<object> ResolveView(object? viewModel)\n    {\n        if (viewModel == null)\n        {\n            return Option<object>.None;\n        }\n\n        Type viewModelType = viewModel.GetType();\n\n        if (_viewFactories.TryGetValue(viewModelType, out Func<object>? factory))\n        {\n            object view = factory();\n            return Option<object>.Some(view);\n        }\n\n        object? staticView = StaticViewMapper.CreateView(viewModelType);\n        return staticView.ToOption();\n    }\n\n    public bool IsRegistered<TViewModel>() where TViewModel : class, IRoutableViewModel\n    {\n        return IsRegistered(typeof(TViewModel));\n    }\n\n    public bool IsRegistered(Type viewModelType)\n    {\n        return _viewFactories.ContainsKey(viewModelType);\n    }\n\n    public IReadOnlyDictionary<Type, Func<object>> GetRegistrations()\n    {\n        return new Dictionary<Type, Func<object>>(_viewFactories);\n    }\n}\n"
  }
}
 [2025-11-04T12:57:49.2] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/MVVM/ViewLocator.cs with new text:
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using Ecliptix.Core.Core.Abstractions;
using Ecliptix.Utilities;
using ReactiveUI;
using IViewLocator = Ecliptix.Core.Core.Abstractions.IViewLocator;

namespace Ecliptix.Core.Core.MVVM;

public sealed class ViewLocator : IViewLocator
{
    private readonly ConcurrentDictionary<Type, Func<object>> _viewFactories = new();

    public void Register<TViewModel, TView>()
        where TViewModel : class, IRoutableViewModel
        where TView : class, new()
    {
        RegisterFactory<TViewModel>(() => new TView());
    }

    public void RegisterFactory<TViewModel>(Func<object> factory)
        where TViewModel : class, IRoutableViewModel
    {
        _viewFactories[typeof(TViewModel)] = factory;
    }

    public Option<object> ResolveView<TViewModel>(TViewModel? viewModel = null)
        where TViewModel : class, IRoutableViewModel
    {
        if (viewModel == null)
        {
            return Option<object>.None;
        }

        Type viewModelType = typeof(TViewModel);

        if (_viewFactories.TryGetValue(viewModelType, out Func<object>? factory))
        {
            object view = factory();
            return Option<object>.Some(view);
        }

        Type actualType = viewModel.GetType();
        if (actualType != viewModelType && _viewFactories.TryGetValue(actualType, out factory))
        {
            object view = factory();
            return Option<object>.Some(view);
        }

        object? staticView = StaticViewMapper.CreateView(actualType);
        return staticView.ToOption();
    }

    public Option<object> ResolveView(object? viewModel)
    {
        if (viewModel == null)
        {
            return Option<object>.None;
        }

        Type viewModelType = viewModel.GetType();

        if (_viewFactories.TryGetValue(viewModelType, out Func<object>? factory))
        {
            object view = factory();
            return Option<object>.Some(view);
        }

        object? staticView = StaticViewMapper.CreateView(viewModelType);
        return staticView.ToOption();
    }

    public bool IsRegistered<TViewModel>() where TViewModel : class, IRoutableViewModel
    {
        return IsRegistered(typeof(TViewModel));
    }

    public bool IsRegistered(Type viewModelType)
    {
        return _viewFactories.ContainsKey(viewModelType);
    }

    public IReadOnlyDictionary<Type, Func<object>> GetRegistrations()
    {
        return new Dictionary<Type, Func<object>>(_viewFactories);
    }
}

 [2025-11-04T12:57:49.2] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3463ms) ************
{
  "Request_seq": 9301,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549756,
  "Type": "response"
}
 [2025-11-04T12:57:49.2] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9302,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/MVVM/ViewLocator.cs"
  }
}
 [2025-11-04T12:57:49.308] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (108.2232ms) ************
{
  "Request_seq": 9302,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549760,
  "Type": "response"
}
 [2025-11-04T12:57:49.309] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9303,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Option.cs",
    "Buffer": "\nnamespace Ecliptix.Utilities;\n\npublic readonly record struct Option<T>\n{\n    private Option(bool isSome, T? value)\n    {\n        IsSome = isSome;\n        Value = value;\n    }\n\n    public bool IsSome { get; }\n    public T? Value { get; }\n\n    public static Option<T> None => new(false, default);\n\n    public static Option<T> Some(T value)\n    {\n        return new Option<T>(true, value);\n    }\n\n    public TResult Match<TResult>(Func<T, TResult> onSome, Func<TResult> onNone)\n    {\n        return IsSome ? onSome(Value!) : onNone();\n    }\n\n    public void Match(Action<T> onSome, Action onNone)\n    {\n        if (IsSome)\n        {\n            onSome(Value!);\n        }\n        else\n        {\n            onNone();\n        }\n    }\n\n    public T ValueOr(T fallback)\n    {\n        return IsSome ? Value! : fallback;\n    }\n\n    public Option<TResult> Map<TResult>(Func<T, TResult> selector)\n    {\n        return IsSome ? Option<TResult>.Some(selector(Value!)) : Option<TResult>.None;\n    }\n\n    public static Option<T> From(T? value)\n    {\n        return value is not null ? Some(value) : None;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:49.309] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Option.cs with new text:

namespace Ecliptix.Utilities;

public readonly record struct Option<T>
{
    private Option(bool isSome, T? value)
    {
        IsSome = isSome;
        Value = value;
    }

    public bool IsSome { get; }
    public T? Value { get; }

    public static Option<T> None => new(false, default);

    public static Option<T> Some(T value)
    {
        return new Option<T>(true, value);
    }

    public TResult Match<TResult>(Func<T, TResult> onSome, Func<TResult> onNone)
    {
        return IsSome ? onSome(Value!) : onNone();
    }

    public void Match(Action<T> onSome, Action onNone)
    {
        if (IsSome)
        {
            onSome(Value!);
        }
        else
        {
            onNone();
        }
    }

    public T ValueOr(T fallback)
    {
        return IsSome ? Value! : fallback;
    }

    public Option<TResult> Map<TResult>(Func<T, TResult> selector)
    {
        return IsSome ? Option<TResult>.Some(selector(Value!)) : Option<TResult>.None;
    }

    public static Option<T> From(T? value)
    {
        return value is not null ? Some(value) : None;
    }
}

 [2025-11-04T12:57:49.31] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2304ms) ************
{
  "Request_seq": 9303,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549764,
  "Type": "response"
}
 [2025-11-04T12:57:49.31] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9304,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Option.cs"
  }
}
 [2025-11-04T12:57:49.371] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (61.1913ms) ************
{
  "Request_seq": 9304,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549768,
  "Type": "response"
}
 [2025-11-04T12:57:49.372] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9305,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/RpcServiceManager.cs",
    "Buffer": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Ecliptix.Core.Core.Messaging.Services;\nusing Ecliptix.Core.Services.Abstractions.Network;\nusing Ecliptix.Protobuf.Common;\nusing Ecliptix.Protobuf.Device;\nusing Ecliptix.Protobuf.Protocol;\nusing Ecliptix.Utilities;\nusing Ecliptix.Utilities.Failures.Network;\n\nnamespace Ecliptix.Core.Services.Network.Rpc;\n\ninternal class RpcServiceManager : IRpcServiceManager\n{\n    private readonly ISecrecyChannelRpcServices _secrecyChannelRpcServices;\n\n    private readonly\n        Dictionary<ServiceFlowType,\n            Func<ServiceRequest, CancellationToken, Task<Result<RpcFlow, NetworkFailure>>>> _serviceInvokers;\n\n    public RpcServiceManager(\n        IUnaryRpcServices unaryRpcServices,\n        IReceiveStreamRpcServices receiveStreamRpcServices,\n        ISecrecyChannelRpcServices secrecyChannelRpcServices,\n        IConnectivityService connectivityService)\n    {\n        _secrecyChannelRpcServices = secrecyChannelRpcServices;\n\n        _serviceInvokers =\n            new Dictionary<ServiceFlowType,\n                Func<ServiceRequest, CancellationToken, Task<Result<RpcFlow, NetworkFailure>>>>\n            {\n                {\n                    ServiceFlowType.Single,\n                    (req, token) => unaryRpcServices.InvokeRequestAsync(req, connectivityService, token)\n                },\n                {\n                    ServiceFlowType.ReceiveStream, receiveStreamRpcServices.ProcessRequest\n                }\n            };\n    }\n\n    public async Task<Result<SecureEnvelope, NetworkFailure>> EstablishSecrecyChannelAsync(\n        IConnectivityService connectivityService,\n        SecureEnvelope envelope,\n        PubKeyExchangeType? exchangeType = null,\n        CancellationToken cancellationToken = default)\n    {\n        return await _secrecyChannelRpcServices.EstablishAppDeviceSecrecyChannelAsync(connectivityService,\n            envelope,\n            exchangeType,\n            cancellationToken).ConfigureAwait(false);\n    }\n\n    public async Task<Result<RestoreChannelResponse, NetworkFailure>> RestoreSecrecyChannelAsync(\n        IConnectivityService connectivityService,\n        RestoreChannelRequest request,\n        CancellationToken cancellationToken = default)\n    {\n        return await _secrecyChannelRpcServices.RestoreAppDeviceSecrecyChannelAsync(connectivityService,\n            request,\n            cancellationToken).ConfigureAwait(false);\n    }\n\n    public async Task<Result<SecureEnvelope, NetworkFailure>> EstablishAuthenticatedSecureChannelAsync(\n        IConnectivityService connectivityService,\n        AuthenticatedEstablishRequest request,\n        CancellationToken cancellationToken = default)\n    {\n        return await _secrecyChannelRpcServices.AuthenticatedEstablishSecureChannelAsync(connectivityService,\n            request,\n            cancellationToken).ConfigureAwait(false);\n    }\n\n    public async Task<Result<RpcFlow, NetworkFailure>> InvokeServiceRequestAsync(ServiceRequest request,\n        CancellationToken token)\n    {\n        if (_serviceInvokers.TryGetValue(request.ActionType,\n                out Func<ServiceRequest, CancellationToken, Task<Result<RpcFlow, NetworkFailure>>>? invoker))\n        {\n            Result<RpcFlow, NetworkFailure> result = await invoker(request, token).ConfigureAwait(false);\n\n            return result;\n        }\n\n        return Result<RpcFlow, NetworkFailure>.Err(NetworkFailure.InvalidRequestType(\"Unknown action type\"));\n    }\n}\n"
  }
}
 [2025-11-04T12:57:49.372] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/RpcServiceManager.cs with new text:
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Ecliptix.Core.Core.Messaging.Services;
using Ecliptix.Core.Services.Abstractions.Network;
using Ecliptix.Protobuf.Common;
using Ecliptix.Protobuf.Device;
using Ecliptix.Protobuf.Protocol;
using Ecliptix.Utilities;
using Ecliptix.Utilities.Failures.Network;

namespace Ecliptix.Core.Services.Network.Rpc;

internal class RpcServiceManager : IRpcServiceManager
{
    private readonly ISecrecyChannelRpcServices _secrecyChannelRpcServices;

    private readonly
        Dictionary<ServiceFlowType,
            Func<ServiceRequest, CancellationToken, Task<Result<RpcFlow, NetworkFailure>>>> _serviceInvokers;

    public RpcServiceManager(
        IUnaryRpcServices unaryRpcServices,
        IReceiveStreamRpcServices receiveStreamRpcServices,
        ISecrecyChannelRpcServices secrecyChannelRpcServices,
        IConnectivityService connectivityService)
    {
        _secrecyChannelRpcServices = secrecyChannelRpcServices;

        _serviceInvokers =
            new Dictionary<ServiceFlowType,
                Func<ServiceRequest, CancellationToken, Task<Result<RpcFlow, NetworkFailure>>>>
            {
                {
                    ServiceFlowType.Single,
                    (req, token) => unaryRpcServices.InvokeRequestAsync(req, connectivityService, token)
                },
                {
                    ServiceFlowType.ReceiveStream, receiveStreamRpcServices.ProcessRequest
                }
            };
    }

    public async Task<Result<SecureEnvelope, NetworkFailure>> EstablishSecrecyChannelAsync(
        IConnectivityService connectivityService,
        SecureEnvelope envelope,
        PubKeyExchangeType? exchangeType = null,
        CancellationToken cancellationToken = default)
    {
        return await _secrecyChannelRpcServices.EstablishAppDeviceSecrecyChannelAsync(connectivityService,
            envelope,
            exchangeType,
            cancellationToken).ConfigureAwait(false);
    }

    public async Task<Result<RestoreChannelResponse, NetworkFailure>> RestoreSecrecyChannelAsync(
        IConnectivityService connectivityService,
        RestoreChannelRequest request,
        CancellationToken cancellationToken = default)
    {
        return await _secrecyChannelRpcServices.RestoreAppDeviceSecrecyChannelAsync(connectivityService,
            request,
            cancellationToken).ConfigureAwait(false);
    }

    public async Task<Result<SecureEnvelope, NetworkFailure>> EstablishAuthenticatedSecureChannelAsync(
        IConnectivityService connectivityService,
        AuthenticatedEstablishRequest request,
        CancellationToken cancellationToken = default)
    {
        return await _secrecyChannelRpcServices.AuthenticatedEstablishSecureChannelAsync(connectivityService,
            request,
            cancellationToken).ConfigureAwait(false);
    }

    public async Task<Result<RpcFlow, NetworkFailure>> InvokeServiceRequestAsync(ServiceRequest request,
        CancellationToken token)
    {
        if (_serviceInvokers.TryGetValue(request.ActionType,
                out Func<ServiceRequest, CancellationToken, Task<Result<RpcFlow, NetworkFailure>>>? invoker))
        {
            Result<RpcFlow, NetworkFailure> result = await invoker(request, token).ConfigureAwait(false);

            return result;
        }

        return Result<RpcFlow, NetworkFailure>.Err(NetworkFailure.InvalidRequestType("Unknown action type"));
    }
}

 [2025-11-04T12:57:49.372] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3978ms) ************
{
  "Request_seq": 9305,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549771,
  "Type": "response"
}
 [2025-11-04T12:57:49.372] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9306,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/RpcServiceManager.cs"
  }
}
 [2025-11-04T12:57:49.49] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (118.0478ms) ************
{
  "Request_seq": 9306,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549775,
  "Type": "response"
}
 [2025-11-04T12:57:49.493] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9307,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/ServiceRequest.cs",
    "Buffer": "using System.Collections.Generic;\nusing Ecliptix.Protobuf.Common;\n\nnamespace Ecliptix.Core.Services.Network.Rpc;\n\npublic class ServiceRequest\n{\n    private ServiceRequest(\n        uint reqId,\n        ServiceFlowType actionType,\n        RpcServiceType rpcServiceMethod,\n        SecureEnvelope payload,\n        List<SecureEnvelope> encryptedChunks,\n        RpcRequestContext? requestContext)\n    {\n        ReqId = reqId;\n        ActionType = actionType;\n        RpcServiceMethod = rpcServiceMethod;\n        Payload = payload;\n        EncryptedChunks = encryptedChunks;\n        RequestContext = requestContext;\n    }\n\n    public uint ReqId { get; }\n\n    public ServiceFlowType ActionType { get; }\n\n    public RpcServiceType RpcServiceMethod { get; }\n\n    public SecureEnvelope Payload { get; }\n\n    public List<SecureEnvelope> EncryptedChunks { get; }\n\n    public RpcRequestContext? RequestContext { get; }\n\n    public static ServiceRequest New(uint reqId, ServiceFlowType actionType, RpcServiceType rpcServiceMethod,\n        SecureEnvelope payload, List<SecureEnvelope> encryptedChunks, RpcRequestContext? requestContext = null)\n    {\n        return new ServiceRequest(reqId, actionType, rpcServiceMethod, payload, encryptedChunks, requestContext);\n    }\n}\n"
  }
}
 [2025-11-04T12:57:49.493] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/ServiceRequest.cs with new text:
using System.Collections.Generic;
using Ecliptix.Protobuf.Common;

namespace Ecliptix.Core.Services.Network.Rpc;

public class ServiceRequest
{
    private ServiceRequest(
        uint reqId,
        ServiceFlowType actionType,
        RpcServiceType rpcServiceMethod,
        SecureEnvelope payload,
        List<SecureEnvelope> encryptedChunks,
        RpcRequestContext? requestContext)
    {
        ReqId = reqId;
        ActionType = actionType;
        RpcServiceMethod = rpcServiceMethod;
        Payload = payload;
        EncryptedChunks = encryptedChunks;
        RequestContext = requestContext;
    }

    public uint ReqId { get; }

    public ServiceFlowType ActionType { get; }

    public RpcServiceType RpcServiceMethod { get; }

    public SecureEnvelope Payload { get; }

    public List<SecureEnvelope> EncryptedChunks { get; }

    public RpcRequestContext? RequestContext { get; }

    public static ServiceRequest New(uint reqId, ServiceFlowType actionType, RpcServiceType rpcServiceMethod,
        SecureEnvelope payload, List<SecureEnvelope> encryptedChunks, RpcRequestContext? requestContext = null)
    {
        return new ServiceRequest(reqId, actionType, rpcServiceMethod, payload, encryptedChunks, requestContext);
    }
}

 [2025-11-04T12:57:49.493] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.4106ms) ************
{
  "Request_seq": 9307,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549779,
  "Type": "response"
}
 [2025-11-04T12:57:49.493] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9308,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/ServiceRequest.cs"
  }
}
 [2025-11-04T12:57:49.59] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (96.6852ms) ************
{
  "Request_seq": 9308,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549784,
  "Type": "response"
}
 [2025-11-04T12:57:49.59] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9309,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Common/MembershipViewType.cs",
    "Buffer": "namespace Ecliptix.Core.Features.Authentication.Common;\n\npublic enum MembershipViewType\n{\n    WelcomeView,\n    SignInView,\n    MobileVerificationView,\n    OtpVerificationView,\n    SecureKeyConfirmationView,\n    PinSetView\n}\n"
  }
}
 [2025-11-04T12:57:49.59] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Common/MembershipViewType.cs with new text:
namespace Ecliptix.Core.Features.Authentication.Common;

public enum MembershipViewType
{
    WelcomeView,
    SignInView,
    MobileVerificationView,
    OtpVerificationView,
    SecureKeyConfirmationView,
    PinSetView
}

 [2025-11-04T12:57:49.591] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3310ms) ************
{
  "Request_seq": 9309,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549787,
  "Type": "response"
}
 [2025-11-04T12:57:49.591] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9310,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Common/MembershipViewType.cs"
  }
}
 [2025-11-04T12:57:49.683] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (91.9341ms) ************
{
  "Request_seq": 9310,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549791,
  "Type": "response"
}
 [2025-11-04T12:57:49.683] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9311,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/FailureBase.cs",
    "Buffer": "using Grpc.Core;\n\nnamespace Ecliptix.Utilities.Failures;\n\npublic interface IFailureBase\n{\n    object ToStructuredLog();\n    Status ToGrpcStatus();\n    GrpcErrorDescriptor ToGrpcDescriptor();\n}\n\npublic abstract record FailureBase(string Message, Exception? InnerException = null) : IFailureBase\n{\n    protected DateTime Timestamp { get; } = DateTime.UtcNow;\n\n    public abstract object ToStructuredLog();\n\n    public virtual Status ToGrpcStatus()\n    {\n        GrpcErrorDescriptor descriptor = ToGrpcDescriptor();\n        return descriptor.CreateStatus(Message);\n    }\n\n    public abstract GrpcErrorDescriptor ToGrpcDescriptor();\n}\n"
  }
}
 [2025-11-04T12:57:49.683] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/FailureBase.cs with new text:
using Grpc.Core;

namespace Ecliptix.Utilities.Failures;

public interface IFailureBase
{
    object ToStructuredLog();
    Status ToGrpcStatus();
    GrpcErrorDescriptor ToGrpcDescriptor();
}

public abstract record FailureBase(string Message, Exception? InnerException = null) : IFailureBase
{
    protected DateTime Timestamp { get; } = DateTime.UtcNow;

    public abstract object ToStructuredLog();

    public virtual Status ToGrpcStatus()
    {
        GrpcErrorDescriptor descriptor = ToGrpcDescriptor();
        return descriptor.CreateStatus(Message);
    }

    public abstract GrpcErrorDescriptor ToGrpcDescriptor();
}

 [2025-11-04T12:57:49.684] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.1915ms) ************
{
  "Request_seq": 9311,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549795,
  "Type": "response"
}
 [2025-11-04T12:57:49.684] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9312,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/FailureBase.cs"
  }
}
 [2025-11-04T12:57:49.73] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (46.5995ms) ************
{
  "Request_seq": 9312,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549799,
  "Type": "response"
}
 [2025-11-04T12:57:49.731] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9313,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/EncryptionGrpc.cs",
    "Buffer": ""
  }
}
 [2025-11-04T12:57:49.731] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/EncryptionGrpc.cs with new text:

 [2025-11-04T12:57:49.731] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2657ms) ************
{
  "Request_seq": 9313,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549803,
  "Type": "response"
}
 [2025-11-04T12:57:49.731] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9314,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/EncryptionGrpc.cs"
  }
}
 [2025-11-04T12:57:49.776] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (45.2547ms) ************
{
  "Request_seq": 9314,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549807,
  "Type": "response"
}
 [2025-11-04T12:57:49.777] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9315,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Registration/MobileVerificationView.axaml.cs",
    "Buffer": "using System.Threading.Tasks;\nusing Avalonia;\nusing Avalonia.Controls;\nusing Avalonia.Input;\nusing Avalonia.Markup.Xaml;\nusing Avalonia.ReactiveUI;\nusing Ecliptix.Core.Controls.Core;\nusing Ecliptix.Core.Features.Authentication.ViewModels.Registration;\nusing ReactiveUI;\n\nnamespace Ecliptix.Core.Features.Authentication.Views.Registration;\n\npublic partial class MobileVerificationView : ReactiveUserControl<MobileVerificationViewModel>\n{\n    private const string MobileTextBoxControlName = \"MobileTextBox\";\n\n    private bool _handlersAttached;\n    public MobileVerificationView()\n    {\n        InitializeComponent();\n    }\n\n    private void InitializeComponent()\n    {\n        AvaloniaXamlLoader.Load(this);\n    }\n\n    protected override void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e)\n    {\n        base.OnAttachedToVisualTree(e);\n        SetupEventHandlers();\n    }\n\n    protected override void OnDetachedFromVisualTree(VisualTreeAttachmentEventArgs e)\n    {\n        base.OnDetachedFromVisualTree(e);\n        TeardownEventHandlers();\n    }\n\n    private void SetupEventHandlers()\n    {\n        if (_handlersAttached)\n        {\n            return;\n        }\n\n        if (this.FindControl<HintedTextBox>(MobileTextBoxControlName) is { } mobileTextBox)\n        {\n            mobileTextBox.KeyDown += OnMobileTextBoxKeyDown;\n            _handlersAttached = true;\n        }\n    }\n\n    private void TeardownEventHandlers()\n    {\n        if (!_handlersAttached)\n        {\n            return;\n        }\n\n        if (this.FindControl<HintedTextBox>(MobileTextBoxControlName) is { } mobileTextBox)\n        {\n            mobileTextBox.KeyDown -= OnMobileTextBoxKeyDown;\n        }\n\n        _handlersAttached = false;\n    }\n\n    private void OnMobileTextBoxKeyDown(object? sender, KeyEventArgs e)\n    {\n        if (e.Key != Key.Enter && e.Key != Key.Return)\n        {\n            return;\n        }\n\n        if (DataContext is not MobileVerificationViewModel vm)\n        {\n            return;\n        }\n\n        vm.HandleEnterKeyPressAsync().ContinueWith(\n            task =>\n            {\n                if (task.IsFaulted && task.Exception != null)\n                {\n                    Serilog.Log.Error(task.Exception, \"[MOBILE-VERIFICATION-VIEW] Unhandled exception in HandleEnterKeyPressAsync\");\n                }\n            },\n            TaskScheduler.Default);\n        e.Handled = true;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:49.777] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Registration/MobileVerificationView.axaml.cs with new text:
using System.Threading.Tasks;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Markup.Xaml;
using Avalonia.ReactiveUI;
using Ecliptix.Core.Controls.Core;
using Ecliptix.Core.Features.Authentication.ViewModels.Registration;
using ReactiveUI;

namespace Ecliptix.Core.Features.Authentication.Views.Registration;

public partial class MobileVerificationView : ReactiveUserControl<MobileVerificationViewModel>
{
    private const string MobileTextBoxControlName = "MobileTextBox";

    private bool _handlersAttached;
    public MobileVerificationView()
    {
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }

    protected override void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e)
    {
        base.OnAttachedToVisualTree(e);
        SetupEventHandlers();
    }

    protected override void OnDetachedFromVisualTree(VisualTreeAttachmentEventArgs e)
    {
        base.OnDetachedFromVisualTree(e);
        TeardownEventHandlers();
    }

    private void SetupEventHandlers()
    {
        if (_handlersAttached)
        {
            return;
        }

        if (this.FindControl<HintedTextBox>(MobileTextBoxControlName) is { } mobileTextBox)
        {
            mobileTextBox.KeyDown += OnMobileTextBoxKeyDown;
            _handlersAttached = true;
        }
    }

    private void TeardownEventHandlers()
    {
        if (!_handlersAttached)
        {
            return;
        }

        if (this.FindControl<HintedTextBox>(MobileTextBoxControlName) is { } mobileTextBox)
        {
            mobileTextBox.KeyDown -= OnMobileTextBoxKeyDown;
        }

        _handlersAttached = false;
    }

    private void OnMobileTextBoxKeyDown(object? sender, KeyEventArgs e)
    {
        if (e.Key != Key.Enter && e.Key != Key.Return)
        {
            return;
        }

        if (DataContext is not MobileVerificationViewModel vm)
        {
            return;
        }

        vm.HandleEnterKeyPressAsync().ContinueWith(
            task =>
            {
                if (task.IsFaulted && task.Exception != null)
                {
                    Serilog.Log.Error(task.Exception, "[MOBILE-VERIFICATION-VIEW] Unhandled exception in HandleEnterKeyPressAsync");
                }
            },
            TaskScheduler.Default);
        e.Handled = true;
    }
}

 [2025-11-04T12:57:49.777] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3693ms) ************
{
  "Request_seq": 9315,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549810,
  "Type": "response"
}
 [2025-11-04T12:57:49.777] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9316,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Registration/MobileVerificationView.axaml.cs"
  }
}
 [2025-11-04T12:57:49.907] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (129.5115ms) ************
{
  "Request_seq": 9316,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549814,
  "Type": "response"
}
 [2025-11-04T12:57:49.907] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9317,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/LogoutProofHandler.cs",
    "Buffer": "using System;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Ecliptix.Core.Infrastructure.Data.Abstractions;\nusing Ecliptix.Core.Services.Abstractions.Authentication;\nusing Ecliptix.Core.Services.Common;\nusing Ecliptix.Protobuf.Membership;\nusing Ecliptix.Protocol.System.Core;\nusing Ecliptix.Protocol.System.Sodium;\nusing Ecliptix.Utilities;\nusing Ecliptix.Utilities.Failures.Authentication;\nusing Ecliptix.Utilities.Failures.Membership;\nusing Ecliptix.Utilities.Failures.Sodium;\nusing Google.Protobuf;\nusing Serilog;\n\nnamespace Ecliptix.Core.Services.Network;\n\npublic class LogoutProofHandler(IIdentityService identityService, IApplicationSecureStorageProvider applicationSecureStorageProvider)\n{\n\n    public async Task<Result<Unit, LogoutFailure>> VerifyRevocationProofAsync(\n        LogoutResponse response,\n        string membershipId,\n        uint connectId)\n    {\n        Result<byte[], LogoutFailure> proofValidation = ValidateRevocationProofFormat(response);\n        if (proofValidation.IsErr)\n        {\n            return Result<Unit, LogoutFailure>.Err(proofValidation.UnwrapErr());\n        }\n\n        byte[] revocationProof = proofValidation.Unwrap();\n\n        Result<ParsedProof, LogoutFailure> parseResult = ParseRevocationProof(revocationProof);\n        if (parseResult.IsErr)\n        {\n            return Result<Unit, LogoutFailure>.Err(parseResult.UnwrapErr());\n        }\n\n        ParsedProof parsed = parseResult.Unwrap();\n\n        return await VerifyAndStoreProofAsync(membershipId, connectId, response.ServerTimestamp, parsed, revocationProof);\n    }\n\n    private static Result<byte[], LogoutFailure> ValidateRevocationProofFormat(LogoutResponse response)\n    {\n        if (response.RevocationProof == null || response.RevocationProof.IsEmpty)\n        {\n            Log.Warning(\"[LOGOUT-PROOF] Missing revocation proof from server\");\n            return Result<byte[], LogoutFailure>.Err(\n                LogoutFailure.InvalidRevocationProof(\"Server did not provide revocation proof\"));\n        }\n\n        byte[] revocationProof = response.RevocationProof.ToByteArray();\n        const int nonceSize = 16;\n        const int hmacSize = 32;\n        int minSize = 1 + sizeof(int) * 2 + nonceSize + hmacSize;\n\n        if (revocationProof.Length < minSize)\n        {\n            Log.Warning(\"[LOGOUT-PROOF] Revocation proof is too small: {Size} bytes\", revocationProof.Length);\n            return Result<byte[], LogoutFailure>.Err(\n                LogoutFailure.InvalidRevocationProof($\"Revocation proof too small: {revocationProof.Length} bytes\"));\n        }\n\n        return Result<byte[], LogoutFailure>.Ok(revocationProof);\n    }\n\n    private readonly record struct ParsedProof(byte[] Nonce, int FingerprintLength, byte[] Fingerprint, byte[] HmacProof);\n\n    private static Result<ParsedProof, LogoutFailure> ParseRevocationProof(byte[] revocationProof)\n    {\n        const byte proofVersionHmac = 1;\n        const int nonceSize = 16;\n        const int hmacSize = 32;\n        const int maxFingerprintSize = 64;\n\n        try\n        {\n            using MemoryStream proofStream = new(revocationProof, writable: false);\n            using BinaryReader reader = new(proofStream);\n\n            Result<Unit, LogoutFailure> versionCheck = ValidateProofVersion(reader, proofVersionHmac);\n            if (versionCheck.IsErr)\n            {\n                return Result<ParsedProof, LogoutFailure>.Err(versionCheck.UnwrapErr());\n            }\n\n            Result<byte[], LogoutFailure> nonceResult = ReadNonce(reader, nonceSize);\n            if (nonceResult.IsErr)\n            {\n                return Result<ParsedProof, LogoutFailure>.Err(nonceResult.UnwrapErr());\n            }\n\n            byte[] nonce = nonceResult.Unwrap();\n\n            Result<FingerprintData, LogoutFailure> fingerprintResult = ReadFingerprint(reader, maxFingerprintSize);\n            if (fingerprintResult.IsErr)\n            {\n                return Result<ParsedProof, LogoutFailure>.Err(fingerprintResult.UnwrapErr());\n            }\n\n            FingerprintData fingerprintData = fingerprintResult.Unwrap();\n\n            Result<byte[], LogoutFailure> hmacResult = ReadHmac(reader, revocationProof.Length, hmacSize);\n            if (hmacResult.IsErr)\n            {\n                return Result<ParsedProof, LogoutFailure>.Err(hmacResult.UnwrapErr());\n            }\n\n            byte[] hmacProof = hmacResult.Unwrap();\n\n            return Result<ParsedProof, LogoutFailure>.Ok(new ParsedProof(nonce, fingerprintData.Length, fingerprintData.Data, hmacProof));\n        }\n        catch (EndOfStreamException ex)\n        {\n            Log.Warning(ex, \"[LOGOUT-PROOF] Revocation proof truncated during parsing\");\n            return Result<ParsedProof, LogoutFailure>.Err(\n                LogoutFailure.InvalidRevocationProof(\"Revocation proof truncated during parsing\"));\n        }\n    }\n\n    private static Result<Unit, LogoutFailure> ValidateProofVersion(BinaryReader reader, byte expectedVersion)\n    {\n        byte version = reader.ReadByte();\n        if (version != expectedVersion)\n        {\n            Log.Warning(\"[LOGOUT-PROOF] Unsupported revocation proof version: {Version}\", version);\n            return Result<Unit, LogoutFailure>.Err(\n                LogoutFailure.InvalidRevocationProof($\"Unsupported revocation proof version: {version}\"));\n        }\n        return Result<Unit, LogoutFailure>.Ok(Unit.Value);\n    }\n\n    private static Result<byte[], LogoutFailure> ReadNonce(BinaryReader reader, int expectedSize)\n    {\n        int nonceLength = reader.ReadInt32();\n        if (nonceLength != expectedSize)\n        {\n            Log.Warning(\"[LOGOUT-PROOF] Invalid nonce length: {Length} (expected {Expected})\", nonceLength, expectedSize);\n            return Result<byte[], LogoutFailure>.Err(\n                LogoutFailure.InvalidRevocationProof($\"Invalid nonce length {nonceLength}\"));\n        }\n\n        byte[] nonce = reader.ReadBytes(nonceLength);\n        if (nonce.Length != nonceLength)\n        {\n            Log.Warning(\"[LOGOUT-PROOF] Unable to read nonce - expected {Expected} bytes, got {Actual}\", nonceLength, nonce.Length);\n            return Result<byte[], LogoutFailure>.Err(\n                LogoutFailure.InvalidRevocationProof(\"Revocation proof truncated while reading nonce\"));\n        }\n\n        return Result<byte[], LogoutFailure>.Ok(nonce);\n    }\n\n    private readonly record struct FingerprintData(int Length, byte[] Data);\n\n    private static Result<FingerprintData, LogoutFailure> ReadFingerprint(BinaryReader reader, int maxSize)\n    {\n        int fingerprintLength = reader.ReadInt32();\n        if (fingerprintLength < 0 || fingerprintLength > maxSize)\n        {\n            Log.Warning(\"[LOGOUT-PROOF] Invalid ratchet fingerprint length: {Length}\", fingerprintLength);\n            return Result<FingerprintData, LogoutFailure>.Err(\n                LogoutFailure.InvalidRevocationProof($\"Invalid fingerprint length {fingerprintLength}\"));\n        }\n\n        byte[] fingerprint = fingerprintLength > 0 ? reader.ReadBytes(fingerprintLength) : Array.Empty<byte>();\n        if (fingerprint.Length != fingerprintLength)\n        {\n            Log.Warning(\"[LOGOUT-PROOF] Unable to read fingerprint - expected {Expected} bytes, got {Actual}\", fingerprintLength, fingerprint.Length);\n            return Result<FingerprintData, LogoutFailure>.Err(\n                LogoutFailure.InvalidRevocationProof(\"Revocation proof truncated while reading fingerprint\"));\n        }\n\n        return Result<FingerprintData, LogoutFailure>.Ok(new FingerprintData(fingerprintLength, fingerprint));\n    }\n\n    private static Result<byte[], LogoutFailure> ReadHmac(BinaryReader reader, int totalProofLength, int expectedHmacSize)\n    {\n        int remainingBytes = (int)(totalProofLength - reader.BaseStream.Position);\n        if (remainingBytes != expectedHmacSize)\n        {\n            Log.Warning(\"[LOGOUT-PROOF] Unexpected HMAC length: {Length}\", remainingBytes);\n            return Result<byte[], LogoutFailure>.Err(\n                LogoutFailure.InvalidRevocationProof($\"Invalid HMAC length {remainingBytes}\"));\n        }\n\n        byte[] hmacProof = reader.ReadBytes(expectedHmacSize);\n        if (hmacProof.Length != expectedHmacSize)\n        {\n            Log.Warning(\"[LOGOUT-PROOF] Unable to read HMAC - expected {Expected} bytes, got {Actual}\", expectedHmacSize, hmacProof.Length);\n            return Result<byte[], LogoutFailure>.Err(\n                LogoutFailure.InvalidRevocationProof(\"Revocation proof truncated while reading HMAC\"));\n        }\n\n        return Result<byte[], LogoutFailure>.Ok(hmacProof);\n    }\n\n    private async Task<Result<Unit, LogoutFailure>> VerifyAndStoreProofAsync(\n        string membershipId,\n        uint connectId,\n        long serverTimestamp,\n        ParsedProof parsed,\n        byte[] revocationProof)\n    {\n        byte[]? proofKey = null;\n\n        try\n        {\n            Result<byte[], LogoutFailure> proofKeyResult = await LoadProofKeyAsync(membershipId);\n            if (proofKeyResult.IsErr)\n            {\n                return Result<Unit, LogoutFailure>.Err(proofKeyResult.UnwrapErr());\n            }\n\n            proofKey = proofKeyResult.Unwrap();\n\n            byte[] canonicalData = BuildCanonicalData(membershipId, connectId, serverTimestamp, parsed);\n\n            bool isValid = LogoutKeyDerivation.VerifyHmac(proofKey, canonicalData, parsed.HmacProof);\n            if (!isValid)\n            {\n                Log.Warning(\"[LOGOUT-PROOF] HMAC verification failed - server proof is invalid\");\n                return Result<Unit, LogoutFailure>.Err(\n                    LogoutFailure.InvalidRevocationProof(\"Server revocation proof HMAC verification failed\"));\n            }\n\n            Result<Unit, LogoutFailure> storeResult = await StoreRevocationProofAsync(membershipId, revocationProof);\n            if (storeResult.IsErr)\n            {\n                Log.Warning(\"[LOGOUT-PROOF] Failed to store revocation proof: {Error}\", storeResult.UnwrapErr().Message);\n            }\n\n            return Result<Unit, LogoutFailure>.Ok(Unit.Value);\n        }\n        finally\n        {\n            if (proofKey != null)\n            {\n                CryptographicOperations.ZeroMemory(proofKey);\n            }\n        }\n    }\n\n    private async Task<Result<byte[], LogoutFailure>> LoadProofKeyAsync(string membershipId)\n    {\n        Result<SodiumSecureMemoryHandle, AuthenticationFailure> handleResult =\n            await identityService.LoadMasterKeyHandleAsync(membershipId).ConfigureAwait(false);\n\n        if (handleResult.IsErr)\n        {\n            Log.Error(\"[LOGOUT-PROOF] Failed to load master key handle for proof verification\");\n            return Result<byte[], LogoutFailure>.Err(\n                LogoutFailure.CryptographicOperationFailed(\n                    $\"Master key retrieval failed: {handleResult.UnwrapErr().Message}\"));\n        }\n\n        using SodiumSecureMemoryHandle masterKeyHandle = handleResult.Unwrap();\n\n        Result<byte[], SodiumFailure> proofKeyResult = LogoutKeyDerivation.DeriveLogoutProofKey(masterKeyHandle);\n        if (proofKeyResult.IsErr)\n        {\n            Log.Error(\"[LOGOUT-PROOF] Failed to derive logout proof key\");\n            return Result<byte[], LogoutFailure>.Err(\n                LogoutFailure.CryptographicOperationFailed(\n                    $\"Proof key derivation failed: {proofKeyResult.UnwrapErr().Message}\"));\n        }\n\n        return Result<byte[], LogoutFailure>.Ok(proofKeyResult.Unwrap());\n    }\n\n    private static byte[] BuildCanonicalData(string membershipId, uint connectId, long serverTimestamp, ParsedProof parsed)\n    {\n        using MemoryStream ms = new();\n        using BinaryWriter writer = new(ms);\n\n        writer.Write(Guid.Parse(membershipId).ToByteArray());\n        writer.Write(connectId);\n        writer.Write(serverTimestamp);\n        writer.Write(parsed.FingerprintLength);\n        if (parsed.FingerprintLength > 0)\n        {\n            writer.Write(parsed.Fingerprint);\n        }\n        writer.Write(parsed.Nonce);\n        writer.Flush();\n\n        return ms.ToArray();\n    }\n\n    private async Task<Result<Unit, LogoutFailure>> StoreRevocationProofAsync(\n        string membershipId,\n        byte[] revocationProof)\n    {\n        try\n        {\n            string storageKey = GetRevocationProofStorageKey(membershipId);\n\n            Result<Unit, InternalServiceApiFailure> storeResult =\n                await applicationSecureStorageProvider.StoreAsync(storageKey, revocationProof)\n                    .ConfigureAwait(false);\n\n            if (storeResult.IsErr)\n            {\n                Log.Error(\"[LOGOUT-PROOF-STORE] Failed to store revocation proof for MembershipId: {MembershipId}\",\n                    membershipId);\n                return Result<Unit, LogoutFailure>.Err(\n                    LogoutFailure.UnexpectedError(\n                        $\"Revocation proof storage failed: {storeResult.UnwrapErr().Message}\"));\n            }\n\n            return Result<Unit, LogoutFailure>.Ok(Unit.Value);\n        }\n        catch (Exception ex)\n        {\n            Log.Error(ex, \"[LOGOUT-PROOF-STORE] Unexpected error storing revocation proof\");\n            return Result<Unit, LogoutFailure>.Err(\n                LogoutFailure.UnexpectedError($\"Unexpected error: {ex.Message}\", ex));\n        }\n    }\n\n    public static async Task<bool> HasRevocationProofAsync(\n        IApplicationSecureStorageProvider storageProvider,\n        string membershipId)\n    {\n        try\n        {\n            string storageKey = GetRevocationProofStorageKey(membershipId);\n\n            Result<Option<byte[]>, InternalServiceApiFailure> getResult =\n                await storageProvider.TryGetByKeyAsync(storageKey).ConfigureAwait(false);\n\n            if (getResult.IsErr)\n            {\n                Log.Warning(\"[LOGOUT-PROOF-CHECK] Failed to check revocation proof for MembershipId: {MembershipId}\",\n                    membershipId);\n                return false;\n            }\n\n            Option<byte[]> proofOption = getResult.Unwrap();\n\n            return proofOption.IsSome;\n        }\n        catch (Exception ex)\n        {\n            Log.Error(ex, \"[LOGOUT-PROOF-CHECK] Unexpected error checking revocation proof\");\n            return false;\n        }\n    }\n\n    public static void ClearRevocationProof(\n        IApplicationSecureStorageProvider storageProvider,\n        string membershipId)\n    {\n        try\n        {\n            string storageKey = GetRevocationProofStorageKey(membershipId);\n            Result<Unit, InternalServiceApiFailure> deleteResult = storageProvider.Delete(storageKey);\n\n            if (deleteResult.IsErr)\n            {\n                Log.Warning(\"[LOGOUT-PROOF-CLEAR] Failed to clear revocation proof for MembershipId: {MembershipId}\",\n                    membershipId);\n            }\n        }\n        catch (Exception ex)\n        {\n            Log.Error(ex, \"[LOGOUT-PROOF-CLEAR] Unexpected error clearing revocation proof\");\n        }\n    }\n\n    private static string GetRevocationProofStorageKey(string membershipId) =>\n        $\"{SecureStorageConstants.Identity.RevocationProofPrefix}{membershipId}\";\n\n    public async Task<Result<Unit, LogoutFailure>> GenerateLogoutHmacProofAsync(\n        LogoutRequest request,\n        string membershipId)\n    {\n        SodiumSecureMemoryHandle? masterKeyHandle = null;\n        byte[]? hmacKey = null;\n\n        try\n        {\n            Result<SodiumSecureMemoryHandle, AuthenticationFailure> handleResult =\n                await identityService.LoadMasterKeyHandleAsync(membershipId).ConfigureAwait(false);\n\n            if (handleResult.IsErr)\n            {\n                Log.Error(\"[LOGOUT-HMAC] Failed to load master key handle for MembershipId: {MembershipId}\",\n                    membershipId);\n                return Result<Unit, LogoutFailure>.Err(\n                    LogoutFailure.CryptographicOperationFailed(\n                        $\"Master key retrieval failed: {handleResult.UnwrapErr().Message}\"));\n            }\n\n            masterKeyHandle = handleResult.Unwrap();\n\n            Result<byte[], SodiumFailure> hmacKeyResult =\n                LogoutKeyDerivation.DeriveLogoutHmacKey(masterKeyHandle);\n\n            if (hmacKeyResult.IsErr)\n            {\n                Log.Error(\"[LOGOUT-HMAC] Failed to derive logout HMAC key for MembershipId: {MembershipId}\",\n                    membershipId);\n                return Result<Unit, LogoutFailure>.Err(\n                    LogoutFailure.CryptographicOperationFailed(\n                        $\"HMAC key derivation failed: {hmacKeyResult.UnwrapErr().Message}\"));\n            }\n\n            hmacKey = hmacKeyResult.Unwrap();\n\n            string canonical = $\"logout:v1:{request.MembershipIdentifier.ToBase64()}:\" +\n                               $\"{request.Timestamp}:{request.Scope}:{request.LogoutReason}\";\n            byte[] canonicalBytes = Encoding.UTF8.GetBytes(canonical);\n\n            byte[] hmacProof = LogoutKeyDerivation.ComputeHmac(hmacKey, canonicalBytes);\n            request.HmacProof = ByteString.CopyFrom(hmacProof);\n\n            return Result<Unit, LogoutFailure>.Ok(Unit.Value);\n        }\n        finally\n        {\n            masterKeyHandle?.Dispose();\n            if (hmacKey != null)\n            {\n                CryptographicOperations.ZeroMemory(hmacKey);\n            }\n        }\n    }\n\n}\n"
  }
}
 [2025-11-04T12:57:49.907] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/LogoutProofHandler.cs with new text:
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using Ecliptix.Core.Infrastructure.Data.Abstractions;
using Ecliptix.Core.Services.Abstractions.Authentication;
using Ecliptix.Core.Services.Common;
using Ecliptix.Protobuf.Membership;
using Ecliptix.Protocol.System.Core;
using Ecliptix.Protocol.System.Sodium;
using Ecliptix.Utilities;
using Ecliptix.Utilities.Failures.Authentication;
using Ecliptix.Utilities.Failures.Membership;
using Ecliptix.Utilities.Failures.Sodium;
using Google.Protobuf;
using Serilog;

namespace Ecliptix.Core.Services.Network;

public class LogoutProofHandler(IIdentityService identityService, IApplicationSecureStorageProvider applicationSecureStorageProvider)
{

    public async Task<Result<Unit, LogoutFailure>> VerifyRevocationProofAsync(
        LogoutResponse response,
        string membershipId,
        uint connectId)
    {
        Result<byte[], LogoutFailure> proofValidation = ValidateRevocationProofFormat(response);
        if (proofValidation.IsErr)
        {
            return Result<Unit, LogoutFailure>.Err(proofValidation.UnwrapErr());
        }

        byte[] revocationProof = proofValidation.Unwrap();

        Result<ParsedProof, LogoutFailure> parseResult = ParseRevocationProof(revocationProof);
        if (parseResult.IsErr)
        {
            return Result<Unit, LogoutFailure>.Err(parseResult.UnwrapErr());
        }

        ParsedProof parsed = parseResult.Unwrap();

        return await VerifyAndStoreProofAsync(membershipId, connectId, response.ServerTimestamp, parsed, revocationProof);
    }

    private static Result<byte[], LogoutFailure> ValidateRevocationProofFormat(LogoutResponse response)
    {
        if (response.RevocationProof == null || response.RevocationProof.IsEmpty)
        {
            Log.Warning("[LOGOUT-PROOF] Missing revocation proof from server");
            return Result<byte[], LogoutFailure>.Err(
                LogoutFailure.InvalidRevocationProof("Server did not provide revocation proof"));
        }

        byte[] revocationProof = response.RevocationProof.ToByteArray();
        const int nonceSize = 16;
        const int hmacSize = 32;
        int minSize = 1 + sizeof(int) * 2 + nonceSize + hmacSize;

        if (revocationProof.Length < minSize)
        {
            Log.Warning("[LOGOUT-PROOF] Revocation proof is too small: {Size} bytes", revocationProof.Length);
            return Result<byte[], LogoutFailure>.Err(
                LogoutFailure.InvalidRevocationProof($"Revocation proof too small: {revocationProof.Length} bytes"));
        }

        return Result<byte[], LogoutFailure>.Ok(revocationProof);
    }

    private readonly record struct ParsedProof(byte[] Nonce, int FingerprintLength, byte[] Fingerprint, byte[] HmacProof);

    private static Result<ParsedProof, LogoutFailure> ParseRevocationProof(byte[] revocationProof)
    {
        const byte proofVersionHmac = 1;
        const int nonceSize = 16;
        const int hmacSize = 32;
        const int maxFingerprintSize = 64;

        try
        {
            using MemoryStream proofStream = new(revocationProof, writable: false);
            using BinaryReader reader = new(proofStream);

            Result<Unit, LogoutFailure> versionCheck = ValidateProofVersion(reader, proofVersionHmac);
            if (versionCheck.IsErr)
            {
                return Result<ParsedProof, LogoutFailure>.Err(versionCheck.UnwrapErr());
            }

            Result<byte[], LogoutFailure> nonceResult = ReadNonce(reader, nonceSize);
            if (nonceResult.IsErr)
            {
                return Result<ParsedProof, LogoutFailure>.Err(nonceResult.UnwrapErr());
            }

            byte[] nonce = nonceResult.Unwrap();

            Result<FingerprintData, LogoutFailure> fingerprintResult = ReadFingerprint(reader, maxFingerprintSize);
            if (fingerprintResult.IsErr)
            {
                return Result<ParsedProof, LogoutFailure>.Err(fingerprintResult.UnwrapErr());
            }

            FingerprintData fingerprintData = fingerprintResult.Unwrap();

            Result<byte[], LogoutFailure> hmacResult = ReadHmac(reader, revocationProof.Length, hmacSize);
            if (hmacResult.IsErr)
            {
                return Result<ParsedProof, LogoutFailure>.Err(hmacResult.UnwrapErr());
            }

            byte[] hmacProof = hmacResult.Unwrap();

            return Result<ParsedProof, LogoutFailure>.Ok(new ParsedProof(nonce, fingerprintData.Length, fingerprintData.Data, hmacProof));
        }
        catch (EndOfStreamException ex)
        {
            Log.Warning(ex, "[LOGOUT-PROOF] Revocation proof truncated during parsing");
            return Result<ParsedProof, LogoutFailure>.Err(
                LogoutFailure.InvalidRevocationProof("Revocation proof truncated during parsing"));
        }
    }

    private static Result<Unit, LogoutFailure> ValidateProofVersion(BinaryReader reader, byte expectedVersion)
    {
        byte version = reader.ReadByte();
        if (version != expectedVersion)
        {
            Log.Warning("[LOGOUT-PROOF] Unsupported revocation proof version: {Version}", version);
            return Result<Unit, LogoutFailure>.Err(
                LogoutFailure.InvalidRevocationProof($"Unsupported revocation proof version: {version}"));
        }
        return Result<Unit, LogoutFailure>.Ok(Unit.Value);
    }

    private static Result<byte[], LogoutFailure> ReadNonce(BinaryReader reader, int expectedSize)
    {
        int nonceLength = reader.ReadInt32();
        if (nonceLength != expectedSize)
        {
            Log.Warning("[LOGOUT-PROOF] Invalid nonce length: {Length} (expected {Expected})", nonceLength, expectedSize);
            return Result<byte[], LogoutFailure>.Err(
                LogoutFailure.InvalidRevocationProof($"Invalid nonce length {nonceLength}"));
        }

        byte[] nonce = reader.ReadBytes(nonceLength);
        if (nonce.Length != nonceLength)
        {
            Log.Warning("[LOGOUT-PROOF] Unable to read nonce - expected {Expected} bytes, got {Actual}", nonceLength, nonce.Length);
            return Result<byte[], LogoutFailure>.Err(
                LogoutFailure.InvalidRevocationProof("Revocation proof truncated while reading nonce"));
        }

        return Result<byte[], LogoutFailure>.Ok(nonce);
    }

    private readonly record struct FingerprintData(int Length, byte[] Data);

    private static Result<FingerprintData, LogoutFailure> ReadFingerprint(BinaryReader reader, int maxSize)
    {
        int fingerprintLength = reader.ReadInt32();
        if (fingerprintLength < 0 || fingerprintLength > maxSize)
        {
            Log.Warning("[LOGOUT-PROOF] Invalid ratchet fingerprint length: {Length}", fingerprintLength);
            return Result<FingerprintData, LogoutFailure>.Err(
                LogoutFailure.InvalidRevocationProof($"Invalid fingerprint length {fingerprintLength}"));
        }

        byte[] fingerprint = fingerprintLength > 0 ? reader.ReadBytes(fingerprintLength) : Array.Empty<byte>();
        if (fingerprint.Length != fingerprintLength)
        {
            Log.Warning("[LOGOUT-PROOF] Unable to read fingerprint - expected {Expected} bytes, got {Actual}", fingerprintLength, fingerprint.Length);
            return Result<FingerprintData, LogoutFailure>.Err(
                LogoutFailure.InvalidRevocationProof("Revocation proof truncated while reading fingerprint"));
        }

        return Result<FingerprintData, LogoutFailure>.Ok(new FingerprintData(fingerprintLength, fingerprint));
    }

    private static Result<byte[], LogoutFailure> ReadHmac(BinaryReader reader, int totalProofLength, int expectedHmacSize)
    {
        int remainingBytes = (int)(totalProofLength - reader.BaseStream.Position);
        if (remainingBytes != expectedHmacSize)
        {
            Log.Warning("[LOGOUT-PROOF] Unexpected HMAC length: {Length}", remainingBytes);
            return Result<byte[], LogoutFailure>.Err(
                LogoutFailure.InvalidRevocationProof($"Invalid HMAC length {remainingBytes}"));
        }

        byte[] hmacProof = reader.ReadBytes(expectedHmacSize);
        if (hmacProof.Length != expectedHmacSize)
        {
            Log.Warning("[LOGOUT-PROOF] Unable to read HMAC - expected {Expected} bytes, got {Actual}", expectedHmacSize, hmacProof.Length);
            return Result<byte[], LogoutFailure>.Err(
                LogoutFailure.InvalidRevocationProof("Revocation proof truncated while reading HMAC"));
        }

        return Result<byte[], LogoutFailure>.Ok(hmacProof);
    }

    private async Task<Result<Unit, LogoutFailure>> VerifyAndStoreProofAsync(
        string membershipId,
        uint connectId,
        long serverTimestamp,
        ParsedProof parsed,
        byte[] revocationProof)
    {
        byte[]? proofKey = null;

        try
        {
            Result<byte[], LogoutFailure> proofKeyResult = await LoadProofKeyAsync(membershipId);
            if (proofKeyResult.IsErr)
            {
                return Result<Unit, LogoutFailure>.Err(proofKeyResult.UnwrapErr());
            }

            proofKey = proofKeyResult.Unwrap();

            byte[] canonicalData = BuildCanonicalData(membershipId, connectId, serverTimestamp, parsed);

            bool isValid = LogoutKeyDerivation.VerifyHmac(proofKey, canonicalData, parsed.HmacProof);
            if (!isValid)
            {
                Log.Warning("[LOGOUT-PROOF] HMAC verification failed - server proof is invalid");
                return Result<Unit, LogoutFailure>.Err(
                    LogoutFailure.InvalidRevocationProof("Server revocation proof HMAC verification failed"));
            }

            Result<Unit, LogoutFailure> storeResult = await StoreRevocationProofAsync(membershipId, revocationProof);
            if (storeResult.IsErr)
            {
                Log.Warning("[LOGOUT-PROOF] Failed to store revocation proof: {Error}", storeResult.UnwrapErr().Message);
            }

            return Result<Unit, LogoutFailure>.Ok(Unit.Value);
        }
        finally
        {
            if (proofKey != null)
            {
                CryptographicOperations.ZeroMemory(proofKey);
            }
        }
    }

    private async Task<Result<byte[], LogoutFailure>> LoadProofKeyAsync(string membershipId)
    {
        Result<SodiumSecureMemoryHandle, AuthenticationFailure> handleResult =
            await identityService.LoadMasterKeyHandleAsync(membershipId).ConfigureAwait(false);

        if (handleResult.IsErr)
        {
            Log.Error("[LOGOUT-PROOF] Failed to load master key handle for proof verification");
            return Result<byte[], LogoutFailure>.Err(
                LogoutFailure.CryptographicOperationFailed(
                    $"Master key retrieval failed: {handleResult.UnwrapErr().Message}"));
        }

        using SodiumSecureMemoryHandle masterKeyHandle = handleResult.Unwrap();

        Result<byte[], SodiumFailure> proofKeyResult = LogoutKeyDerivation.DeriveLogoutProofKey(masterKeyHandle);
        if (proofKeyResult.IsErr)
        {
            Log.Error("[LOGOUT-PROOF] Failed to derive logout proof key");
            return Result<byte[], LogoutFailure>.Err(
                LogoutFailure.CryptographicOperationFailed(
                    $"Proof key derivation failed: {proofKeyResult.UnwrapErr().Message}"));
        }

        return Result<byte[], LogoutFailure>.Ok(proofKeyResult.Unwrap());
    }

    private static byte[] BuildCanonicalData(string membershipId, uint connectId, long serverTimestamp, ParsedProof parsed)
    {
        using MemoryStream ms = new();
        using BinaryWriter writer = new(ms);

        writer.Write(Guid.Parse(membershipId).ToByteArray());
        writer.Write(connectId);
        writer.Write(serverTimestamp);
        writer.Write(parsed.FingerprintLength);
        if (parsed.FingerprintLength > 0)
        {
            writer.Write(parsed.Fingerprint);
        }
        writer.Write(parsed.Nonce);
        writer.Flush();

        return ms.ToArray();
    }

    private async Task<Result<Unit, LogoutFailure>> StoreRevocationProofAsync(
        string membershipId,
        byte[] revocationProof)
    {
        try
        {
            string storageKey = GetRevocationProofStorageKey(membershipId);

            Result<Unit, InternalServiceApiFailure> storeResult =
                await applicationSecureStorageProvider.StoreAsync(storageKey, revocationProof)
                    .ConfigureAwait(false);

            if (storeResult.IsErr)
            {
                Log.Error("[LOGOUT-PROOF-STORE] Failed to store revocation proof for MembershipId: {MembershipId}",
                    membershipId);
                return Result<Unit, LogoutFailure>.Err(
                    LogoutFailure.UnexpectedError(
                        $"Revocation proof storage failed: {storeResult.UnwrapErr().Message}"));
            }

            return Result<Unit, LogoutFailure>.Ok(Unit.Value);
        }
        catch (Exception ex)
        {
            Log.Error(ex, "[LOGOUT-PROOF-STORE] Unexpected error storing revocation proof");
            return Result<Unit, LogoutFailure>.Err(
                LogoutFailure.UnexpectedError($"Unexpected error: {ex.Message}", ex));
        }
    }

    public static async Task<bool> HasRevocationProofAsync(
        IApplicationSecureStorageProvider storageProvider,
        string membershipId)
    {
        try
        {
            string storageKey = GetRevocationProofStorageKey(membershipId);

            Result<Option<byte[]>, InternalServiceApiFailure> getResult =
                await storageProvider.TryGetByKeyAsync(storageKey).ConfigureAwait(false);

            if (getResult.IsErr)
            {
                Log.Warning("[LOGOUT-PROOF-CHECK] Failed to check revocation proof for MembershipId: {MembershipId}",
                    membershipId);
                return false;
            }

            Option<byte[]> proofOption = getResult.Unwrap();

            return proofOption.IsSome;
        }
        catch (Exception ex)
        {
            Log.Error(ex, "[LOGOUT-PROOF-CHECK] Unexpected error checking revocation proof");
            return false;
        }
    }

    public static void ClearRevocationProof(
        IApplicationSecureStorageProvider storageProvider,
        string membershipId)
    {
        try
        {
            string storageKey = GetRevocationProofStorageKey(membershipId);
            Result<Unit, InternalServiceApiFailure> deleteResult = storageProvider.Delete(storageKey);

            if (deleteResult.IsErr)
            {
                Log.Warning("[LOGOUT-PROOF-CLEAR] Failed to clear revocation proof for MembershipId: {MembershipId}",
                    membershipId);
            }
        }
        catch (Exception ex)
        {
            Log.Error(ex, "[LOGOUT-PROOF-CLEAR] Unexpected error clearing revocation proof");
        }
    }

    private static string GetRevocationProofStorageKey(string membershipId) =>
        $"{SecureStorageConstants.Identity.RevocationProofPrefix}{membershipId}";

    public async Task<Result<Unit, LogoutFailure>> GenerateLogoutHmacProofAsync(
        LogoutRequest request,
        string membershipId)
    {
        SodiumSecureMemoryHandle? masterKeyHandle = null;
        byte[]? hmacKey = null;

        try
        {
            Result<SodiumSecureMemoryHandle, AuthenticationFailure> handleResult =
                await identityService.LoadMasterKeyHandleAsync(membershipId).ConfigureAwait(false);

            if (handleResult.IsErr)
            {
                Log.Error("[LOGOUT-HMAC] Failed to load master key handle for MembershipId: {MembershipId}",
                    membershipId);
                return Result<Unit, LogoutFailure>.Err(
                    LogoutFailure.CryptographicOperationFailed(
                        $"Master key retrieval failed: {handleResult.UnwrapErr().Message}"));
            }

            masterKeyHandle = handleResult.Unwrap();

            Result<byte[], SodiumFailure> hmacKeyResult =
                LogoutKeyDerivation.DeriveLogoutHmacKey(masterKeyHandle);

            if (hmacKeyResult.IsErr)
            {
                Log.Error("[LOGOUT-HMAC] Failed to derive logout HMAC key for MembershipId: {MembershipId}",
                    membershipId);
                return Result<Unit, LogoutFailure>.Err(
                    LogoutFailure.CryptographicOperationFailed(
                        $"HMAC key derivation failed: {hmacKeyResult.UnwrapErr().Message}"));
            }

            hmacKey = hmacKeyResult.Unwrap();

            string canonical = $"logout:v1:{request.MembershipIdentifier.ToBase64()}:" +
                               $"{request.Timestamp}:{request.Scope}:{request.LogoutReason}";
            byte[] canonicalBytes = Encoding.UTF8.GetBytes(canonical);

            byte[] hmacProof = LogoutKeyDerivation.ComputeHmac(hmacKey, canonicalBytes);
            request.HmacProof = ByteString.CopyFrom(hmacProof);

            return Result<Unit, LogoutFailure>.Ok(Unit.Value);
        }
        finally
        {
            masterKeyHandle?.Dispose();
            if (hmacKey != null)
            {
                CryptographicOperations.ZeroMemory(hmacKey);
            }
        }
    }

}

 [2025-11-04T12:57:49.907] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.5781ms) ************
{
  "Request_seq": 9317,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549819,
  "Type": "response"
}
 [2025-11-04T12:57:49.908] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9318,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/LogoutProofHandler.cs"
  }
}
 [2025-11-04T12:57:50.176] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (268.7698ms) ************
{
  "Request_seq": 9318,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549823,
  "Type": "response"
}
 [2025-11-04T12:57:50.178] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9319,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/Encryption.cs",
    "Buffer": "// <auto-generated>\n//     Generated by the protocol buffer compiler.  DO NOT EDIT!\n//     source: common/encryption.proto\n// </auto-generated>\n#pragma warning disable 1591, 0612, 3021, 8981\n#region Designer generated code\n\nusing pb = global::Google.Protobuf;\nusing pbc = global::Google.Protobuf.Collections;\nusing pbr = global::Google.Protobuf.Reflection;\nusing scg = global::System.Collections.Generic;\nnamespace Ecliptix.Protobuf.Common {\n\n  /// <summary>Holder for reflection information generated from common/encryption.proto</summary>\n  public static partial class EncryptionReflection {\n\n    #region Descriptor\n    /// <summary>File descriptor for common/encryption.proto</summary>\n    public static pbr::FileDescriptor Descriptor {\n      get { return descriptor; }\n    }\n    private static pbr::FileDescriptor descriptor;\n\n    static EncryptionReflection() {\n      byte[] descriptorData = global::System.Convert.FromBase64String(\n          string.Concat(\n            \"Chdjb21tb24vZW5jcnlwdGlvbi5wcm90bxIVZWNsaXB0aXgucHJvdG8uY29t\",\n            \"bW9uInYKDEtleU1hdGVyaWFscxIbChNpZGVudGl0eV9wdWJsaWNfa2V5GAEg\",\n            \"ASgMEhwKFGVwaGVtZXJhbF9wdWJsaWNfa2V5GAIgASgMEhgKEG9uZV90aW1l\",\n            \"X3ByZV9rZXkYAyABKAwSEQoJc2lnbmF0dXJlGAQgASgMQhuqAhhFY2xpcHRp\",\n            \"eC5Qcm90b2J1Zi5Db21tb25iBnByb3RvMw==\"));\n      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,\n          new pbr::FileDescriptor[] { },\n          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Common.KeyMaterials), global::Ecliptix.Protobuf.Common.KeyMaterials.Parser, new[]{ \"IdentityPublicKey\", \"EphemeralPublicKey\", \"OneTimePreKey\", \"Signature\" }, null, null, null, null)\n          }));\n    }\n    #endregion\n\n  }\n  #region Messages\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class KeyMaterials : pb::IMessage<KeyMaterials>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<KeyMaterials> _parser = new pb::MessageParser<KeyMaterials>(() => new KeyMaterials());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<KeyMaterials> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Common.EncryptionReflection.Descriptor.MessageTypes[0]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public KeyMaterials() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public KeyMaterials(KeyMaterials other) : this() {\n      identityPublicKey_ = other.identityPublicKey_;\n      ephemeralPublicKey_ = other.ephemeralPublicKey_;\n      oneTimePreKey_ = other.oneTimePreKey_;\n      signature_ = other.signature_;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public KeyMaterials Clone() {\n      return new KeyMaterials(this);\n    }\n\n    /// <summary>Field number for the \"identity_public_key\" field.</summary>\n    public const int IdentityPublicKeyFieldNumber = 1;\n    private pb::ByteString identityPublicKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString IdentityPublicKey {\n      get { return identityPublicKey_; }\n      set {\n        identityPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"ephemeral_public_key\" field.</summary>\n    public const int EphemeralPublicKeyFieldNumber = 2;\n    private pb::ByteString ephemeralPublicKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString EphemeralPublicKey {\n      get { return ephemeralPublicKey_; }\n      set {\n        ephemeralPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"one_time_pre_key\" field.</summary>\n    public const int OneTimePreKeyFieldNumber = 3;\n    private pb::ByteString oneTimePreKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString OneTimePreKey {\n      get { return oneTimePreKey_; }\n      set {\n        oneTimePreKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"signature\" field.</summary>\n    public const int SignatureFieldNumber = 4;\n    private pb::ByteString signature_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString Signature {\n      get { return signature_; }\n      set {\n        signature_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as KeyMaterials);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(KeyMaterials other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (IdentityPublicKey != other.IdentityPublicKey) return false;\n      if (EphemeralPublicKey != other.EphemeralPublicKey) return false;\n      if (OneTimePreKey != other.OneTimePreKey) return false;\n      if (Signature != other.Signature) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (IdentityPublicKey.Length != 0) hash ^= IdentityPublicKey.GetHashCode();\n      if (EphemeralPublicKey.Length != 0) hash ^= EphemeralPublicKey.GetHashCode();\n      if (OneTimePreKey.Length != 0) hash ^= OneTimePreKey.GetHashCode();\n      if (Signature.Length != 0) hash ^= Signature.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (IdentityPublicKey.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(IdentityPublicKey);\n      }\n      if (EphemeralPublicKey.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(EphemeralPublicKey);\n      }\n      if (OneTimePreKey.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(OneTimePreKey);\n      }\n      if (Signature.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(Signature);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (IdentityPublicKey.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(IdentityPublicKey);\n      }\n      if (EphemeralPublicKey.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(EphemeralPublicKey);\n      }\n      if (OneTimePreKey.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(OneTimePreKey);\n      }\n      if (Signature.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(Signature);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (IdentityPublicKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(IdentityPublicKey);\n      }\n      if (EphemeralPublicKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EphemeralPublicKey);\n      }\n      if (OneTimePreKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(OneTimePreKey);\n      }\n      if (Signature.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(KeyMaterials other) {\n      if (other == null) {\n        return;\n      }\n      if (other.IdentityPublicKey.Length != 0) {\n        IdentityPublicKey = other.IdentityPublicKey;\n      }\n      if (other.EphemeralPublicKey.Length != 0) {\n        EphemeralPublicKey = other.EphemeralPublicKey;\n      }\n      if (other.OneTimePreKey.Length != 0) {\n        OneTimePreKey = other.OneTimePreKey;\n      }\n      if (other.Signature.Length != 0) {\n        Signature = other.Signature;\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            IdentityPublicKey = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            EphemeralPublicKey = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            OneTimePreKey = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            Signature = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            IdentityPublicKey = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            EphemeralPublicKey = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            OneTimePreKey = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            Signature = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n  }\n\n  #endregion\n\n}\n\n#endregion Designer generated code\n"
  }
}
 [2025-11-04T12:57:50.178] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/Encryption.cs with new text:
// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: common/encryption.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Ecliptix.Protobuf.Common {

  /// <summary>Holder for reflection information generated from common/encryption.proto</summary>
  public static partial class EncryptionReflection {

    #region Descriptor
    /// <summary>File descriptor for common/encryption.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static EncryptionReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Chdjb21tb24vZW5jcnlwdGlvbi5wcm90bxIVZWNsaXB0aXgucHJvdG8uY29t",
            "bW9uInYKDEtleU1hdGVyaWFscxIbChNpZGVudGl0eV9wdWJsaWNfa2V5GAEg",
            "ASgMEhwKFGVwaGVtZXJhbF9wdWJsaWNfa2V5GAIgASgMEhgKEG9uZV90aW1l",
            "X3ByZV9rZXkYAyABKAwSEQoJc2lnbmF0dXJlGAQgASgMQhuqAhhFY2xpcHRp",
            "eC5Qcm90b2J1Zi5Db21tb25iBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Common.KeyMaterials), global::Ecliptix.Protobuf.Common.KeyMaterials.Parser, new[]{ "IdentityPublicKey", "EphemeralPublicKey", "OneTimePreKey", "Signature" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class KeyMaterials : pb::IMessage<KeyMaterials>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeyMaterials> _parser = new pb::MessageParser<KeyMaterials>(() => new KeyMaterials());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<KeyMaterials> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Common.EncryptionReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyMaterials() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyMaterials(KeyMaterials other) : this() {
      identityPublicKey_ = other.identityPublicKey_;
      ephemeralPublicKey_ = other.ephemeralPublicKey_;
      oneTimePreKey_ = other.oneTimePreKey_;
      signature_ = other.signature_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyMaterials Clone() {
      return new KeyMaterials(this);
    }

    /// <summary>Field number for the "identity_public_key" field.</summary>
    public const int IdentityPublicKeyFieldNumber = 1;
    private pb::ByteString identityPublicKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString IdentityPublicKey {
      get { return identityPublicKey_; }
      set {
        identityPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ephemeral_public_key" field.</summary>
    public const int EphemeralPublicKeyFieldNumber = 2;
    private pb::ByteString ephemeralPublicKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString EphemeralPublicKey {
      get { return ephemeralPublicKey_; }
      set {
        ephemeralPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "one_time_pre_key" field.</summary>
    public const int OneTimePreKeyFieldNumber = 3;
    private pb::ByteString oneTimePreKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString OneTimePreKey {
      get { return oneTimePreKey_; }
      set {
        oneTimePreKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 4;
    private pb::ByteString signature_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Signature {
      get { return signature_; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as KeyMaterials);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(KeyMaterials other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IdentityPublicKey != other.IdentityPublicKey) return false;
      if (EphemeralPublicKey != other.EphemeralPublicKey) return false;
      if (OneTimePreKey != other.OneTimePreKey) return false;
      if (Signature != other.Signature) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (IdentityPublicKey.Length != 0) hash ^= IdentityPublicKey.GetHashCode();
      if (EphemeralPublicKey.Length != 0) hash ^= EphemeralPublicKey.GetHashCode();
      if (OneTimePreKey.Length != 0) hash ^= OneTimePreKey.GetHashCode();
      if (Signature.Length != 0) hash ^= Signature.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (IdentityPublicKey.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(IdentityPublicKey);
      }
      if (EphemeralPublicKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(EphemeralPublicKey);
      }
      if (OneTimePreKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(OneTimePreKey);
      }
      if (Signature.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(Signature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (IdentityPublicKey.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(IdentityPublicKey);
      }
      if (EphemeralPublicKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(EphemeralPublicKey);
      }
      if (OneTimePreKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(OneTimePreKey);
      }
      if (Signature.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(Signature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (IdentityPublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(IdentityPublicKey);
      }
      if (EphemeralPublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EphemeralPublicKey);
      }
      if (OneTimePreKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(OneTimePreKey);
      }
      if (Signature.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(KeyMaterials other) {
      if (other == null) {
        return;
      }
      if (other.IdentityPublicKey.Length != 0) {
        IdentityPublicKey = other.IdentityPublicKey;
      }
      if (other.EphemeralPublicKey.Length != 0) {
        EphemeralPublicKey = other.EphemeralPublicKey;
      }
      if (other.OneTimePreKey.Length != 0) {
        OneTimePreKey = other.OneTimePreKey;
      }
      if (other.Signature.Length != 0) {
        Signature = other.Signature;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            IdentityPublicKey = input.ReadBytes();
            break;
          }
          case 18: {
            EphemeralPublicKey = input.ReadBytes();
            break;
          }
          case 26: {
            OneTimePreKey = input.ReadBytes();
            break;
          }
          case 34: {
            Signature = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            IdentityPublicKey = input.ReadBytes();
            break;
          }
          case 18: {
            EphemeralPublicKey = input.ReadBytes();
            break;
          }
          case 26: {
            OneTimePreKey = input.ReadBytes();
            break;
          }
          case 34: {
            Signature = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code

 [2025-11-04T12:57:50.178] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3537ms) ************
{
  "Request_seq": 9319,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549828,
  "Type": "response"
}
 [2025-11-04T12:57:50.178] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9320,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/Encryption.cs"
  }
}
 [2025-11-04T12:57:50.349] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (171.4327ms) ************
{
  "Request_seq": 9320,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549832,
  "Type": "response"
}
 [2025-11-04T12:57:50.349] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9321,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IResettable.cs",
    "Buffer": "namespace Ecliptix.Core.Core.Abstractions;\n\npublic interface IResettable\n{\n    void ResetState();\n}\n"
  }
}
 [2025-11-04T12:57:50.35] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IResettable.cs with new text:
namespace Ecliptix.Core.Core.Abstractions;

public interface IResettable
{
    void ResetState();
}

 [2025-11-04T12:57:50.35] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3461ms) ************
{
  "Request_seq": 9321,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549837,
  "Type": "response"
}
 [2025-11-04T12:57:50.35] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9322,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IResettable.cs"
  }
}
 [2025-11-04T12:57:50.477] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (126.9466ms) ************
{
  "Request_seq": 9322,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549841,
  "Type": "response"
}
 [2025-11-04T12:57:50.478] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9323,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecureMemoryPool.cs",
    "Buffer": "using System.Collections.Concurrent;\n\nnamespace Ecliptix.Protocol.System.Utilities;\n\ninternal sealed class SecureMemoryPool : IDisposable\n{\n    private readonly ConcurrentBag<SecureMemoryBuffer> _pool = new();\n    private readonly int _defaultBufferSize;\n    private readonly int _maxPoolSize;\n    private int _currentPoolSize;\n    private bool _disposed;\n\n    public SecureMemoryPool(int defaultBufferSize = ProtocolSystemConstants.MemoryPool.DefaultBufferSize, int maxPoolSize = ProtocolSystemConstants.MemoryPool.MaxPoolSize)\n    {\n        if (defaultBufferSize <= 0)\n        {\n            throw new ArgumentException(ProtocolSystemConstants.ErrorMessages.BufferSizePositive, nameof(defaultBufferSize));\n        }\n\n        if (maxPoolSize <= 0)\n        {\n            throw new ArgumentException(ProtocolSystemConstants.ErrorMessages.MaxPoolSizePositive, nameof(maxPoolSize));\n        }\n\n        _defaultBufferSize = defaultBufferSize;\n        _maxPoolSize = maxPoolSize;\n    }\n\n    public SecureMemoryBuffer Rent(int minimumSize = -1)\n    {\n        if (_disposed)\n        {\n            throw new ObjectDisposedException(nameof(SecureMemoryPool));\n        }\n\n        int requestedSize = minimumSize > 0 ? minimumSize : _defaultBufferSize;\n        int allocatedSize = minimumSize > 0 ? Math.Max(minimumSize, _defaultBufferSize) : _defaultBufferSize;\n\n        while (_pool.TryTake(out SecureMemoryBuffer? buffer))\n        {\n            if (!buffer.IsDisposed && buffer.AllocatedSize >= requestedSize)\n            {\n                buffer.Clear();\n                buffer.SetRequestedSize(requestedSize);\n                return buffer;\n            }\n\n            buffer.Dispose();\n            Interlocked.Decrement(ref _currentPoolSize);\n        }\n\n        return new SecureMemoryBuffer(requestedSize, allocatedSize, this);\n    }\n\n    internal void Return(SecureMemoryBuffer buffer)\n    {\n        if (_disposed || buffer.IsDisposed)\n        {\n            buffer.Dispose();\n            return;\n        }\n\n        buffer.Clear();\n\n        if (_currentPoolSize < _maxPoolSize)\n        {\n            _pool.Add(buffer);\n            Interlocked.Increment(ref _currentPoolSize);\n        }\n        else\n        {\n            buffer.Dispose();\n        }\n    }\n\n    public void Dispose()\n    {\n        if (_disposed)\n        {\n            return;\n        }\n\n        _disposed = true;\n        while (_pool.TryTake(out SecureMemoryBuffer? buffer))\n        {\n            buffer.Dispose();\n        }\n    }\n}\n"
  }
}
 [2025-11-04T12:57:50.478] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecureMemoryPool.cs with new text:
using System.Collections.Concurrent;

namespace Ecliptix.Protocol.System.Utilities;

internal sealed class SecureMemoryPool : IDisposable
{
    private readonly ConcurrentBag<SecureMemoryBuffer> _pool = new();
    private readonly int _defaultBufferSize;
    private readonly int _maxPoolSize;
    private int _currentPoolSize;
    private bool _disposed;

    public SecureMemoryPool(int defaultBufferSize = ProtocolSystemConstants.MemoryPool.DefaultBufferSize, int maxPoolSize = ProtocolSystemConstants.MemoryPool.MaxPoolSize)
    {
        if (defaultBufferSize <= 0)
        {
            throw new ArgumentException(ProtocolSystemConstants.ErrorMessages.BufferSizePositive, nameof(defaultBufferSize));
        }

        if (maxPoolSize <= 0)
        {
            throw new ArgumentException(ProtocolSystemConstants.ErrorMessages.MaxPoolSizePositive, nameof(maxPoolSize));
        }

        _defaultBufferSize = defaultBufferSize;
        _maxPoolSize = maxPoolSize;
    }

    public SecureMemoryBuffer Rent(int minimumSize = -1)
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(nameof(SecureMemoryPool));
        }

        int requestedSize = minimumSize > 0 ? minimumSize : _defaultBufferSize;
        int allocatedSize = minimumSize > 0 ? Math.Max(minimumSize, _defaultBufferSize) : _defaultBufferSize;

        while (_pool.TryTake(out SecureMemoryBuffer? buffer))
        {
            if (!buffer.IsDisposed && buffer.AllocatedSize >= requestedSize)
            {
                buffer.Clear();
                buffer.SetRequestedSize(requestedSize);
                return buffer;
            }

            buffer.Dispose();
            Interlocked.Decrement(ref _currentPoolSize);
        }

        return new SecureMemoryBuffer(requestedSize, allocatedSize, this);
    }

    internal void Return(SecureMemoryBuffer buffer)
    {
        if (_disposed || buffer.IsDisposed)
        {
            buffer.Dispose();
            return;
        }

        buffer.Clear();

        if (_currentPoolSize < _maxPoolSize)
        {
            _pool.Add(buffer);
            Interlocked.Increment(ref _currentPoolSize);
        }
        else
        {
            buffer.Dispose();
        }
    }

    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        _disposed = true;
        while (_pool.TryTake(out SecureMemoryBuffer? buffer))
        {
            buffer.Dispose();
        }
    }
}

 [2025-11-04T12:57:50.478] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2646ms) ************
{
  "Request_seq": 9323,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549845,
  "Type": "response"
}
 [2025-11-04T12:57:50.478] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9324,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecureMemoryPool.cs"
  }
}
 [2025-11-04T12:57:50.549] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (70.2628ms) ************
{
  "Request_seq": 9324,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549849,
  "Type": "response"
}
 [2025-11-04T12:57:50.552] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9325,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/KeyExchange.cs",
    "Buffer": "// <auto-generated>\n//     Generated by the protocol buffer compiler.  DO NOT EDIT!\n//     source: protocol/key_exchange.proto\n// </auto-generated>\n#pragma warning disable 1591, 0612, 3021, 8981\n#region Designer generated code\n\nusing pb = global::Google.Protobuf;\nusing pbc = global::Google.Protobuf.Collections;\nusing pbr = global::Google.Protobuf.Reflection;\nusing scg = global::System.Collections.Generic;\nnamespace Ecliptix.Protobuf.Protocol {\n\n  /// <summary>Holder for reflection information generated from protocol/key_exchange.proto</summary>\n  public static partial class KeyExchangeReflection {\n\n    #region Descriptor\n    /// <summary>File descriptor for protocol/key_exchange.proto</summary>\n    public static pbr::FileDescriptor Descriptor {\n      get { return descriptor; }\n    }\n    private static pbr::FileDescriptor descriptor;\n\n    static KeyExchangeReflection() {\n      byte[] descriptorData = global::System.Convert.FromBase64String(\n          string.Concat(\n            \"Chtwcm90b2NvbC9rZXlfZXhjaGFuZ2UucHJvdG8SF2VjbGlwdGl4LnByb3Rv\",\n            \"LnByb3RvY29sIrsBCg5QdWJLZXlFeGNoYW5nZRI7CgVzdGF0ZRgBIAEoDjIs\",\n            \"LmVjbGlwdGl4LnByb3RvLnByb3RvY29sLlB1YktleUV4Y2hhbmdlU3RhdGUS\",\n            \"PAoHb2ZfdHlwZRgCIAEoDjIrLmVjbGlwdGl4LnByb3RvLnByb3RvY29sLlB1\",\n            \"YktleUV4Y2hhbmdlVHlwZRIPCgdwYXlsb2FkGAMgASgMEh0KFWluaXRpYWxf\",\n            \"RGhfcHVibGljX0tleRgEIAEoDCLjAgoPUHVibGljS2V5QnVuZGxlEhsKE2lk\",\n            \"ZW50aXR5X3B1YmxpY19rZXkYASABKAwSGQoRc2lnbmVkX3ByZV9rZXlfaWQY\",\n            \"AiABKA0SIQoZc2lnbmVkX3ByZV9rZXlfcHVibGljX2tleRgDIAEoDBIgChhz\",\n            \"aWduZWRfcHJlX2tleV9zaWduYXR1cmUYBCABKAwSUQoRb25lX3RpbWVfcHJl\",\n            \"X2tleXMYBSADKAsyNi5lY2xpcHRpeC5wcm90by5wcm90b2NvbC5QdWJsaWNL\",\n            \"ZXlCdW5kbGUuT25lVGltZVByZUtleRIiChppZGVudGl0eV94MjU1MTlfcHVi\",\n            \"bGljX2tleRgGIAEoDBIjChtlcGhlbWVyYWxfeDI1NTE5X3B1YmxpY19rZXkY\",\n            \"ByABKAwaNwoNT25lVGltZVByZUtleRISCgpwcmVfa2V5X2lkGAEgASgNEhIK\",\n            \"CnB1YmxpY19rZXkYAiABKAwqRgoTUHViS2V5RXhjaGFuZ2VTdGF0ZRIICgRJ\",\n            \"TklUEAASDAoIQ09NUExFVEUQARILCgdQRU5ESU5HEAISCgoGRkFJTEVEEAMq\",\n            \"egoSUHViS2V5RXhjaGFuZ2VUeXBlEhUKEUlOSVRJQUxfSEFORFNIQUtFEAAS\",\n            \"IQodREFUQV9DRU5URVJfRVBIRU1FUkFMX0NPTk5FQ1QQARIUChBTRVJWRVJf\",\n            \"U1RSRUFNSU5HEAISFAoQREVWSUNFX1RPX0RFVklDRRADQh2qAhpFY2xpcHRp\",\n            \"eC5Qcm90b2J1Zi5Qcm90b2NvbGIGcHJvdG8z\"));\n      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,\n          new pbr::FileDescriptor[] { },\n          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState), typeof(global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType), }, null, new pbr::GeneratedClrTypeInfo[] {\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Protocol.PubKeyExchange), global::Ecliptix.Protobuf.Protocol.PubKeyExchange.Parser, new[]{ \"State\", \"OfType\", \"Payload\", \"InitialDhPublicKey\" }, null, null, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Protocol.PublicKeyBundle), global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Parser, new[]{ \"IdentityPublicKey\", \"SignedPreKeyId\", \"SignedPreKeyPublicKey\", \"SignedPreKeySignature\", \"OneTimePreKeys\", \"IdentityX25519PublicKey\", \"EphemeralX25519PublicKey\" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey), global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey.Parser, new[]{ \"PreKeyId\", \"PublicKey\" }, null, null, null, null)})\n          }));\n    }\n    #endregion\n\n  }\n  #region Enums\n  public enum PubKeyExchangeState {\n    [pbr::OriginalName(\"INIT\")] Init = 0,\n    [pbr::OriginalName(\"COMPLETE\")] Complete = 1,\n    [pbr::OriginalName(\"PENDING\")] Pending = 2,\n    [pbr::OriginalName(\"FAILED\")] Failed = 3,\n  }\n\n  public enum PubKeyExchangeType {\n    [pbr::OriginalName(\"INITIAL_HANDSHAKE\")] InitialHandshake = 0,\n    [pbr::OriginalName(\"DATA_CENTER_EPHEMERAL_CONNECT\")] DataCenterEphemeralConnect = 1,\n    [pbr::OriginalName(\"SERVER_STREAMING\")] ServerStreaming = 2,\n    [pbr::OriginalName(\"DEVICE_TO_DEVICE\")] DeviceToDevice = 3,\n  }\n\n  #endregion\n\n  #region Messages\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class PubKeyExchange : pb::IMessage<PubKeyExchange>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<PubKeyExchange> _parser = new pb::MessageParser<PubKeyExchange>(() => new PubKeyExchange());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<PubKeyExchange> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Protocol.KeyExchangeReflection.Descriptor.MessageTypes[0]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public PubKeyExchange() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public PubKeyExchange(PubKeyExchange other) : this() {\n      state_ = other.state_;\n      ofType_ = other.ofType_;\n      payload_ = other.payload_;\n      initialDhPublicKey_ = other.initialDhPublicKey_;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public PubKeyExchange Clone() {\n      return new PubKeyExchange(this);\n    }\n\n    /// <summary>Field number for the \"state\" field.</summary>\n    public const int StateFieldNumber = 1;\n    private global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState state_ = global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState State {\n      get { return state_; }\n      set {\n        state_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"of_type\" field.</summary>\n    public const int OfTypeFieldNumber = 2;\n    private global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType ofType_ = global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType OfType {\n      get { return ofType_; }\n      set {\n        ofType_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"payload\" field.</summary>\n    public const int PayloadFieldNumber = 3;\n    private pb::ByteString payload_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString Payload {\n      get { return payload_; }\n      set {\n        payload_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"initial_Dh_public_Key\" field.</summary>\n    public const int InitialDhPublicKeyFieldNumber = 4;\n    private pb::ByteString initialDhPublicKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString InitialDhPublicKey {\n      get { return initialDhPublicKey_; }\n      set {\n        initialDhPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as PubKeyExchange);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(PubKeyExchange other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (State != other.State) return false;\n      if (OfType != other.OfType) return false;\n      if (Payload != other.Payload) return false;\n      if (InitialDhPublicKey != other.InitialDhPublicKey) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (State != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init) hash ^= State.GetHashCode();\n      if (OfType != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake) hash ^= OfType.GetHashCode();\n      if (Payload.Length != 0) hash ^= Payload.GetHashCode();\n      if (InitialDhPublicKey.Length != 0) hash ^= InitialDhPublicKey.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (State != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init) {\n        output.WriteRawTag(8);\n        output.WriteEnum((int) State);\n      }\n      if (OfType != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake) {\n        output.WriteRawTag(16);\n        output.WriteEnum((int) OfType);\n      }\n      if (Payload.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(Payload);\n      }\n      if (InitialDhPublicKey.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(InitialDhPublicKey);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (State != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init) {\n        output.WriteRawTag(8);\n        output.WriteEnum((int) State);\n      }\n      if (OfType != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake) {\n        output.WriteRawTag(16);\n        output.WriteEnum((int) OfType);\n      }\n      if (Payload.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(Payload);\n      }\n      if (InitialDhPublicKey.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(InitialDhPublicKey);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (State != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init) {\n        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) State);\n      }\n      if (OfType != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake) {\n        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OfType);\n      }\n      if (Payload.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Payload);\n      }\n      if (InitialDhPublicKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(InitialDhPublicKey);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(PubKeyExchange other) {\n      if (other == null) {\n        return;\n      }\n      if (other.State != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init) {\n        State = other.State;\n      }\n      if (other.OfType != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake) {\n        OfType = other.OfType;\n      }\n      if (other.Payload.Length != 0) {\n        Payload = other.Payload;\n      }\n      if (other.InitialDhPublicKey.Length != 0) {\n        InitialDhPublicKey = other.InitialDhPublicKey;\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 8: {\n            State = (global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState) input.ReadEnum();\n            break;\n          }\n          case 16: {\n            OfType = (global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType) input.ReadEnum();\n            break;\n          }\n          case 26: {\n            Payload = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            InitialDhPublicKey = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 8: {\n            State = (global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState) input.ReadEnum();\n            break;\n          }\n          case 16: {\n            OfType = (global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType) input.ReadEnum();\n            break;\n          }\n          case 26: {\n            Payload = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            InitialDhPublicKey = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class PublicKeyBundle : pb::IMessage<PublicKeyBundle>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<PublicKeyBundle> _parser = new pb::MessageParser<PublicKeyBundle>(() => new PublicKeyBundle());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<PublicKeyBundle> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Protocol.KeyExchangeReflection.Descriptor.MessageTypes[1]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public PublicKeyBundle() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public PublicKeyBundle(PublicKeyBundle other) : this() {\n      identityPublicKey_ = other.identityPublicKey_;\n      signedPreKeyId_ = other.signedPreKeyId_;\n      signedPreKeyPublicKey_ = other.signedPreKeyPublicKey_;\n      signedPreKeySignature_ = other.signedPreKeySignature_;\n      oneTimePreKeys_ = other.oneTimePreKeys_.Clone();\n      identityX25519PublicKey_ = other.identityX25519PublicKey_;\n      ephemeralX25519PublicKey_ = other.ephemeralX25519PublicKey_;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public PublicKeyBundle Clone() {\n      return new PublicKeyBundle(this);\n    }\n\n    /// <summary>Field number for the \"identity_public_key\" field.</summary>\n    public const int IdentityPublicKeyFieldNumber = 1;\n    private pb::ByteString identityPublicKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString IdentityPublicKey {\n      get { return identityPublicKey_; }\n      set {\n        identityPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"signed_pre_key_id\" field.</summary>\n    public const int SignedPreKeyIdFieldNumber = 2;\n    private uint signedPreKeyId_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public uint SignedPreKeyId {\n      get { return signedPreKeyId_; }\n      set {\n        signedPreKeyId_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"signed_pre_key_public_key\" field.</summary>\n    public const int SignedPreKeyPublicKeyFieldNumber = 3;\n    private pb::ByteString signedPreKeyPublicKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString SignedPreKeyPublicKey {\n      get { return signedPreKeyPublicKey_; }\n      set {\n        signedPreKeyPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"signed_pre_key_signature\" field.</summary>\n    public const int SignedPreKeySignatureFieldNumber = 4;\n    private pb::ByteString signedPreKeySignature_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString SignedPreKeySignature {\n      get { return signedPreKeySignature_; }\n      set {\n        signedPreKeySignature_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"one_time_pre_keys\" field.</summary>\n    public const int OneTimePreKeysFieldNumber = 5;\n    private static readonly pb::FieldCodec<global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey> _repeated_oneTimePreKeys_codec\n        = pb::FieldCodec.ForMessage(42, global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey.Parser);\n    private readonly pbc::RepeatedField<global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey> oneTimePreKeys_ = new pbc::RepeatedField<global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey>();\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pbc::RepeatedField<global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey> OneTimePreKeys {\n      get { return oneTimePreKeys_; }\n    }\n\n    /// <summary>Field number for the \"identity_x25519_public_key\" field.</summary>\n    public const int IdentityX25519PublicKeyFieldNumber = 6;\n    private pb::ByteString identityX25519PublicKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString IdentityX25519PublicKey {\n      get { return identityX25519PublicKey_; }\n      set {\n        identityX25519PublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"ephemeral_x25519_public_key\" field.</summary>\n    public const int EphemeralX25519PublicKeyFieldNumber = 7;\n    private pb::ByteString ephemeralX25519PublicKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString EphemeralX25519PublicKey {\n      get { return ephemeralX25519PublicKey_; }\n      set {\n        ephemeralX25519PublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as PublicKeyBundle);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(PublicKeyBundle other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (IdentityPublicKey != other.IdentityPublicKey) return false;\n      if (SignedPreKeyId != other.SignedPreKeyId) return false;\n      if (SignedPreKeyPublicKey != other.SignedPreKeyPublicKey) return false;\n      if (SignedPreKeySignature != other.SignedPreKeySignature) return false;\n      if(!oneTimePreKeys_.Equals(other.oneTimePreKeys_)) return false;\n      if (IdentityX25519PublicKey != other.IdentityX25519PublicKey) return false;\n      if (EphemeralX25519PublicKey != other.EphemeralX25519PublicKey) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (IdentityPublicKey.Length != 0) hash ^= IdentityPublicKey.GetHashCode();\n      if (SignedPreKeyId != 0) hash ^= SignedPreKeyId.GetHashCode();\n      if (SignedPreKeyPublicKey.Length != 0) hash ^= SignedPreKeyPublicKey.GetHashCode();\n      if (SignedPreKeySignature.Length != 0) hash ^= SignedPreKeySignature.GetHashCode();\n      hash ^= oneTimePreKeys_.GetHashCode();\n      if (IdentityX25519PublicKey.Length != 0) hash ^= IdentityX25519PublicKey.GetHashCode();\n      if (EphemeralX25519PublicKey.Length != 0) hash ^= EphemeralX25519PublicKey.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (IdentityPublicKey.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(IdentityPublicKey);\n      }\n      if (SignedPreKeyId != 0) {\n        output.WriteRawTag(16);\n        output.WriteUInt32(SignedPreKeyId);\n      }\n      if (SignedPreKeyPublicKey.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(SignedPreKeyPublicKey);\n      }\n      if (SignedPreKeySignature.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(SignedPreKeySignature);\n      }\n      oneTimePreKeys_.WriteTo(output, _repeated_oneTimePreKeys_codec);\n      if (IdentityX25519PublicKey.Length != 0) {\n        output.WriteRawTag(50);\n        output.WriteBytes(IdentityX25519PublicKey);\n      }\n      if (EphemeralX25519PublicKey.Length != 0) {\n        output.WriteRawTag(58);\n        output.WriteBytes(EphemeralX25519PublicKey);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (IdentityPublicKey.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(IdentityPublicKey);\n      }\n      if (SignedPreKeyId != 0) {\n        output.WriteRawTag(16);\n        output.WriteUInt32(SignedPreKeyId);\n      }\n      if (SignedPreKeyPublicKey.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(SignedPreKeyPublicKey);\n      }\n      if (SignedPreKeySignature.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(SignedPreKeySignature);\n      }\n      oneTimePreKeys_.WriteTo(ref output, _repeated_oneTimePreKeys_codec);\n      if (IdentityX25519PublicKey.Length != 0) {\n        output.WriteRawTag(50);\n        output.WriteBytes(IdentityX25519PublicKey);\n      }\n      if (EphemeralX25519PublicKey.Length != 0) {\n        output.WriteRawTag(58);\n        output.WriteBytes(EphemeralX25519PublicKey);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (IdentityPublicKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(IdentityPublicKey);\n      }\n      if (SignedPreKeyId != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SignedPreKeyId);\n      }\n      if (SignedPreKeyPublicKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SignedPreKeyPublicKey);\n      }\n      if (SignedPreKeySignature.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SignedPreKeySignature);\n      }\n      size += oneTimePreKeys_.CalculateSize(_repeated_oneTimePreKeys_codec);\n      if (IdentityX25519PublicKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(IdentityX25519PublicKey);\n      }\n      if (EphemeralX25519PublicKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EphemeralX25519PublicKey);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(PublicKeyBundle other) {\n      if (other == null) {\n        return;\n      }\n      if (other.IdentityPublicKey.Length != 0) {\n        IdentityPublicKey = other.IdentityPublicKey;\n      }\n      if (other.SignedPreKeyId != 0) {\n        SignedPreKeyId = other.SignedPreKeyId;\n      }\n      if (other.SignedPreKeyPublicKey.Length != 0) {\n        SignedPreKeyPublicKey = other.SignedPreKeyPublicKey;\n      }\n      if (other.SignedPreKeySignature.Length != 0) {\n        SignedPreKeySignature = other.SignedPreKeySignature;\n      }\n      oneTimePreKeys_.Add(other.oneTimePreKeys_);\n      if (other.IdentityX25519PublicKey.Length != 0) {\n        IdentityX25519PublicKey = other.IdentityX25519PublicKey;\n      }\n      if (other.EphemeralX25519PublicKey.Length != 0) {\n        EphemeralX25519PublicKey = other.EphemeralX25519PublicKey;\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            IdentityPublicKey = input.ReadBytes();\n            break;\n          }\n          case 16: {\n            SignedPreKeyId = input.ReadUInt32();\n            break;\n          }\n          case 26: {\n            SignedPreKeyPublicKey = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            SignedPreKeySignature = input.ReadBytes();\n            break;\n          }\n          case 42: {\n            oneTimePreKeys_.AddEntriesFrom(input, _repeated_oneTimePreKeys_codec);\n            break;\n          }\n          case 50: {\n            IdentityX25519PublicKey = input.ReadBytes();\n            break;\n          }\n          case 58: {\n            EphemeralX25519PublicKey = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            IdentityPublicKey = input.ReadBytes();\n            break;\n          }\n          case 16: {\n            SignedPreKeyId = input.ReadUInt32();\n            break;\n          }\n          case 26: {\n            SignedPreKeyPublicKey = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            SignedPreKeySignature = input.ReadBytes();\n            break;\n          }\n          case 42: {\n            oneTimePreKeys_.AddEntriesFrom(ref input, _repeated_oneTimePreKeys_codec);\n            break;\n          }\n          case 50: {\n            IdentityX25519PublicKey = input.ReadBytes();\n            break;\n          }\n          case 58: {\n            EphemeralX25519PublicKey = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n    #region Nested types\n    /// <summary>Container for nested types declared in the PublicKeyBundle message type.</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static partial class Types {\n      [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n      public sealed partial class OneTimePreKey : pb::IMessage<OneTimePreKey>\n      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n          , pb::IBufferMessage\n      #endif\n      {\n        private static readonly pb::MessageParser<OneTimePreKey> _parser = new pb::MessageParser<OneTimePreKey>(() => new OneTimePreKey());\n        private pb::UnknownFieldSet _unknownFields;\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public static pb::MessageParser<OneTimePreKey> Parser { get { return _parser; } }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public static pbr::MessageDescriptor Descriptor {\n          get { return global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Descriptor.NestedTypes[0]; }\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        pbr::MessageDescriptor pb::IMessage.Descriptor {\n          get { return Descriptor; }\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public OneTimePreKey() {\n          OnConstruction();\n        }\n\n        partial void OnConstruction();\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public OneTimePreKey(OneTimePreKey other) : this() {\n          preKeyId_ = other.preKeyId_;\n          publicKey_ = other.publicKey_;\n          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public OneTimePreKey Clone() {\n          return new OneTimePreKey(this);\n        }\n\n        /// <summary>Field number for the \"pre_key_id\" field.</summary>\n        public const int PreKeyIdFieldNumber = 1;\n        private uint preKeyId_;\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public uint PreKeyId {\n          get { return preKeyId_; }\n          set {\n            preKeyId_ = value;\n          }\n        }\n\n        /// <summary>Field number for the \"public_key\" field.</summary>\n        public const int PublicKeyFieldNumber = 2;\n        private pb::ByteString publicKey_ = pb::ByteString.Empty;\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public pb::ByteString PublicKey {\n          get { return publicKey_; }\n          set {\n            publicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n          }\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public override bool Equals(object other) {\n          return Equals(other as OneTimePreKey);\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public bool Equals(OneTimePreKey other) {\n          if (ReferenceEquals(other, null)) {\n            return false;\n          }\n          if (ReferenceEquals(other, this)) {\n            return true;\n          }\n          if (PreKeyId != other.PreKeyId) return false;\n          if (PublicKey != other.PublicKey) return false;\n          return Equals(_unknownFields, other._unknownFields);\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public override int GetHashCode() {\n          int hash = 1;\n          if (PreKeyId != 0) hash ^= PreKeyId.GetHashCode();\n          if (PublicKey.Length != 0) hash ^= PublicKey.GetHashCode();\n          if (_unknownFields != null) {\n            hash ^= _unknownFields.GetHashCode();\n          }\n          return hash;\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public override string ToString() {\n          return pb::JsonFormatter.ToDiagnosticString(this);\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public void WriteTo(pb::CodedOutputStream output) {\n        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n          output.WriteRawMessage(this);\n        #else\n          if (PreKeyId != 0) {\n            output.WriteRawTag(8);\n            output.WriteUInt32(PreKeyId);\n          }\n          if (PublicKey.Length != 0) {\n            output.WriteRawTag(18);\n            output.WriteBytes(PublicKey);\n          }\n          if (_unknownFields != null) {\n            _unknownFields.WriteTo(output);\n          }\n        #endif\n        }\n\n        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n          if (PreKeyId != 0) {\n            output.WriteRawTag(8);\n            output.WriteUInt32(PreKeyId);\n          }\n          if (PublicKey.Length != 0) {\n            output.WriteRawTag(18);\n            output.WriteBytes(PublicKey);\n          }\n          if (_unknownFields != null) {\n            _unknownFields.WriteTo(ref output);\n          }\n        }\n        #endif\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public int CalculateSize() {\n          int size = 0;\n          if (PreKeyId != 0) {\n            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PreKeyId);\n          }\n          if (PublicKey.Length != 0) {\n            size += 1 + pb::CodedOutputStream.ComputeBytesSize(PublicKey);\n          }\n          if (_unknownFields != null) {\n            size += _unknownFields.CalculateSize();\n          }\n          return size;\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public void MergeFrom(OneTimePreKey other) {\n          if (other == null) {\n            return;\n          }\n          if (other.PreKeyId != 0) {\n            PreKeyId = other.PreKeyId;\n          }\n          if (other.PublicKey.Length != 0) {\n            PublicKey = other.PublicKey;\n          }\n          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        public void MergeFrom(pb::CodedInputStream input) {\n        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n          input.ReadRawMessage(this);\n        #else\n          uint tag;\n          while ((tag = input.ReadTag()) != 0) {\n          if ((tag & 7) == 4) {\n            // Abort on any end group tag.\n            return;\n          }\n          switch(tag) {\n              default:\n                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n                break;\n              case 8: {\n                PreKeyId = input.ReadUInt32();\n                break;\n              }\n              case 18: {\n                PublicKey = input.ReadBytes();\n                break;\n              }\n            }\n          }\n        #endif\n        }\n\n        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n          uint tag;\n          while ((tag = input.ReadTag()) != 0) {\n          if ((tag & 7) == 4) {\n            // Abort on any end group tag.\n            return;\n          }\n          switch(tag) {\n              default:\n                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n                break;\n              case 8: {\n                PreKeyId = input.ReadUInt32();\n                break;\n              }\n              case 18: {\n                PublicKey = input.ReadBytes();\n                break;\n              }\n            }\n          }\n        }\n        #endif\n\n      }\n\n    }\n    #endregion\n\n  }\n\n  #endregion\n\n}\n\n#endregion Designer generated code\n"
  }
}
 [2025-11-04T12:57:50.553] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/KeyExchange.cs with new text:
// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: protocol/key_exchange.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Ecliptix.Protobuf.Protocol {

  /// <summary>Holder for reflection information generated from protocol/key_exchange.proto</summary>
  public static partial class KeyExchangeReflection {

    #region Descriptor
    /// <summary>File descriptor for protocol/key_exchange.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static KeyExchangeReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Chtwcm90b2NvbC9rZXlfZXhjaGFuZ2UucHJvdG8SF2VjbGlwdGl4LnByb3Rv",
            "LnByb3RvY29sIrsBCg5QdWJLZXlFeGNoYW5nZRI7CgVzdGF0ZRgBIAEoDjIs",
            "LmVjbGlwdGl4LnByb3RvLnByb3RvY29sLlB1YktleUV4Y2hhbmdlU3RhdGUS",
            "PAoHb2ZfdHlwZRgCIAEoDjIrLmVjbGlwdGl4LnByb3RvLnByb3RvY29sLlB1",
            "YktleUV4Y2hhbmdlVHlwZRIPCgdwYXlsb2FkGAMgASgMEh0KFWluaXRpYWxf",
            "RGhfcHVibGljX0tleRgEIAEoDCLjAgoPUHVibGljS2V5QnVuZGxlEhsKE2lk",
            "ZW50aXR5X3B1YmxpY19rZXkYASABKAwSGQoRc2lnbmVkX3ByZV9rZXlfaWQY",
            "AiABKA0SIQoZc2lnbmVkX3ByZV9rZXlfcHVibGljX2tleRgDIAEoDBIgChhz",
            "aWduZWRfcHJlX2tleV9zaWduYXR1cmUYBCABKAwSUQoRb25lX3RpbWVfcHJl",
            "X2tleXMYBSADKAsyNi5lY2xpcHRpeC5wcm90by5wcm90b2NvbC5QdWJsaWNL",
            "ZXlCdW5kbGUuT25lVGltZVByZUtleRIiChppZGVudGl0eV94MjU1MTlfcHVi",
            "bGljX2tleRgGIAEoDBIjChtlcGhlbWVyYWxfeDI1NTE5X3B1YmxpY19rZXkY",
            "ByABKAwaNwoNT25lVGltZVByZUtleRISCgpwcmVfa2V5X2lkGAEgASgNEhIK",
            "CnB1YmxpY19rZXkYAiABKAwqRgoTUHViS2V5RXhjaGFuZ2VTdGF0ZRIICgRJ",
            "TklUEAASDAoIQ09NUExFVEUQARILCgdQRU5ESU5HEAISCgoGRkFJTEVEEAMq",
            "egoSUHViS2V5RXhjaGFuZ2VUeXBlEhUKEUlOSVRJQUxfSEFORFNIQUtFEAAS",
            "IQodREFUQV9DRU5URVJfRVBIRU1FUkFMX0NPTk5FQ1QQARIUChBTRVJWRVJf",
            "U1RSRUFNSU5HEAISFAoQREVWSUNFX1RPX0RFVklDRRADQh2qAhpFY2xpcHRp",
            "eC5Qcm90b2J1Zi5Qcm90b2NvbGIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState), typeof(global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Protocol.PubKeyExchange), global::Ecliptix.Protobuf.Protocol.PubKeyExchange.Parser, new[]{ "State", "OfType", "Payload", "InitialDhPublicKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Protocol.PublicKeyBundle), global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Parser, new[]{ "IdentityPublicKey", "SignedPreKeyId", "SignedPreKeyPublicKey", "SignedPreKeySignature", "OneTimePreKeys", "IdentityX25519PublicKey", "EphemeralX25519PublicKey" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey), global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey.Parser, new[]{ "PreKeyId", "PublicKey" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Enums
  public enum PubKeyExchangeState {
    [pbr::OriginalName("INIT")] Init = 0,
    [pbr::OriginalName("COMPLETE")] Complete = 1,
    [pbr::OriginalName("PENDING")] Pending = 2,
    [pbr::OriginalName("FAILED")] Failed = 3,
  }

  public enum PubKeyExchangeType {
    [pbr::OriginalName("INITIAL_HANDSHAKE")] InitialHandshake = 0,
    [pbr::OriginalName("DATA_CENTER_EPHEMERAL_CONNECT")] DataCenterEphemeralConnect = 1,
    [pbr::OriginalName("SERVER_STREAMING")] ServerStreaming = 2,
    [pbr::OriginalName("DEVICE_TO_DEVICE")] DeviceToDevice = 3,
  }

  #endregion

  #region Messages
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PubKeyExchange : pb::IMessage<PubKeyExchange>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PubKeyExchange> _parser = new pb::MessageParser<PubKeyExchange>(() => new PubKeyExchange());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PubKeyExchange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Protocol.KeyExchangeReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PubKeyExchange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PubKeyExchange(PubKeyExchange other) : this() {
      state_ = other.state_;
      ofType_ = other.ofType_;
      payload_ = other.payload_;
      initialDhPublicKey_ = other.initialDhPublicKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PubKeyExchange Clone() {
      return new PubKeyExchange(this);
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 1;
    private global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState state_ = global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    /// <summary>Field number for the "of_type" field.</summary>
    public const int OfTypeFieldNumber = 2;
    private global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType ofType_ = global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType OfType {
      get { return ofType_; }
      set {
        ofType_ = value;
      }
    }

    /// <summary>Field number for the "payload" field.</summary>
    public const int PayloadFieldNumber = 3;
    private pb::ByteString payload_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Payload {
      get { return payload_; }
      set {
        payload_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "initial_Dh_public_Key" field.</summary>
    public const int InitialDhPublicKeyFieldNumber = 4;
    private pb::ByteString initialDhPublicKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString InitialDhPublicKey {
      get { return initialDhPublicKey_; }
      set {
        initialDhPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PubKeyExchange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PubKeyExchange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (State != other.State) return false;
      if (OfType != other.OfType) return false;
      if (Payload != other.Payload) return false;
      if (InitialDhPublicKey != other.InitialDhPublicKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (State != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init) hash ^= State.GetHashCode();
      if (OfType != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake) hash ^= OfType.GetHashCode();
      if (Payload.Length != 0) hash ^= Payload.GetHashCode();
      if (InitialDhPublicKey.Length != 0) hash ^= InitialDhPublicKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (State != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init) {
        output.WriteRawTag(8);
        output.WriteEnum((int) State);
      }
      if (OfType != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake) {
        output.WriteRawTag(16);
        output.WriteEnum((int) OfType);
      }
      if (Payload.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Payload);
      }
      if (InitialDhPublicKey.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(InitialDhPublicKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (State != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init) {
        output.WriteRawTag(8);
        output.WriteEnum((int) State);
      }
      if (OfType != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake) {
        output.WriteRawTag(16);
        output.WriteEnum((int) OfType);
      }
      if (Payload.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Payload);
      }
      if (InitialDhPublicKey.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(InitialDhPublicKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (State != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) State);
      }
      if (OfType != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OfType);
      }
      if (Payload.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Payload);
      }
      if (InitialDhPublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(InitialDhPublicKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PubKeyExchange other) {
      if (other == null) {
        return;
      }
      if (other.State != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState.Init) {
        State = other.State;
      }
      if (other.OfType != global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType.InitialHandshake) {
        OfType = other.OfType;
      }
      if (other.Payload.Length != 0) {
        Payload = other.Payload;
      }
      if (other.InitialDhPublicKey.Length != 0) {
        InitialDhPublicKey = other.InitialDhPublicKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            State = (global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState) input.ReadEnum();
            break;
          }
          case 16: {
            OfType = (global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType) input.ReadEnum();
            break;
          }
          case 26: {
            Payload = input.ReadBytes();
            break;
          }
          case 34: {
            InitialDhPublicKey = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            State = (global::Ecliptix.Protobuf.Protocol.PubKeyExchangeState) input.ReadEnum();
            break;
          }
          case 16: {
            OfType = (global::Ecliptix.Protobuf.Protocol.PubKeyExchangeType) input.ReadEnum();
            break;
          }
          case 26: {
            Payload = input.ReadBytes();
            break;
          }
          case 34: {
            InitialDhPublicKey = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PublicKeyBundle : pb::IMessage<PublicKeyBundle>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PublicKeyBundle> _parser = new pb::MessageParser<PublicKeyBundle>(() => new PublicKeyBundle());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PublicKeyBundle> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Protocol.KeyExchangeReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PublicKeyBundle() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PublicKeyBundle(PublicKeyBundle other) : this() {
      identityPublicKey_ = other.identityPublicKey_;
      signedPreKeyId_ = other.signedPreKeyId_;
      signedPreKeyPublicKey_ = other.signedPreKeyPublicKey_;
      signedPreKeySignature_ = other.signedPreKeySignature_;
      oneTimePreKeys_ = other.oneTimePreKeys_.Clone();
      identityX25519PublicKey_ = other.identityX25519PublicKey_;
      ephemeralX25519PublicKey_ = other.ephemeralX25519PublicKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PublicKeyBundle Clone() {
      return new PublicKeyBundle(this);
    }

    /// <summary>Field number for the "identity_public_key" field.</summary>
    public const int IdentityPublicKeyFieldNumber = 1;
    private pb::ByteString identityPublicKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString IdentityPublicKey {
      get { return identityPublicKey_; }
      set {
        identityPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "signed_pre_key_id" field.</summary>
    public const int SignedPreKeyIdFieldNumber = 2;
    private uint signedPreKeyId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint SignedPreKeyId {
      get { return signedPreKeyId_; }
      set {
        signedPreKeyId_ = value;
      }
    }

    /// <summary>Field number for the "signed_pre_key_public_key" field.</summary>
    public const int SignedPreKeyPublicKeyFieldNumber = 3;
    private pb::ByteString signedPreKeyPublicKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString SignedPreKeyPublicKey {
      get { return signedPreKeyPublicKey_; }
      set {
        signedPreKeyPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "signed_pre_key_signature" field.</summary>
    public const int SignedPreKeySignatureFieldNumber = 4;
    private pb::ByteString signedPreKeySignature_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString SignedPreKeySignature {
      get { return signedPreKeySignature_; }
      set {
        signedPreKeySignature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "one_time_pre_keys" field.</summary>
    public const int OneTimePreKeysFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey> _repeated_oneTimePreKeys_codec
        = pb::FieldCodec.ForMessage(42, global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey.Parser);
    private readonly pbc::RepeatedField<global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey> oneTimePreKeys_ = new pbc::RepeatedField<global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Types.OneTimePreKey> OneTimePreKeys {
      get { return oneTimePreKeys_; }
    }

    /// <summary>Field number for the "identity_x25519_public_key" field.</summary>
    public const int IdentityX25519PublicKeyFieldNumber = 6;
    private pb::ByteString identityX25519PublicKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString IdentityX25519PublicKey {
      get { return identityX25519PublicKey_; }
      set {
        identityX25519PublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ephemeral_x25519_public_key" field.</summary>
    public const int EphemeralX25519PublicKeyFieldNumber = 7;
    private pb::ByteString ephemeralX25519PublicKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString EphemeralX25519PublicKey {
      get { return ephemeralX25519PublicKey_; }
      set {
        ephemeralX25519PublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PublicKeyBundle);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PublicKeyBundle other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IdentityPublicKey != other.IdentityPublicKey) return false;
      if (SignedPreKeyId != other.SignedPreKeyId) return false;
      if (SignedPreKeyPublicKey != other.SignedPreKeyPublicKey) return false;
      if (SignedPreKeySignature != other.SignedPreKeySignature) return false;
      if(!oneTimePreKeys_.Equals(other.oneTimePreKeys_)) return false;
      if (IdentityX25519PublicKey != other.IdentityX25519PublicKey) return false;
      if (EphemeralX25519PublicKey != other.EphemeralX25519PublicKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (IdentityPublicKey.Length != 0) hash ^= IdentityPublicKey.GetHashCode();
      if (SignedPreKeyId != 0) hash ^= SignedPreKeyId.GetHashCode();
      if (SignedPreKeyPublicKey.Length != 0) hash ^= SignedPreKeyPublicKey.GetHashCode();
      if (SignedPreKeySignature.Length != 0) hash ^= SignedPreKeySignature.GetHashCode();
      hash ^= oneTimePreKeys_.GetHashCode();
      if (IdentityX25519PublicKey.Length != 0) hash ^= IdentityX25519PublicKey.GetHashCode();
      if (EphemeralX25519PublicKey.Length != 0) hash ^= EphemeralX25519PublicKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (IdentityPublicKey.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(IdentityPublicKey);
      }
      if (SignedPreKeyId != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(SignedPreKeyId);
      }
      if (SignedPreKeyPublicKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(SignedPreKeyPublicKey);
      }
      if (SignedPreKeySignature.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(SignedPreKeySignature);
      }
      oneTimePreKeys_.WriteTo(output, _repeated_oneTimePreKeys_codec);
      if (IdentityX25519PublicKey.Length != 0) {
        output.WriteRawTag(50);
        output.WriteBytes(IdentityX25519PublicKey);
      }
      if (EphemeralX25519PublicKey.Length != 0) {
        output.WriteRawTag(58);
        output.WriteBytes(EphemeralX25519PublicKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (IdentityPublicKey.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(IdentityPublicKey);
      }
      if (SignedPreKeyId != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(SignedPreKeyId);
      }
      if (SignedPreKeyPublicKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(SignedPreKeyPublicKey);
      }
      if (SignedPreKeySignature.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(SignedPreKeySignature);
      }
      oneTimePreKeys_.WriteTo(ref output, _repeated_oneTimePreKeys_codec);
      if (IdentityX25519PublicKey.Length != 0) {
        output.WriteRawTag(50);
        output.WriteBytes(IdentityX25519PublicKey);
      }
      if (EphemeralX25519PublicKey.Length != 0) {
        output.WriteRawTag(58);
        output.WriteBytes(EphemeralX25519PublicKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (IdentityPublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(IdentityPublicKey);
      }
      if (SignedPreKeyId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SignedPreKeyId);
      }
      if (SignedPreKeyPublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SignedPreKeyPublicKey);
      }
      if (SignedPreKeySignature.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SignedPreKeySignature);
      }
      size += oneTimePreKeys_.CalculateSize(_repeated_oneTimePreKeys_codec);
      if (IdentityX25519PublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(IdentityX25519PublicKey);
      }
      if (EphemeralX25519PublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EphemeralX25519PublicKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PublicKeyBundle other) {
      if (other == null) {
        return;
      }
      if (other.IdentityPublicKey.Length != 0) {
        IdentityPublicKey = other.IdentityPublicKey;
      }
      if (other.SignedPreKeyId != 0) {
        SignedPreKeyId = other.SignedPreKeyId;
      }
      if (other.SignedPreKeyPublicKey.Length != 0) {
        SignedPreKeyPublicKey = other.SignedPreKeyPublicKey;
      }
      if (other.SignedPreKeySignature.Length != 0) {
        SignedPreKeySignature = other.SignedPreKeySignature;
      }
      oneTimePreKeys_.Add(other.oneTimePreKeys_);
      if (other.IdentityX25519PublicKey.Length != 0) {
        IdentityX25519PublicKey = other.IdentityX25519PublicKey;
      }
      if (other.EphemeralX25519PublicKey.Length != 0) {
        EphemeralX25519PublicKey = other.EphemeralX25519PublicKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            IdentityPublicKey = input.ReadBytes();
            break;
          }
          case 16: {
            SignedPreKeyId = input.ReadUInt32();
            break;
          }
          case 26: {
            SignedPreKeyPublicKey = input.ReadBytes();
            break;
          }
          case 34: {
            SignedPreKeySignature = input.ReadBytes();
            break;
          }
          case 42: {
            oneTimePreKeys_.AddEntriesFrom(input, _repeated_oneTimePreKeys_codec);
            break;
          }
          case 50: {
            IdentityX25519PublicKey = input.ReadBytes();
            break;
          }
          case 58: {
            EphemeralX25519PublicKey = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            IdentityPublicKey = input.ReadBytes();
            break;
          }
          case 16: {
            SignedPreKeyId = input.ReadUInt32();
            break;
          }
          case 26: {
            SignedPreKeyPublicKey = input.ReadBytes();
            break;
          }
          case 34: {
            SignedPreKeySignature = input.ReadBytes();
            break;
          }
          case 42: {
            oneTimePreKeys_.AddEntriesFrom(ref input, _repeated_oneTimePreKeys_codec);
            break;
          }
          case 50: {
            IdentityX25519PublicKey = input.ReadBytes();
            break;
          }
          case 58: {
            EphemeralX25519PublicKey = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the PublicKeyBundle message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class OneTimePreKey : pb::IMessage<OneTimePreKey>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<OneTimePreKey> _parser = new pb::MessageParser<OneTimePreKey>(() => new OneTimePreKey());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<OneTimePreKey> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Ecliptix.Protobuf.Protocol.PublicKeyBundle.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OneTimePreKey() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OneTimePreKey(OneTimePreKey other) : this() {
          preKeyId_ = other.preKeyId_;
          publicKey_ = other.publicKey_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OneTimePreKey Clone() {
          return new OneTimePreKey(this);
        }

        /// <summary>Field number for the "pre_key_id" field.</summary>
        public const int PreKeyIdFieldNumber = 1;
        private uint preKeyId_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint PreKeyId {
          get { return preKeyId_; }
          set {
            preKeyId_ = value;
          }
        }

        /// <summary>Field number for the "public_key" field.</summary>
        public const int PublicKeyFieldNumber = 2;
        private pb::ByteString publicKey_ = pb::ByteString.Empty;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString PublicKey {
          get { return publicKey_; }
          set {
            publicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as OneTimePreKey);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(OneTimePreKey other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (PreKeyId != other.PreKeyId) return false;
          if (PublicKey != other.PublicKey) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (PreKeyId != 0) hash ^= PreKeyId.GetHashCode();
          if (PublicKey.Length != 0) hash ^= PublicKey.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (PreKeyId != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(PreKeyId);
          }
          if (PublicKey.Length != 0) {
            output.WriteRawTag(18);
            output.WriteBytes(PublicKey);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (PreKeyId != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(PreKeyId);
          }
          if (PublicKey.Length != 0) {
            output.WriteRawTag(18);
            output.WriteBytes(PublicKey);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (PreKeyId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PreKeyId);
          }
          if (PublicKey.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(PublicKey);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(OneTimePreKey other) {
          if (other == null) {
            return;
          }
          if (other.PreKeyId != 0) {
            PreKeyId = other.PreKeyId;
          }
          if (other.PublicKey.Length != 0) {
            PublicKey = other.PublicKey;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                PreKeyId = input.ReadUInt32();
                break;
              }
              case 18: {
                PublicKey = input.ReadBytes();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                PreKeyId = input.ReadUInt32();
                break;
              }
              case 18: {
                PublicKey = input.ReadBytes();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code

 [2025-11-04T12:57:50.553] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (2.1502ms) ************
{
  "Request_seq": 9325,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549853,
  "Type": "response"
}
 [2025-11-04T12:57:50.553] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9326,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/KeyExchange.cs"
  }
}
 [2025-11-04T12:57:50.714] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (161.3940ms) ************
{
  "Request_seq": 9326,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549857,
  "Type": "response"
}
 [2025-11-04T12:57:50.715] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9327,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Views/Core/MainWindow.cs",
    "Buffer": "using System;\nusing System.Reactive.Disposables;\nusing System.Reactive.Linq;\nusing Avalonia;\nusing Avalonia.Controls;\nusing Avalonia.Markup.Xaml;\nusing Avalonia.ReactiveUI;\nusing Ecliptix.Core.Controls.LanguageSelector;\nusing Ecliptix.Core.Controls.Modals.BottomSheetModal;\nusing Ecliptix.Core.Services.Core;\nusing Ecliptix.Core.ViewModels.Core;\nusing ReactiveUI;\n\nnamespace Ecliptix.Core.Views.Core;\n\npublic partial class MainWindow : ReactiveWindow<MainWindowViewModel>\n{\n    private bool _languageSelectorLoaded;\n    private readonly Border? _languageSelectorContainer;\n\n    public MainWindow()\n    {\n        AvaloniaXamlLoader.Load(this);\n        IconService.SetIconForWindow(this);\n\n        _languageSelectorContainer = this.FindControl<Border>(\"LanguageSelectorContainer\");\n\n        SetupLazyLanguageSelector();\n\n#if DEBUG\n        this.AttachDevTools();\n#endif\n    }\n\n    private void SetupLazyLanguageSelector()\n    {\n        this.WhenActivated(disposables =>\n        {\n            this.WhenAnyValue(x => x.DataContext)\n                .Where(dc => dc != null)\n                .Select(dc => dc!)\n                .OfType<MainWindowViewModel>()\n                .Take(1)\n                .Where(_ => !_languageSelectorLoaded)\n                .ObserveOn(RxApp.MainThreadScheduler)\n                .Subscribe(LoadLanguageSelector)\n                .DisposeWith(disposables);\n        });\n    }\n\n    private void LoadLanguageSelector(MainWindowViewModel viewModel)\n    {\n        if (_languageSelectorLoaded || _languageSelectorContainer == null)\n        {\n            return;\n        }\n\n        LanguageSelectorView languageSelector = new()\n        {\n            DataContext = viewModel.LanguageSelector\n        };\n\n        _languageSelectorContainer.Child = languageSelector;\n        _languageSelectorLoaded = true;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:50.715] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Views/Core/MainWindow.cs with new text:
using System;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using Avalonia.ReactiveUI;
using Ecliptix.Core.Controls.LanguageSelector;
using Ecliptix.Core.Controls.Modals.BottomSheetModal;
using Ecliptix.Core.Services.Core;
using Ecliptix.Core.ViewModels.Core;
using ReactiveUI;

namespace Ecliptix.Core.Views.Core;

public partial class MainWindow : ReactiveWindow<MainWindowViewModel>
{
    private bool _languageSelectorLoaded;
    private readonly Border? _languageSelectorContainer;

    public MainWindow()
    {
        AvaloniaXamlLoader.Load(this);
        IconService.SetIconForWindow(this);

        _languageSelectorContainer = this.FindControl<Border>("LanguageSelectorContainer");

        SetupLazyLanguageSelector();

#if DEBUG
        this.AttachDevTools();
#endif
    }

    private void SetupLazyLanguageSelector()
    {
        this.WhenActivated(disposables =>
        {
            this.WhenAnyValue(x => x.DataContext)
                .Where(dc => dc != null)
                .Select(dc => dc!)
                .OfType<MainWindowViewModel>()
                .Take(1)
                .Where(_ => !_languageSelectorLoaded)
                .ObserveOn(RxApp.MainThreadScheduler)
                .Subscribe(LoadLanguageSelector)
                .DisposeWith(disposables);
        });
    }

    private void LoadLanguageSelector(MainWindowViewModel viewModel)
    {
        if (_languageSelectorLoaded || _languageSelectorContainer == null)
        {
            return;
        }

        LanguageSelectorView languageSelector = new()
        {
            DataContext = viewModel.LanguageSelector
        };

        _languageSelectorContainer.Child = languageSelector;
        _languageSelectorLoaded = true;
    }
}

 [2025-11-04T12:57:50.715] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3409ms) ************
{
  "Request_seq": 9327,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549862,
  "Type": "response"
}
 [2025-11-04T12:57:50.716] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9328,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Views/Core/MainWindow.cs"
  }
}
 [2025-11-04T12:57:50.846] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (130.6907ms) ************
{
  "Request_seq": 9328,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549866,
  "Type": "response"
}
 [2025-11-04T12:57:50.847] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9329,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Common/InternalServiceApiFailure.cs",
    "Buffer": "using System;\n\nnamespace Ecliptix.Core.Services.Common;\n\npublic class InternalServiceApiFailure\n{\n    private InternalServiceApiFailure(InternalServiceApiFailureType type, string message,\n        Exception? innerException = null)\n    {\n        Type = type;\n        Message = message;\n        InnerException = innerException;\n    }\n\n    public InternalServiceApiFailureType Type { get; }\n    public string Message { get; }\n    public Exception? InnerException { get; }\n\n    public static InternalServiceApiFailure SecureStoreAccessDenied(string details, Exception? inner = null)\n    {\n        return new InternalServiceApiFailure(InternalServiceApiFailureType.SecureStoreAccessDenied, details, inner);\n    }\n\n    public static InternalServiceApiFailure SecureStoreKeyNotFound(string details, Exception? inner = null)\n    {\n        return new InternalServiceApiFailure(InternalServiceApiFailureType.SecureStoreKeyNotFound, details, inner);\n    }\n\n    public static InternalServiceApiFailure ApiRequestFailed(string details, Exception? inner = null)\n    {\n        return new InternalServiceApiFailure(InternalServiceApiFailureType.ApiRequestFailed, details, inner);\n    }\n}\n"
  }
}
 [2025-11-04T12:57:50.847] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Common/InternalServiceApiFailure.cs with new text:
using System;

namespace Ecliptix.Core.Services.Common;

public class InternalServiceApiFailure
{
    private InternalServiceApiFailure(InternalServiceApiFailureType type, string message,
        Exception? innerException = null)
    {
        Type = type;
        Message = message;
        InnerException = innerException;
    }

    public InternalServiceApiFailureType Type { get; }
    public string Message { get; }
    public Exception? InnerException { get; }

    public static InternalServiceApiFailure SecureStoreAccessDenied(string details, Exception? inner = null)
    {
        return new InternalServiceApiFailure(InternalServiceApiFailureType.SecureStoreAccessDenied, details, inner);
    }

    public static InternalServiceApiFailure SecureStoreKeyNotFound(string details, Exception? inner = null)
    {
        return new InternalServiceApiFailure(InternalServiceApiFailureType.SecureStoreKeyNotFound, details, inner);
    }

    public static InternalServiceApiFailure ApiRequestFailed(string details, Exception? inner = null)
    {
        return new InternalServiceApiFailure(InternalServiceApiFailureType.ApiRequestFailed, details, inner);
    }
}

 [2025-11-04T12:57:50.847] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3405ms) ************
{
  "Request_seq": 9329,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549870,
  "Type": "response"
}
 [2025-11-04T12:57:50.847] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9330,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Common/InternalServiceApiFailure.cs"
  }
}
 [2025-11-04T12:57:50.948] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (100.2737ms) ************
{
  "Request_seq": 9330,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549874,
  "Type": "response"
}
 [2025-11-04T12:57:50.949] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9331,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/IGrpcDeadlineProvider.cs",
    "Buffer": "using System;\nusing Ecliptix.Core.Services.Network.Rpc;\n\nnamespace Ecliptix.Core.Services.Network;\n\npublic interface IGrpcDeadlineProvider\n{\n    DateTime GetDeadlineUtc(RpcServiceType serviceType, RpcRequestContext? requestContext);\n}\n"
  }
}
 [2025-11-04T12:57:50.949] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/IGrpcDeadlineProvider.cs with new text:
using System;
using Ecliptix.Core.Services.Network.Rpc;

namespace Ecliptix.Core.Services.Network;

public interface IGrpcDeadlineProvider
{
    DateTime GetDeadlineUtc(RpcServiceType serviceType, RpcRequestContext? requestContext);
}

 [2025-11-04T12:57:50.949] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3001ms) ************
{
  "Request_seq": 9331,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549878,
  "Type": "response"
}
 [2025-11-04T12:57:50.949] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9332,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/IGrpcDeadlineProvider.cs"
  }
}
 [2025-11-04T12:57:51.039] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (89.9881ms) ************
{
  "Request_seq": 9332,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549882,
  "Type": "response"
}
 [2025-11-04T12:57:51.04] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9333,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Core/IApplicationRouter.cs",
    "Buffer": "using System.Threading.Tasks;\nusing Avalonia.Controls;\n\nnamespace Ecliptix.Core.Services.Abstractions.Core;\n\npublic interface IApplicationRouter\n{\n    Task NavigateToAuthenticationAsync();\n\n    Task NavigateToMainAsync();\n\n    Task TransitionFromSplashAsync(Window splashWindow, bool isAuthenticated);\n}\n"
  }
}
 [2025-11-04T12:57:51.04] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Core/IApplicationRouter.cs with new text:
using System.Threading.Tasks;
using Avalonia.Controls;

namespace Ecliptix.Core.Services.Abstractions.Core;

public interface IApplicationRouter
{
    Task NavigateToAuthenticationAsync();

    Task NavigateToMainAsync();

    Task TransitionFromSplashAsync(Window splashWindow, bool isAuthenticated);
}

 [2025-11-04T12:57:51.041] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3111ms) ************
{
  "Request_seq": 9333,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549886,
  "Type": "response"
}
 [2025-11-04T12:57:51.041] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9334,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Core/IApplicationRouter.cs"
  }
}
 [2025-11-04T12:57:51.129] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (88.5062ms) ************
{
  "Request_seq": 9334,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549890,
  "Type": "response"
}
 [2025-11-04T12:57:51.13] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9335,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Authentication/SecureTextBuffer.cs",
    "Buffer": "using System;\nusing System.Globalization;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Ecliptix.Protocol.System.Sodium;\nusing Ecliptix.Protocol.System.Utilities;\nusing Ecliptix.Utilities;\nusing Ecliptix.Utilities.Failures.Sodium;\n\nnamespace Ecliptix.Core.Services.Authentication;\n\npublic sealed class SecureTextBuffer : IDisposable\n{\n    private SodiumSecureMemoryHandle _secureHandle = SodiumSecureMemoryHandle.Allocate(0).Unwrap();\n    private bool _isDisposed;\n\n    public int Length { get; private set; }\n\n    public void Insert(int index, string text)\n    {\n        if (string.IsNullOrEmpty(text))\n        {\n            return;\n        }\n\n        ModifyState(index, 0, text);\n    }\n\n    public void Remove(int index, int count)\n    {\n        if (count <= 0)\n        {\n            return;\n        }\n\n        ModifyState(index, count, string.Empty);\n    }\n\n    public void WithSecureBytes(Action<ReadOnlySpan<byte>> action)\n    {\n        if (_isDisposed)\n        {\n            throw new ObjectDisposedException(nameof(SecureTextBuffer));\n        }\n\n        if (_secureHandle.IsInvalid || _secureHandle.Length == 0)\n        {\n            action(ReadOnlySpan<byte>.Empty);\n            return;\n        }\n\n        using SecurePooledArray<byte> rentedBytes = SecureArrayPool.Rent<byte>(_secureHandle.Length);\n        Span<byte> span = rentedBytes.AsSpan();\n\n        _secureHandle.Read(span).Unwrap();\n\n        action(span);\n    }\n\n    private void ModifyState(int charIndex, int removeCharCount, string insertChars)\n    {\n        if (_isDisposed)\n        {\n            throw new ObjectDisposedException(nameof(SecureTextBuffer));\n        }\n\n        SodiumSecureMemoryHandle? newHandle = null;\n        bool success = false;\n        byte[]? insertBytes = null;\n\n        try\n        {\n            insertBytes = PrepareInsertBytes(insertChars);\n            if (insertBytes == null)\n            {\n                return;\n            }\n\n            int oldByteLength = _secureHandle.Length;\n            int currentTextElementCount = GetCurrentTextElementCount(oldByteLength);\n\n            charIndex = Math.Clamp(charIndex, 0, currentTextElementCount);\n            removeCharCount = Math.Clamp(removeCharCount, 0, currentTextElementCount - charIndex);\n\n            ByteIndexRange byteRange = CalculateByteIndices(oldByteLength, charIndex, removeCharCount);\n            int removedByteCount = byteRange.End - byteRange.Start;\n            int newByteLength = oldByteLength - removedByteCount + insertBytes.Length;\n\n            newHandle = AssembleNewBuffer(oldByteLength, byteRange.Start, byteRange.End, insertBytes, newByteLength);\n\n            UpdateHandleAndLength(newHandle, currentTextElementCount, removeCharCount, insertBytes);\n            success = true;\n        }\n        finally\n        {\n            CleanupInsertBytes(insertBytes);\n            if (!success)\n            {\n                newHandle?.Dispose();\n            }\n        }\n    }\n\n    private static byte[]? PrepareInsertBytes(string insertChars)\n    {\n        if (string.IsNullOrEmpty(insertChars))\n        {\n            return [];\n        }\n\n        Result<SecureStringHandler, SodiumFailure> handlerResult = SecureStringHandler.FromString(insertChars);\n        if (handlerResult.IsErr)\n        {\n            return null;\n        }\n\n        using SecureStringHandler insertHandler = handlerResult.Unwrap();\n        using SecurePooledArray<byte> tempBytes = SecureArrayPool.Rent<byte>(insertHandler.ByteLength);\n\n        Result<Unit, SodiumFailure> readResult = insertHandler.UseBytes(bytes =>\n        {\n            bytes.CopyTo(tempBytes.AsSpan());\n            return Unit.Value;\n        });\n\n        if (readResult.IsErr)\n        {\n            return null;\n        }\n\n        byte[] insertBytes = new byte[insertHandler.ByteLength];\n        tempBytes.AsSpan()[..insertHandler.ByteLength].CopyTo(insertBytes);\n        return insertBytes;\n    }\n\n    private int GetCurrentTextElementCount(int byteLength)\n    {\n        if (byteLength == 0)\n        {\n            return 0;\n        }\n\n        using SecurePooledArray<byte> oldBytes = SecureArrayPool.Rent<byte>(byteLength);\n        _secureHandle.Read(oldBytes.AsSpan()).Unwrap();\n        string currentText = Encoding.UTF8.GetString(oldBytes.AsSpan());\n        return GetTextElementCount(currentText);\n    }\n\n    private readonly record struct ByteIndexRange(int Start, int End);\n\n    private ByteIndexRange CalculateByteIndices(int oldByteLength, int charIndex, int removeCharCount)\n    {\n        if (oldByteLength == 0 || (charIndex == 0 && removeCharCount == 0))\n        {\n            return new ByteIndexRange(0, oldByteLength);\n        }\n\n        using SecurePooledArray<byte> oldBytes = SecureArrayPool.Rent<byte>(oldByteLength);\n        _secureHandle.Read(oldBytes.AsSpan()).Unwrap();\n        string currentText = Encoding.UTF8.GetString(oldBytes.AsSpan());\n\n        int startByteIndex = GetByteIndexFromTextElementIndex(currentText, charIndex);\n        int endByteIndex = GetByteIndexFromTextElementIndex(currentText, charIndex + removeCharCount);\n\n        return new ByteIndexRange(startByteIndex, endByteIndex);\n    }\n\n    private SodiumSecureMemoryHandle AssembleNewBuffer(int oldByteLength, int startByteIndex, int endByteIndex, byte[] insertBytes, int newByteLength)\n    {\n        if (newByteLength == 0)\n        {\n            return SodiumSecureMemoryHandle.Allocate(0).Unwrap();\n        }\n\n        using SecurePooledArray<byte> newBytes = SecureArrayPool.Rent<byte>(newByteLength);\n        Span<byte> newSpan = newBytes.AsSpan();\n\n        if (oldByteLength > 0)\n        {\n            CopyBufferSegments(oldByteLength, startByteIndex, endByteIndex, insertBytes, newSpan);\n        }\n        else\n        {\n            insertBytes.CopyTo(newSpan);\n        }\n\n        SodiumSecureMemoryHandle newHandle = SodiumSecureMemoryHandle.Allocate(newByteLength).Unwrap();\n        newHandle.Write(newSpan).Unwrap();\n        return newHandle;\n    }\n\n    private void CopyBufferSegments(int oldByteLength, int startByteIndex, int endByteIndex, byte[] insertBytes, Span<byte> newSpan)\n    {\n        using SecurePooledArray<byte> oldBytesForCopy = SecureArrayPool.Rent<byte>(oldByteLength);\n        _secureHandle.Read(oldBytesForCopy.AsSpan()).Unwrap();\n        Span<byte> oldSpan = oldBytesForCopy.AsSpan();\n\n        oldSpan[..startByteIndex].CopyTo(newSpan);\n        insertBytes.CopyTo(newSpan[startByteIndex..]);\n        oldSpan[endByteIndex..].CopyTo(newSpan[(startByteIndex + insertBytes.Length)..]);\n    }\n\n    private void UpdateHandleAndLength(SodiumSecureMemoryHandle newHandle, int currentTextElementCount, int removeCharCount, byte[] insertBytes)\n    {\n        _secureHandle.Dispose();\n        _secureHandle = newHandle;\n        string insertText = insertBytes.Length > 0 ? Encoding.UTF8.GetString(insertBytes) : string.Empty;\n        Length = currentTextElementCount - removeCharCount + GetTextElementCount(insertText);\n    }\n\n    private static void CleanupInsertBytes(byte[]? insertBytes)\n    {\n        if (insertBytes != null && insertBytes.Length > 0)\n        {\n            CryptographicOperations.ZeroMemory(insertBytes);\n        }\n    }\n\n    private static int GetByteIndexFromTextElementIndex(string text, int textElementIndex)\n    {\n        if (textElementIndex == 0 || string.IsNullOrEmpty(text))\n        {\n            return 0;\n        }\n\n        try\n        {\n            StringInfo stringInfo = new(text);\n            int textElementCount = stringInfo.LengthInTextElements;\n\n            if (textElementIndex >= textElementCount)\n            {\n                return Encoding.UTF8.GetByteCount(text);\n            }\n\n            string substring = stringInfo.SubstringByTextElements(0, textElementIndex);\n            return Encoding.UTF8.GetByteCount(substring);\n        }\n        catch (Exception ex)\n        {\n            Serilog.Log.Warning(ex, \"[SECURE-TEXT-BUFFER] Failed to calculate byte index for text element. TextElementIndex: {Index}, Fallback used\",\n                textElementIndex);\n            return Math.Min(textElementIndex, Encoding.UTF8.GetByteCount(text));\n        }\n    }\n\n    private static int GetTextElementCount(string text)\n    {\n        if (string.IsNullOrEmpty(text))\n        {\n            return 0;\n        }\n\n        try\n        {\n            StringInfo stringInfo = new(text);\n            return stringInfo.LengthInTextElements;\n        }\n        catch (Exception ex)\n        {\n            Serilog.Log.Warning(ex, \"[SECURE-TEXT-BUFFER] Failed to get text element count. TextLength: {Length}, Fallback used\",\n                text.Length);\n            return text.Length;\n        }\n    }\n\n    public void Dispose()\n    {\n        if (_isDisposed)\n        {\n            return;\n        }\n\n        _secureHandle?.Dispose();\n        _isDisposed = true;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:51.13] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Authentication/SecureTextBuffer.cs with new text:
using System;
using System.Globalization;
using System.Security.Cryptography;
using System.Text;
using Ecliptix.Protocol.System.Sodium;
using Ecliptix.Protocol.System.Utilities;
using Ecliptix.Utilities;
using Ecliptix.Utilities.Failures.Sodium;

namespace Ecliptix.Core.Services.Authentication;

public sealed class SecureTextBuffer : IDisposable
{
    private SodiumSecureMemoryHandle _secureHandle = SodiumSecureMemoryHandle.Allocate(0).Unwrap();
    private bool _isDisposed;

    public int Length { get; private set; }

    public void Insert(int index, string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return;
        }

        ModifyState(index, 0, text);
    }

    public void Remove(int index, int count)
    {
        if (count <= 0)
        {
            return;
        }

        ModifyState(index, count, string.Empty);
    }

    public void WithSecureBytes(Action<ReadOnlySpan<byte>> action)
    {
        if (_isDisposed)
        {
            throw new ObjectDisposedException(nameof(SecureTextBuffer));
        }

        if (_secureHandle.IsInvalid || _secureHandle.Length == 0)
        {
            action(ReadOnlySpan<byte>.Empty);
            return;
        }

        using SecurePooledArray<byte> rentedBytes = SecureArrayPool.Rent<byte>(_secureHandle.Length);
        Span<byte> span = rentedBytes.AsSpan();

        _secureHandle.Read(span).Unwrap();

        action(span);
    }

    private void ModifyState(int charIndex, int removeCharCount, string insertChars)
    {
        if (_isDisposed)
        {
            throw new ObjectDisposedException(nameof(SecureTextBuffer));
        }

        SodiumSecureMemoryHandle? newHandle = null;
        bool success = false;
        byte[]? insertBytes = null;

        try
        {
            insertBytes = PrepareInsertBytes(insertChars);
            if (insertBytes == null)
            {
                return;
            }

            int oldByteLength = _secureHandle.Length;
            int currentTextElementCount = GetCurrentTextElementCount(oldByteLength);

            charIndex = Math.Clamp(charIndex, 0, currentTextElementCount);
            removeCharCount = Math.Clamp(removeCharCount, 0, currentTextElementCount - charIndex);

            ByteIndexRange byteRange = CalculateByteIndices(oldByteLength, charIndex, removeCharCount);
            int removedByteCount = byteRange.End - byteRange.Start;
            int newByteLength = oldByteLength - removedByteCount + insertBytes.Length;

            newHandle = AssembleNewBuffer(oldByteLength, byteRange.Start, byteRange.End, insertBytes, newByteLength);

            UpdateHandleAndLength(newHandle, currentTextElementCount, removeCharCount, insertBytes);
            success = true;
        }
        finally
        {
            CleanupInsertBytes(insertBytes);
            if (!success)
            {
                newHandle?.Dispose();
            }
        }
    }

    private static byte[]? PrepareInsertBytes(string insertChars)
    {
        if (string.IsNullOrEmpty(insertChars))
        {
            return [];
        }

        Result<SecureStringHandler, SodiumFailure> handlerResult = SecureStringHandler.FromString(insertChars);
        if (handlerResult.IsErr)
        {
            return null;
        }

        using SecureStringHandler insertHandler = handlerResult.Unwrap();
        using SecurePooledArray<byte> tempBytes = SecureArrayPool.Rent<byte>(insertHandler.ByteLength);

        Result<Unit, SodiumFailure> readResult = insertHandler.UseBytes(bytes =>
        {
            bytes.CopyTo(tempBytes.AsSpan());
            return Unit.Value;
        });

        if (readResult.IsErr)
        {
            return null;
        }

        byte[] insertBytes = new byte[insertHandler.ByteLength];
        tempBytes.AsSpan()[..insertHandler.ByteLength].CopyTo(insertBytes);
        return insertBytes;
    }

    private int GetCurrentTextElementCount(int byteLength)
    {
        if (byteLength == 0)
        {
            return 0;
        }

        using SecurePooledArray<byte> oldBytes = SecureArrayPool.Rent<byte>(byteLength);
        _secureHandle.Read(oldBytes.AsSpan()).Unwrap();
        string currentText = Encoding.UTF8.GetString(oldBytes.AsSpan());
        return GetTextElementCount(currentText);
    }

    private readonly record struct ByteIndexRange(int Start, int End);

    private ByteIndexRange CalculateByteIndices(int oldByteLength, int charIndex, int removeCharCount)
    {
        if (oldByteLength == 0 || (charIndex == 0 && removeCharCount == 0))
        {
            return new ByteIndexRange(0, oldByteLength);
        }

        using SecurePooledArray<byte> oldBytes = SecureArrayPool.Rent<byte>(oldByteLength);
        _secureHandle.Read(oldBytes.AsSpan()).Unwrap();
        string currentText = Encoding.UTF8.GetString(oldBytes.AsSpan());

        int startByteIndex = GetByteIndexFromTextElementIndex(currentText, charIndex);
        int endByteIndex = GetByteIndexFromTextElementIndex(currentText, charIndex + removeCharCount);

        return new ByteIndexRange(startByteIndex, endByteIndex);
    }

    private SodiumSecureMemoryHandle AssembleNewBuffer(int oldByteLength, int startByteIndex, int endByteIndex, byte[] insertBytes, int newByteLength)
    {
        if (newByteLength == 0)
        {
            return SodiumSecureMemoryHandle.Allocate(0).Unwrap();
        }

        using SecurePooledArray<byte> newBytes = SecureArrayPool.Rent<byte>(newByteLength);
        Span<byte> newSpan = newBytes.AsSpan();

        if (oldByteLength > 0)
        {
            CopyBufferSegments(oldByteLength, startByteIndex, endByteIndex, insertBytes, newSpan);
        }
        else
        {
            insertBytes.CopyTo(newSpan);
        }

        SodiumSecureMemoryHandle newHandle = SodiumSecureMemoryHandle.Allocate(newByteLength).Unwrap();
        newHandle.Write(newSpan).Unwrap();
        return newHandle;
    }

    private void CopyBufferSegments(int oldByteLength, int startByteIndex, int endByteIndex, byte[] insertBytes, Span<byte> newSpan)
    {
        using SecurePooledArray<byte> oldBytesForCopy = SecureArrayPool.Rent<byte>(oldByteLength);
        _secureHandle.Read(oldBytesForCopy.AsSpan()).Unwrap();
        Span<byte> oldSpan = oldBytesForCopy.AsSpan();

        oldSpan[..startByteIndex].CopyTo(newSpan);
        insertBytes.CopyTo(newSpan[startByteIndex..]);
        oldSpan[endByteIndex..].CopyTo(newSpan[(startByteIndex + insertBytes.Length)..]);
    }

    private void UpdateHandleAndLength(SodiumSecureMemoryHandle newHandle, int currentTextElementCount, int removeCharCount, byte[] insertBytes)
    {
        _secureHandle.Dispose();
        _secureHandle = newHandle;
        string insertText = insertBytes.Length > 0 ? Encoding.UTF8.GetString(insertBytes) : string.Empty;
        Length = currentTextElementCount - removeCharCount + GetTextElementCount(insertText);
    }

    private static void CleanupInsertBytes(byte[]? insertBytes)
    {
        if (insertBytes != null && insertBytes.Length > 0)
        {
            CryptographicOperations.ZeroMemory(insertBytes);
        }
    }

    private static int GetByteIndexFromTextElementIndex(string text, int textElementIndex)
    {
        if (textElementIndex == 0 || string.IsNullOrEmpty(text))
        {
            return 0;
        }

        try
        {
            StringInfo stringInfo = new(text);
            int textElementCount = stringInfo.LengthInTextElements;

            if (textElementIndex >= textElementCount)
            {
                return Encoding.UTF8.GetByteCount(text);
            }

            string substring = stringInfo.SubstringByTextElements(0, textElementIndex);
            return Encoding.UTF8.GetByteCount(substring);
        }
        catch (Exception ex)
        {
            Serilog.Log.Warning(ex, "[SECURE-TEXT-BUFFER] Failed to calculate byte index for text element. TextElementIndex: {Index}, Fallback used",
                textElementIndex);
            return Math.Min(textElementIndex, Encoding.UTF8.GetByteCount(text));
        }
    }

    private static int GetTextElementCount(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return 0;
        }

        try
        {
            StringInfo stringInfo = new(text);
            return stringInfo.LengthInTextElements;
        }
        catch (Exception ex)
        {
            Serilog.Log.Warning(ex, "[SECURE-TEXT-BUFFER] Failed to get text element count. TextLength: {Length}, Fallback used",
                text.Length);
            return text.Length;
        }
    }

    public void Dispose()
    {
        if (_isDisposed)
        {
            return;
        }

        _secureHandle?.Dispose();
        _isDisposed = true;
    }
}

 [2025-11-04T12:57:51.13] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.4263ms) ************
{
  "Request_seq": 9335,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549894,
  "Type": "response"
}
 [2025-11-04T12:57:51.13] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9336,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Authentication/SecureTextBuffer.cs"
  }
}
 [2025-11-04T12:57:51.285] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (154.5370ms) ************
{
  "Request_seq": 9336,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549898,
  "Type": "response"
}
 [2025-11-04T12:57:51.285] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9337,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/UtilityConstants.cs",
    "Buffer": "namespace Ecliptix.Utilities;\n\ninternal static class UtilityConstants\n{\n    internal static class Hash\n    {\n        public const int InitialHashSeed = 17;\n        public const int HashMultiplier = 31;\n    }\n\n    internal static class ErrorMessages\n    {\n        public const string CannotUnwrapErr = \"Cannot unwrap an Err result\";\n        public const string CannotUnwrapOk = \"Cannot unwrap an Ok result\";\n        public const string ErrorMapperReturnedNull = \"Error mapper returned null, violating TE : notnull\";\n        public const string InsufficientEntropy = \"Random number generator appears to have insufficient entropy\";\n        public const string InvalidAppInstanceIdFormat = \"Invalid AppInstanceId format: \";\n        public const string InvalidAppDeviceIdFormat = \"Invalid AppDeviceId format: \";\n    }\n\n    internal static class Cryptography\n    {\n        public const int MaxEntropyCheckAttempts = 10;\n        public const int GuidSizeBytes = 16;\n        public const int UInt32SizeBytes = 4;\n        public const int StackAllocThreshold = 512;\n        public const int Sha256OutputSize = 32;\n        public const byte MaxByteValue = 255;\n        public const byte MinByteValue = 0;\n        public const int HashBytesToRead = 4;\n    }\n\n    internal static class UnitType\n    {\n        public const int HashCode = 0;\n        public const string StringRepresentation = \"()\";\n    }\n\n    internal static class ResultType\n    {\n        public const string OkString = \"Ok\";\n        public const string ErrString = \"Err\";\n    }\n\n    internal static class ProtocolNames\n    {\n        public const string X3dhInfo = \"Ecliptix_X3DH\";\n    }\n\n    internal static class ProtocolBytes\n    {\n        public const byte MsgInfoValue = 0x01;\n        public const byte ChainInfoValue = 0x02;\n    }\n\n    internal static class NetworkConstants\n    {\n        public const uint MinRequestId = 10;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:51.285] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/UtilityConstants.cs with new text:
namespace Ecliptix.Utilities;

internal static class UtilityConstants
{
    internal static class Hash
    {
        public const int InitialHashSeed = 17;
        public const int HashMultiplier = 31;
    }

    internal static class ErrorMessages
    {
        public const string CannotUnwrapErr = "Cannot unwrap an Err result";
        public const string CannotUnwrapOk = "Cannot unwrap an Ok result";
        public const string ErrorMapperReturnedNull = "Error mapper returned null, violating TE : notnull";
        public const string InsufficientEntropy = "Random number generator appears to have insufficient entropy";
        public const string InvalidAppInstanceIdFormat = "Invalid AppInstanceId format: ";
        public const string InvalidAppDeviceIdFormat = "Invalid AppDeviceId format: ";
    }

    internal static class Cryptography
    {
        public const int MaxEntropyCheckAttempts = 10;
        public const int GuidSizeBytes = 16;
        public const int UInt32SizeBytes = 4;
        public const int StackAllocThreshold = 512;
        public const int Sha256OutputSize = 32;
        public const byte MaxByteValue = 255;
        public const byte MinByteValue = 0;
        public const int HashBytesToRead = 4;
    }

    internal static class UnitType
    {
        public const int HashCode = 0;
        public const string StringRepresentation = "()";
    }

    internal static class ResultType
    {
        public const string OkString = "Ok";
        public const string ErrString = "Err";
    }

    internal static class ProtocolNames
    {
        public const string X3dhInfo = "Ecliptix_X3DH";
    }

    internal static class ProtocolBytes
    {
        public const byte MsgInfoValue = 0x01;
        public const byte ChainInfoValue = 0x02;
    }

    internal static class NetworkConstants
    {
        public const uint MinRequestId = 10;
    }
}

 [2025-11-04T12:57:51.285] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2251ms) ************
{
  "Request_seq": 9337,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549902,
  "Type": "response"
}
 [2025-11-04T12:57:51.286] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9338,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/UtilityConstants.cs"
  }
}
 [2025-11-04T12:57:51.343] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (57.3743ms) ************
{
  "Request_seq": 9338,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549906,
  "Type": "response"
}
 [2025-11-04T12:57:51.344] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9339,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/BottomSheetModal/BottomSheetViewModel.cs",
    "Buffer": "using System;\nusing System.Reactive.Disposables;\nusing System.Reactive.Linq;\nusing System.Threading.Tasks;\n\nusing Avalonia.Controls;\nusing Avalonia.Threading;\nusing Ecliptix.Core.Core.Messaging.Events;\nusing Ecliptix.Core.Core.Messaging.Services;\n\nusing ReactiveUI;\nusing IMessageBus = Ecliptix.Core.Core.Messaging.IMessageBus;\n\nnamespace Ecliptix.Core.Controls.Modals.BottomSheetModal;\n\npublic sealed class BottomSheetViewModel : ReactiveObject, IActivatableViewModel, IDisposable\n{\n    private readonly IBottomSheetService _bottomSheetService;\n    private readonly IMessageBus _messageBus;\n    private bool _disposed;\n    private bool _isVisible;\n    private bool _isDismissableOnScrimClick;\n    private bool _showScrim;\n    private UserControl? _content;\n\n    public UserControl? Content\n    {\n        get => _content;\n        set => this.RaiseAndSetIfChanged(ref _content, value);\n    }\n\n    public bool ShowScrim\n    {\n        get => _showScrim;\n        set => this.RaiseAndSetIfChanged(ref _showScrim, value);\n    }\n\n    public bool IsVisible\n    {\n        get => _isVisible;\n        set => this.RaiseAndSetIfChanged(ref _isVisible, value);\n    }\n\n    public bool IsDismissableOnScrimClick\n    {\n        get => _isDismissableOnScrimClick;\n        set => this.RaiseAndSetIfChanged(ref _isDismissableOnScrimClick, value);\n    }\n\n    public ViewModelActivator Activator { get; } = new();\n\n    public BottomSheetViewModel(IBottomSheetService bottomSheetService, IMessageBus messageBus)\n    {\n        _bottomSheetService = bottomSheetService;\n        _messageBus = messageBus;\n\n        this.WhenActivated(disposables =>\n        {\n            _messageBus.Subscribe<BottomSheetCommandEvent>(async evt =>\n            {\n                await HandleCommand(evt);\n            }).DisposeWith(disposables);\n\n            this.WhenAnyValue(x => x.IsVisible)\n                .Skip(1)\n                .Subscribe(async isVisible =>\n                {\n                    UserControl? contentSnapshot = Content;\n\n                    await Task.Delay(isVisible\n                        ? BottomSheetAnimationConstants.ShowAnimationDuration\n                        : BottomSheetAnimationConstants.HideAnimationDuration);\n\n                    await _messageBus.PublishAsync(isVisible\n                        ? BottomSheetAnimationCompleteEvent.ShowComplete()\n                        : BottomSheetAnimationCompleteEvent.HideComplete());\n\n                    if (!isVisible)\n                    {\n                        await Task.Delay(50);\n\n                        await Dispatcher.UIThread.InvokeAsync(() =>\n                        {\n                            if (ReferenceEquals(Content, contentSnapshot))\n                            {\n                                Content = null;\n                            }\n                        });\n                    }\n                })\n                .DisposeWith(disposables);\n        });\n    }\n\n    private Task HandleCommand(BottomSheetCommandEvent evt)\n    {\n        if (_disposed)\n        {\n            return Task.CompletedTask;\n        }\n\n        if (evt.AnimationType == AnimationType.Show)\n        {\n            Content = evt.Control;\n            ShowScrim = evt.ShowScrim;\n            IsDismissableOnScrimClick = evt.IsDismissable;\n            IsVisible = true;\n        }\n        else\n        {\n            IsVisible = false;\n        }\n\n        return Task.CompletedTask;\n    }\n\n    public void BottomSheetDismissed()\n    {\n        Task.Run(async () => await _bottomSheetService.BottomSheetDismissed());\n    }\n\n    public void Dispose()\n    {\n        if (_disposed)\n        {\n            return;\n        }\n\n        _disposed = true;\n        GC.SuppressFinalize(this);\n    }\n}\n"
  }
}
 [2025-11-04T12:57:51.344] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/BottomSheetModal/BottomSheetViewModel.cs with new text:
using System;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Threading.Tasks;

using Avalonia.Controls;
using Avalonia.Threading;
using Ecliptix.Core.Core.Messaging.Events;
using Ecliptix.Core.Core.Messaging.Services;

using ReactiveUI;
using IMessageBus = Ecliptix.Core.Core.Messaging.IMessageBus;

namespace Ecliptix.Core.Controls.Modals.BottomSheetModal;

public sealed class BottomSheetViewModel : ReactiveObject, IActivatableViewModel, IDisposable
{
    private readonly IBottomSheetService _bottomSheetService;
    private readonly IMessageBus _messageBus;
    private bool _disposed;
    private bool _isVisible;
    private bool _isDismissableOnScrimClick;
    private bool _showScrim;
    private UserControl? _content;

    public UserControl? Content
    {
        get => _content;
        set => this.RaiseAndSetIfChanged(ref _content, value);
    }

    public bool ShowScrim
    {
        get => _showScrim;
        set => this.RaiseAndSetIfChanged(ref _showScrim, value);
    }

    public bool IsVisible
    {
        get => _isVisible;
        set => this.RaiseAndSetIfChanged(ref _isVisible, value);
    }

    public bool IsDismissableOnScrimClick
    {
        get => _isDismissableOnScrimClick;
        set => this.RaiseAndSetIfChanged(ref _isDismissableOnScrimClick, value);
    }

    public ViewModelActivator Activator { get; } = new();

    public BottomSheetViewModel(IBottomSheetService bottomSheetService, IMessageBus messageBus)
    {
        _bottomSheetService = bottomSheetService;
        _messageBus = messageBus;

        this.WhenActivated(disposables =>
        {
            _messageBus.Subscribe<BottomSheetCommandEvent>(async evt =>
            {
                await HandleCommand(evt);
            }).DisposeWith(disposables);

            this.WhenAnyValue(x => x.IsVisible)
                .Skip(1)
                .Subscribe(async isVisible =>
                {
                    UserControl? contentSnapshot = Content;

                    await Task.Delay(isVisible
                        ? BottomSheetAnimationConstants.ShowAnimationDuration
                        : BottomSheetAnimationConstants.HideAnimationDuration);

                    await _messageBus.PublishAsync(isVisible
                        ? BottomSheetAnimationCompleteEvent.ShowComplete()
                        : BottomSheetAnimationCompleteEvent.HideComplete());

                    if (!isVisible)
                    {
                        await Task.Delay(50);

                        await Dispatcher.UIThread.InvokeAsync(() =>
                        {
                            if (ReferenceEquals(Content, contentSnapshot))
                            {
                                Content = null;
                            }
                        });
                    }
                })
                .DisposeWith(disposables);
        });
    }

    private Task HandleCommand(BottomSheetCommandEvent evt)
    {
        if (_disposed)
        {
            return Task.CompletedTask;
        }

        if (evt.AnimationType == AnimationType.Show)
        {
            Content = evt.Control;
            ShowScrim = evt.ShowScrim;
            IsDismissableOnScrimClick = evt.IsDismissable;
            IsVisible = true;
        }
        else
        {
            IsVisible = false;
        }

        return Task.CompletedTask;
    }

    public void BottomSheetDismissed()
    {
        Task.Run(async () => await _bottomSheetService.BottomSheetDismissed());
    }

    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        _disposed = true;
        GC.SuppressFinalize(this);
    }
}

 [2025-11-04T12:57:51.344] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3567ms) ************
{
  "Request_seq": 9339,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549910,
  "Type": "response"
}
 [2025-11-04T12:57:51.344] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9340,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/BottomSheetModal/BottomSheetViewModel.cs"
  }
}
 [2025-11-04T12:57:51.482] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (137.8423ms) ************
{
  "Request_seq": 9340,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549914,
  "Type": "response"
}
 [2025-11-04T12:57:51.482] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9341,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/ProtocolStateGrpc.cs",
    "Buffer": ""
  }
}
 [2025-11-04T12:57:51.482] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/ProtocolStateGrpc.cs with new text:

 [2025-11-04T12:57:51.482] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.1950ms) ************
{
  "Request_seq": 9341,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549918,
  "Type": "response"
}
 [2025-11-04T12:57:51.483] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9342,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/ProtocolStateGrpc.cs"
  }
}
 [2025-11-04T12:57:51.529] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (46.4652ms) ************
{
  "Request_seq": 9342,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549922,
  "Type": "response"
}
 [2025-11-04T12:57:51.53] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9343,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/AssemblyInfo.cs",
    "Buffer": "using System.Runtime.CompilerServices;\n\n[assembly: InternalsVisibleTo(\"Ecliptix.Protocol.System\")]\n[assembly: InternalsVisibleTo(\"Ecliptix.Opaque.Protocol\")]\n[assembly: InternalsVisibleTo(\"Ecliptix.Core\")]\n[assembly: InternalsVisibleTo(\"Ecliptix.Core.Desktop\")]\n[assembly: InternalsVisibleTo(\"Ecliptix.Network\")]\n[assembly: InternalsVisibleTo(\"Ecliptix.Security.Certificate.Pinning\")]\n"
  }
}
 [2025-11-04T12:57:51.53] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/AssemblyInfo.cs with new text:
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("Ecliptix.Protocol.System")]
[assembly: InternalsVisibleTo("Ecliptix.Opaque.Protocol")]
[assembly: InternalsVisibleTo("Ecliptix.Core")]
[assembly: InternalsVisibleTo("Ecliptix.Core.Desktop")]
[assembly: InternalsVisibleTo("Ecliptix.Network")]
[assembly: InternalsVisibleTo("Ecliptix.Security.Certificate.Pinning")]

 [2025-11-04T12:57:51.53] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2218ms) ************
{
  "Request_seq": 9343,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549926,
  "Type": "response"
}
 [2025-11-04T12:57:51.53] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9344,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/AssemblyInfo.cs"
  }
}
 [2025-11-04T12:57:51.577] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (47.2437ms) ************
{
  "Request_seq": 9344,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549930,
  "Type": "response"
}
 [2025-11-04T12:57:51.578] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9345,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/StorageKeyConstants.cs",
    "Buffer": "namespace Ecliptix.Utilities;\n\ninternal static class StorageKeyConstants\n{\n    internal static class SessionContext\n    {\n        public const string SignInSession = \"ecliptix-signin-session\";\n        public const string SessionKeyPrefix = \"ecliptix-session-key\";\n        public const string MasterSalt = \"ECLIPTIX_MSTR_V1\";\n        public const string DomainContext = \"ECLIPTIX_MASTER_KEY\";\n        public const string Ed25519Context = \"ED25519\";\n        public const string X25519Context = \"X25519\";\n        public const string SignedPreKeyContext = \"SPK_X25519\";\n    }\n}\n"
  }
}
 [2025-11-04T12:57:51.578] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/StorageKeyConstants.cs with new text:
namespace Ecliptix.Utilities;

internal static class StorageKeyConstants
{
    internal static class SessionContext
    {
        public const string SignInSession = "ecliptix-signin-session";
        public const string SessionKeyPrefix = "ecliptix-session-key";
        public const string MasterSalt = "ECLIPTIX_MSTR_V1";
        public const string DomainContext = "ECLIPTIX_MASTER_KEY";
        public const string Ed25519Context = "ED25519";
        public const string X25519Context = "X25519";
        public const string SignedPreKeyContext = "SPK_X25519";
    }
}

 [2025-11-04T12:57:51.578] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2402ms) ************
{
  "Request_seq": 9345,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549933,
  "Type": "response"
}
 [2025-11-04T12:57:51.578] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9346,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/StorageKeyConstants.cs"
  }
}
 [2025-11-04T12:57:51.621] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (42.7285ms) ************
{
  "Request_seq": 9346,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549937,
  "Type": "response"
}
 [2025-11-04T12:57:51.622] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9347,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Shared/Converters/BooleanToOpacityConverter.cs",
    "Buffer": "using System;\nusing System.Globalization;\nusing Avalonia;\nusing Avalonia.Data.Converters;\n\nnamespace Ecliptix.Core.Shared.Converters;\n\npublic class BooleanToOpacityConverter : IValueConverter\n{\n    public double TrueOpacity { get; set; } = 1.0;\n    public double FalseOpacity { get; set; } = 0;\n\n    public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)\n    {\n        if (value is bool boolValue)\n        {\n            return boolValue ? TrueOpacity : FalseOpacity;\n        }\n        return FalseOpacity;\n    }\n\n    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException(\"ConvertBack is not supported for one-way opacity binding\");\n    }\n}\n"
  }
}
 [2025-11-04T12:57:51.622] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Shared/Converters/BooleanToOpacityConverter.cs with new text:
using System;
using System.Globalization;
using Avalonia;
using Avalonia.Data.Converters;

namespace Ecliptix.Core.Shared.Converters;

public class BooleanToOpacityConverter : IValueConverter
{
    public double TrueOpacity { get; set; } = 1.0;
    public double FalseOpacity { get; set; } = 0;

    public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is bool boolValue)
        {
            return boolValue ? TrueOpacity : FalseOpacity;
        }
        return FalseOpacity;
    }

    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException("ConvertBack is not supported for one-way opacity binding");
    }
}

 [2025-11-04T12:57:51.622] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3325ms) ************
{
  "Request_seq": 9347,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549941,
  "Type": "response"
}
 [2025-11-04T12:57:51.622] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9348,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Shared/Converters/BooleanToOpacityConverter.cs"
  }
}
 [2025-11-04T12:57:51.731] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (108.8016ms) ************
{
  "Request_seq": 9348,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549945,
  "Type": "response"
}
 [2025-11-04T12:57:51.732] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9349,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/EcliptixProtocol/EcliptixProtocolFailureType.cs",
    "Buffer": "namespace Ecliptix.Utilities.Failures.EcliptixProtocol;\n\npublic enum EcliptixProtocolFailureType\n{\n    Generic,\n    DecodeFailed,\n    DeriveKeyFailed,\n    HandshakeFailed,\n    PeerPubKeyFailed,\n    InvalidInput,\n    ObjectDisposed,\n    AllocationFailed,\n    PinningFailure,\n    BufferTooSmall,\n    DataTooLarge,\n    KeyGenerationFailed,\n    PrepareLocalFailed,\n    MemoryBufferError,\n    StateMismatch,\n}\n"
  }
}
 [2025-11-04T12:57:51.732] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/EcliptixProtocol/EcliptixProtocolFailureType.cs with new text:
namespace Ecliptix.Utilities.Failures.EcliptixProtocol;

public enum EcliptixProtocolFailureType
{
    Generic,
    DecodeFailed,
    DeriveKeyFailed,
    HandshakeFailed,
    PeerPubKeyFailed,
    InvalidInput,
    ObjectDisposed,
    AllocationFailed,
    PinningFailure,
    BufferTooSmall,
    DataTooLarge,
    KeyGenerationFailed,
    PrepareLocalFailed,
    MemoryBufferError,
    StateMismatch,
}

 [2025-11-04T12:57:51.732] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2570ms) ************
{
  "Request_seq": 9349,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549949,
  "Type": "response"
}
 [2025-11-04T12:57:51.732] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9350,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/EcliptixProtocol/EcliptixProtocolFailureType.cs"
  }
}
 [2025-11-04T12:57:51.783] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (50.9134ms) ************
{
  "Request_seq": 9350,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549953,
  "Type": "response"
}
 [2025-11-04T12:57:51.784] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9351,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Security/KeySplitting/IHardenedKeyDerivation.cs",
    "Buffer": "using System.Threading.Tasks;\nusing Ecliptix.Protocol.System.Sodium;\nusing Ecliptix.Utilities;\nusing Ecliptix.Utilities.Failures;\n\nnamespace Ecliptix.Core.Infrastructure.Security.KeySplitting;\n\npublic interface IHardenedKeyDerivation\n{\n    Task<Result<SodiumSecureMemoryHandle, KeySplittingFailure>> DeriveEnhancedMasterKeyHandleAsync(\n        SodiumSecureMemoryHandle baseKeyHandle,\n        string context,\n        KeyDerivationOptions options);\n}\n\npublic class KeyDerivationOptions\n{\n    public int MemorySize { get; set; } = 262144;\n    public int Iterations { get; set; } = 4;\n    public int DegreeOfParallelism { get; set; } = 4;\n    public bool UseHardwareEntropy { get; set; } = true;\n    public int OutputLength { get; set; } = 64;\n}\n"
  }
}
 [2025-11-04T12:57:51.784] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Security/KeySplitting/IHardenedKeyDerivation.cs with new text:
using System.Threading.Tasks;
using Ecliptix.Protocol.System.Sodium;
using Ecliptix.Utilities;
using Ecliptix.Utilities.Failures;

namespace Ecliptix.Core.Infrastructure.Security.KeySplitting;

public interface IHardenedKeyDerivation
{
    Task<Result<SodiumSecureMemoryHandle, KeySplittingFailure>> DeriveEnhancedMasterKeyHandleAsync(
        SodiumSecureMemoryHandle baseKeyHandle,
        string context,
        KeyDerivationOptions options);
}

public class KeyDerivationOptions
{
    public int MemorySize { get; set; } = 262144;
    public int Iterations { get; set; } = 4;
    public int DegreeOfParallelism { get; set; } = 4;
    public bool UseHardwareEntropy { get; set; } = true;
    public int OutputLength { get; set; } = 64;
}

 [2025-11-04T12:57:51.784] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3621ms) ************
{
  "Request_seq": 9351,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549956,
  "Type": "response"
}
 [2025-11-04T12:57:51.784] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9352,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Security/KeySplitting/IHardenedKeyDerivation.cs"
  }
}
 [2025-11-04T12:57:51.889] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (105.3909ms) ************
{
  "Request_seq": 9352,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549960,
  "Type": "response"
}
 [2025-11-04T12:57:51.89] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9353,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/Constants/MobileNumberValidatorConstants.cs",
    "Buffer": "namespace Ecliptix.Core.Services.Membership.Constants;\n\npublic static class MobileNumberValidatorConstants\n{\n    public static class LocalizationKeys\n    {\n        public const string CannotBeEmpty = \"ValidationErrors.MobileNumber.CannotBeEmpty\";\n        public const string MustStartWithCountryCode = \"ValidationErrors.MobileNumber.MustStartWithCountryCode\";\n        public const string ContainsNonDigits = \"ValidationErrors.MobileNumber.ContainsNonDigits\";\n        public const string IncorrectLength = \"ValidationErrors.MobileNumber.IncorrectLength\";\n    }\n\n    public static class ValidationRules\n    {\n        public const string CountryCodePrefix = \"+\";\n        public const int MinDigits = 7;\n        public const int MaxDigits = 15;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:51.89] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/Constants/MobileNumberValidatorConstants.cs with new text:
namespace Ecliptix.Core.Services.Membership.Constants;

public static class MobileNumberValidatorConstants
{
    public static class LocalizationKeys
    {
        public const string CannotBeEmpty = "ValidationErrors.MobileNumber.CannotBeEmpty";
        public const string MustStartWithCountryCode = "ValidationErrors.MobileNumber.MustStartWithCountryCode";
        public const string ContainsNonDigits = "ValidationErrors.MobileNumber.ContainsNonDigits";
        public const string IncorrectLength = "ValidationErrors.MobileNumber.IncorrectLength";
    }

    public static class ValidationRules
    {
        public const string CountryCodePrefix = "+";
        public const int MinDigits = 7;
        public const int MaxDigits = 15;
    }
}

 [2025-11-04T12:57:51.89] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3654ms) ************
{
  "Request_seq": 9353,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549964,
  "Type": "response"
}
 [2025-11-04T12:57:51.89] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9354,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/Constants/MobileNumberValidatorConstants.cs"
  }
}
 [2025-11-04T12:57:51.99] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (99.8627ms) ************
{
  "Request_seq": 9354,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549968,
  "Type": "response"
}
 [2025-11-04T12:57:51.991] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9355,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Validations/ValidationFailure.cs",
    "Buffer": "using Grpc.Core;\n\nnamespace Ecliptix.Utilities.Failures.Validations;\n\npublic enum ValidationFailureType\n{\n    SignInFailed,\n    LoginAttemptExceeded\n}\n\npublic record ValidationFailure(\n    ValidationFailureType FailureType,\n    string Message,\n    Exception? InnerException = null)\n    : FailureBase(Message, InnerException)\n{\n    public override object ToStructuredLog()\n    {\n        return new\n        {\n            ValidationFailureType = FailureType.ToString(),\n            Message,\n            InnerException,\n            Timestamp\n        };\n    }\n\n    public static ValidationFailure SignInFailed(string details, Exception? inner = null) =>\n        new(ValidationFailureType.SignInFailed, details, inner);\n\n    public static ValidationFailure LoginAttemptExceeded(string details, Exception? inner = null) =>\n        new(ValidationFailureType.LoginAttemptExceeded, details, inner);\n\n    public override GrpcErrorDescriptor ToGrpcDescriptor() =>\n        FailureType switch\n        {\n            ValidationFailureType.LoginAttemptExceeded => new GrpcErrorDescriptor(\n                ErrorCode.MaxAttemptsReached, StatusCode.ResourceExhausted, ErrorI18nKeys.MaxAttempts),\n            _ => new GrpcErrorDescriptor(\n                ErrorCode.ValidationFailed, StatusCode.InvalidArgument, ErrorI18nKeys.Validation)\n        };\n}\n"
  }
}
 [2025-11-04T12:57:51.991] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Validations/ValidationFailure.cs with new text:
using Grpc.Core;

namespace Ecliptix.Utilities.Failures.Validations;

public enum ValidationFailureType
{
    SignInFailed,
    LoginAttemptExceeded
}

public record ValidationFailure(
    ValidationFailureType FailureType,
    string Message,
    Exception? InnerException = null)
    : FailureBase(Message, InnerException)
{
    public override object ToStructuredLog()
    {
        return new
        {
            ValidationFailureType = FailureType.ToString(),
            Message,
            InnerException,
            Timestamp
        };
    }

    public static ValidationFailure SignInFailed(string details, Exception? inner = null) =>
        new(ValidationFailureType.SignInFailed, details, inner);

    public static ValidationFailure LoginAttemptExceeded(string details, Exception? inner = null) =>
        new(ValidationFailureType.LoginAttemptExceeded, details, inner);

    public override GrpcErrorDescriptor ToGrpcDescriptor() =>
        FailureType switch
        {
            ValidationFailureType.LoginAttemptExceeded => new GrpcErrorDescriptor(
                ErrorCode.MaxAttemptsReached, StatusCode.ResourceExhausted, ErrorI18nKeys.MaxAttempts),
            _ => new GrpcErrorDescriptor(
                ErrorCode.ValidationFailed, StatusCode.InvalidArgument, ErrorI18nKeys.Validation)
        };
}

 [2025-11-04T12:57:51.991] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3034ms) ************
{
  "Request_seq": 9355,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549972,
  "Type": "response"
}
 [2025-11-04T12:57:51.991] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9356,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Validations/ValidationFailure.cs"
  }
}
 [2025-11-04T12:57:52.048] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (56.2804ms) ************
{
  "Request_seq": 9356,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549976,
  "Type": "response"
}
 [2025-11-04T12:57:52.049] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9357,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Sodium/SodiumExceptionMessagePatterns.cs",
    "Buffer": "namespace Ecliptix.Utilities.Failures.Sodium;\n\npublic static class SodiumExceptionMessagePatterns\n{\n    public const string SodiumInitPattern = \"sodium_init() returned an error code\";\n    public const string AddressPinnedObjectPattern = \"AddrOfPinnedObject returned IntPtr.Zero\";\n}\n"
  }
}
 [2025-11-04T12:57:52.049] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Sodium/SodiumExceptionMessagePatterns.cs with new text:
namespace Ecliptix.Utilities.Failures.Sodium;

public static class SodiumExceptionMessagePatterns
{
    public const string SodiumInitPattern = "sodium_init() returned an error code";
    public const string AddressPinnedObjectPattern = "AddrOfPinnedObject returned IntPtr.Zero";
}

 [2025-11-04T12:57:52.049] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2063ms) ************
{
  "Request_seq": 9357,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549980,
  "Type": "response"
}
 [2025-11-04T12:57:52.049] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9358,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Sodium/SodiumExceptionMessagePatterns.cs"
  }
}
 [2025-11-04T12:57:52.092] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (43.2814ms) ************
{
  "Request_seq": 9358,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549984,
  "Type": "response"
}
 [2025-11-04T12:57:52.102] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9359,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/OpaqueModels.cs",
    "Buffer": "// <auto-generated>\n//     Generated by the protocol buffer compiler.  DO NOT EDIT!\n//     source: membership/opaque_models.proto\n// </auto-generated>\n#pragma warning disable 1591, 0612, 3021, 8981\n#region Designer generated code\n\nusing pb = global::Google.Protobuf;\nusing pbc = global::Google.Protobuf.Collections;\nusing pbr = global::Google.Protobuf.Reflection;\nusing scg = global::System.Collections.Generic;\nnamespace Ecliptix.Protobuf.Membership {\n\n  /// <summary>Holder for reflection information generated from membership/opaque_models.proto</summary>\n  public static partial class OpaqueModelsReflection {\n\n    #region Descriptor\n    /// <summary>File descriptor for membership/opaque_models.proto</summary>\n    public static pbr::FileDescriptor Descriptor {\n      get { return descriptor; }\n    }\n    private static pbr::FileDescriptor descriptor;\n\n    static OpaqueModelsReflection() {\n      byte[] descriptorData = global::System.Convert.FromBase64String(\n          string.Concat(\n            \"Ch5tZW1iZXJzaGlwL29wYXF1ZV9tb2RlbHMucHJvdG8SGWVjbGlwdGl4LnBy\",\n            \"b3RvLm1lbWJlcnNoaXAaIG1lbWJlcnNoaXAvbWVtYmVyc2hpcF9jb3JlLnBy\",\n            \"b3RvGhxhY2NvdW50L2FjY291bnRfbW9kZWxzLnByb3RvGh9nb29nbGUvcHJv\",\n            \"dG9idWYvdGltZXN0YW1wLnByb3RvIlEKHU9wYXF1ZVJlZ2lzdHJhdGlvbklu\",\n            \"aXRSZXF1ZXN0EhEKCXBlZXJfb3ByZhgBIAEoDBIdChVtZW1iZXJzaGlwX2lk\",\n            \"ZW50aWZpZXIYAiABKAwitAIKHk9wYXF1ZVJlZ2lzdHJhdGlvbkluaXRSZXNw\",\n            \"b25zZRIRCglwZWVyX29wcmYYASABKAwSVgoGcmVzdWx0GAIgASgOMkYuZWNs\",\n            \"aXB0aXgucHJvdG8ubWVtYmVyc2hpcC5PcGFxdWVSZWdpc3RyYXRpb25Jbml0\",\n            \"UmVzcG9uc2UuVXBkYXRlUmVzdWx0EhQKB21lc3NhZ2UYAyABKAlIAIgBARI+\",\n            \"CgptZW1iZXJzaGlwGAQgASgLMiUuZWNsaXB0aXgucHJvdG8ubWVtYmVyc2hp\",\n            \"cC5NZW1iZXJzaGlwSAGIAQEiNgoMVXBkYXRlUmVzdWx0Eg0KCVNVQ0NFRURF\",\n            \"RBAAEhcKE0lOVkFMSURfQ1JFREVOVElBTFMQAUIKCghfbWVzc2FnZUINCgtf\",\n            \"bWVtYmVyc2hpcCJ4CiFPcGFxdWVSZWdpc3RyYXRpb25Db21wbGV0ZVJlcXVl\",\n            \"c3QSIAoYcGVlcl9yZWdpc3RyYXRpb25fcmVjb3JkGAEgASgMEh0KFW1lbWJl\",\n            \"cnNoaXBfaWRlbnRpZmllchgCIAEoDBISCgptYXN0ZXJfa2V5GAMgASgMIoUD\",\n            \"CiJPcGFxdWVSZWdpc3RyYXRpb25Db21wbGV0ZVJlc3BvbnNlEmAKBnJlc3Vs\",\n            \"dBgBIAEoDjJQLmVjbGlwdGl4LnByb3RvLm1lbWJlcnNoaXAuT3BhcXVlUmVn\",\n            \"aXN0cmF0aW9uQ29tcGxldGVSZXNwb25zZS5SZWdpc3RyYXRpb25SZXN1bHQS\",\n            \"FAoHbWVzc2FnZRgCIAEoCUgAiAEBEhgKC3Nlc3Npb25fa2V5GAMgASgMSAGI\",\n            \"AQESOwoSYXZhaWxhYmxlX2FjY291bnRzGAQgAygLMh8uZWNsaXB0aXgucHJv\",\n            \"dG8uYWNjb3VudC5BY2NvdW50EjwKDmFjdGl2ZV9hY2NvdW50GAUgASgLMh8u\",\n            \"ZWNsaXB0aXgucHJvdG8uYWNjb3VudC5BY2NvdW50SAKIAQEiIwoSUmVnaXN0\",\n            \"cmF0aW9uUmVzdWx0Eg0KCVNVQ0NFRURFRBAAQgoKCF9tZXNzYWdlQg4KDF9z\",\n            \"ZXNzaW9uX2tleUIRCg9fYWN0aXZlX2FjY291bnQiQwoXT3BhcXVlU2lnbklu\",\n            \"SW5pdFJlcXVlc3QSFQoNbW9iaWxlX251bWJlchgBIAEoCRIRCglwZWVyX29w\",\n            \"cmYYAiABKAwirAMKGE9wYXF1ZVNpZ25JbkluaXRSZXNwb25zZRIcChRzZXJ2\",\n            \"ZXJfb3ByZl9yZXNwb25zZRgBIAEoDBIjChtzZXJ2ZXJfZXBoZW1lcmFsX3B1\",\n            \"YmxpY19rZXkYAiABKAwSGwoTcmVnaXN0cmF0aW9uX3JlY29yZBgDIAEoDBIa\",\n            \"ChJzZXJ2ZXJfc3RhdGVfdG9rZW4YBCABKAwSFAoHbWVzc2FnZRgFIAEoCUgA\",\n            \"iAEBEiAKE21pbnV0ZXNfdW50aWxfcmV0cnkYBiABKAVIAYgBARJQCgZyZXN1\",\n            \"bHQYByABKA4yQC5lY2xpcHRpeC5wcm90by5tZW1iZXJzaGlwLk9wYXF1ZVNp\",\n            \"Z25JbkluaXRSZXNwb25zZS5TaWduSW5SZXN1bHQSEgoKc2VydmVyX21hYxgI\",\n            \"IAEoDCJSCgxTaWduSW5SZXN1bHQSDQoJU1VDQ0VFREVEEAASFwoTSU5WQUxJ\",\n            \"RF9DUkVERU5USUFMUxABEhoKFkxPR0lOX0FUVEVNUFRfRVhDRUVERUQQAkIK\",\n            \"CghfbWVzc2FnZUIWChRfbWludXRlc191bnRpbF9yZXRyeSKJAQobT3BhcXVl\",\n            \"U2lnbkluRmluYWxpemVSZXF1ZXN0EhUKDW1vYmlsZV9udW1iZXIYASABKAkS\",\n            \"IwobY2xpZW50X2VwaGVtZXJhbF9wdWJsaWNfa2V5GAIgASgMEhIKCmNsaWVu\",\n            \"dF9tYWMYAyABKAwSGgoSc2VydmVyX3N0YXRlX3Rva2VuGAQgASgMIpUEChxP\",\n            \"cGFxdWVTaWduSW5GaW5hbGl6ZVJlc3BvbnNlEhIKCnNlcnZlcl9tYWMYASAB\",\n            \"KAwSPgoKbWVtYmVyc2hpcBgCIAEoCzIlLmVjbGlwdGl4LnByb3RvLm1lbWJl\",\n            \"cnNoaXAuTWVtYmVyc2hpcEgAiAEBElQKBnJlc3VsdBgDIAEoDjJELmVjbGlw\",\n            \"dGl4LnByb3RvLm1lbWJlcnNoaXAuT3BhcXVlU2lnbkluRmluYWxpemVSZXNw\",\n            \"b25zZS5TaWduSW5SZXN1bHQSFAoHbWVzc2FnZRgEIAEoCUgBiAEBEiAKE21p\",\n            \"bnV0ZXNfdW50aWxfcmV0cnkYBSABKAVIAogBARI7ChJhdmFpbGFibGVfYWNj\",\n            \"b3VudHMYBiADKAsyHy5lY2xpcHRpeC5wcm90by5hY2NvdW50LkFjY291bnQS\",\n            \"PAoOYWN0aXZlX2FjY291bnQYByABKAsyHy5lY2xpcHRpeC5wcm90by5hY2Nv\",\n            \"dW50LkFjY291bnRIA4gBASJSCgxTaWduSW5SZXN1bHQSDQoJU1VDQ0VFREVE\",\n            \"EAASFwoTSU5WQUxJRF9DUkVERU5USUFMUxABEhoKFkxPR0lOX0FUVEVNUFRf\",\n            \"RVhDRUVERUQQAkINCgtfbWVtYmVyc2hpcEIKCghfbWVzc2FnZUIWChRfbWlu\",\n            \"dXRlc191bnRpbF9yZXRyeUIRCg9fYWN0aXZlX2FjY291bnQiVgoiT3BhcXVl\",\n            \"UmVjb3ZlcnlTZWN1cmVLZXlJbml0UmVxdWVzdBIRCglwZWVyX29wcmYYASAB\",\n            \"KAwSHQoVbWVtYmVyc2hpcF9pZGVudGlmaWVyGAIgASgMIsICCiNPcGFxdWVS\",\n            \"ZWNvdmVyeVNlY3VyZUtleUluaXRSZXNwb25zZRIRCglwZWVyX29wcmYYASAB\",\n            \"KAwSXQoGcmVzdWx0GAIgASgOMk0uZWNsaXB0aXgucHJvdG8ubWVtYmVyc2hp\",\n            \"cC5PcGFxdWVSZWNvdmVyeVNlY3VyZUtleUluaXRSZXNwb25zZS5SZWNvdmVy\",\n            \"eVJlc3VsdBIUCgdtZXNzYWdlGAMgASgJSACIAQESPgoKbWVtYmVyc2hpcBgE\",\n            \"IAEoCzIlLmVjbGlwdGl4LnByb3RvLm1lbWJlcnNoaXAuTWVtYmVyc2hpcEgB\",\n            \"iAEBIjgKDlJlY292ZXJ5UmVzdWx0Eg0KCVNVQ0NFRURFRBAAEhcKE0lOVkFM\",\n            \"SURfQ1JFREVOVElBTFMQAUIKCghfbWVzc2FnZUINCgtfbWVtYmVyc2hpcCJ5\",\n            \"CiZPcGFxdWVSZWNvdmVyeVNlY3JldEtleUNvbXBsZXRlUmVxdWVzdBIcChRw\",\n            \"ZWVyX3JlY292ZXJ5X3JlY29yZBgBIAEoDBIdChVtZW1iZXJzaGlwX2lkZW50\",\n            \"aWZpZXIYAiABKAwSEgoKbWFzdGVyX2tleRgDIAEoDCJLCidPcGFxdWVSZWNv\",\n            \"dmVyeVNlY3JldEtleUNvbXBsZXRlUmVzcG9uc2USFAoHbWVzc2FnZRgBIAEo\",\n            \"CUgAiAEBQgoKCF9tZXNzYWdlIvkBCg5Ba2VTZXJ2ZXJTdGF0ZRIqCiJzZXJ2\",\n            \"ZXJfZXBoZW1lcmFsX3ByaXZhdGVfa2V5X2J5dGVzGAEgASgMEiMKG3NlcnZl\",\n            \"cl9lcGhlbWVyYWxfcHVibGljX2tleRgCIAEoDBIgChhjbGllbnRfc3RhdGlj\",\n            \"X3B1YmxpY19rZXkYAyABKAwSFQoNb3ByZl9yZXNwb25zZRgEIAEoDBIQCgh1\",\n            \"c2VybmFtZRgFIAEoCRIbChNyZWdpc3RyYXRpb25fcmVjb3JkGAYgASgMEi4K\",\n            \"CmV4cGlyYXRpb24YByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1w\",\n            \"Im8KFkFrZVNlY3VyZUtleVJlc2V0U3RhdGUSEAoIdXNlcm5hbWUYASABKAkS\",\n            \"EwoLcmVzZXRfdG9rZW4YAiABKAkSLgoKZXhwaXJhdGlvbhgDIAEoCzIaLmdv\",\n            \"b2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCH6oCHEVjbGlwdGl4LlByb3RvYnVm\",\n            \"Lk1lbWJlcnNoaXBiBnByb3RvMw==\"));\n      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,\n          new pbr::FileDescriptor[] { global::Ecliptix.Protobuf.Membership.MembershipCoreReflection.Descriptor, global::Ecliptix.Protobuf.Account.AccountModelsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },\n          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitRequest), global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitRequest.Parser, new[]{ \"PeerOprf\", \"MembershipIdentifier\" }, null, null, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse), global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Parser, new[]{ \"PeerOprf\", \"Result\", \"Message\", \"Membership\" }, new[]{ \"Message\", \"Membership\" }, new[]{ typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult) }, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteRequest), global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteRequest.Parser, new[]{ \"PeerRegistrationRecord\", \"MembershipIdentifier\", \"MasterKey\" }, null, null, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse), global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Parser, new[]{ \"Result\", \"Message\", \"SessionKey\", \"AvailableAccounts\", \"ActiveAccount\" }, new[]{ \"Message\", \"SessionKey\", \"ActiveAccount\" }, new[]{ typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult) }, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInInitRequest), global::Ecliptix.Protobuf.Membership.OpaqueSignInInitRequest.Parser, new[]{ \"MobileNumber\", \"PeerOprf\" }, null, null, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse), global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Parser, new[]{ \"ServerOprfResponse\", \"ServerEphemeralPublicKey\", \"RegistrationRecord\", \"ServerStateToken\", \"Message\", \"MinutesUntilRetry\", \"Result\", \"ServerMac\" }, new[]{ \"Message\", \"MinutesUntilRetry\" }, new[]{ typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult) }, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeRequest), global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeRequest.Parser, new[]{ \"MobileNumber\", \"ClientEphemeralPublicKey\", \"ClientMac\", \"ServerStateToken\" }, null, null, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse), global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Parser, new[]{ \"ServerMac\", \"Membership\", \"Result\", \"Message\", \"MinutesUntilRetry\", \"AvailableAccounts\", \"ActiveAccount\" }, new[]{ \"Membership\", \"Message\", \"MinutesUntilRetry\", \"ActiveAccount\" }, new[]{ typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult) }, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitRequest), global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitRequest.Parser, new[]{ \"PeerOprf\", \"MembershipIdentifier\" }, null, null, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse), global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Parser, new[]{ \"PeerOprf\", \"Result\", \"Message\", \"Membership\" }, new[]{ \"Message\", \"Membership\" }, new[]{ typeof(global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult) }, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecretKeyCompleteRequest), global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecretKeyCompleteRequest.Parser, new[]{ \"PeerRecoveryRecord\", \"MembershipIdentifier\", \"MasterKey\" }, null, null, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecretKeyCompleteResponse), global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecretKeyCompleteResponse.Parser, new[]{ \"Message\" }, new[]{ \"Message\" }, null, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.AkeServerState), global::Ecliptix.Protobuf.Membership.AkeServerState.Parser, new[]{ \"ServerEphemeralPrivateKeyBytes\", \"ServerEphemeralPublicKey\", \"ClientStaticPublicKey\", \"OprfResponse\", \"Username\", \"RegistrationRecord\", \"Expiration\" }, null, null, null, null),\n            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.AkeSecureKeyResetState), global::Ecliptix.Protobuf.Membership.AkeSecureKeyResetState.Parser, new[]{ \"Username\", \"ResetToken\", \"Expiration\" }, null, null, null, null)\n          }));\n    }\n    #endregion\n\n  }\n  #region Messages\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueRegistrationInitRequest : pb::IMessage<OpaqueRegistrationInitRequest>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueRegistrationInitRequest> _parser = new pb::MessageParser<OpaqueRegistrationInitRequest>(() => new OpaqueRegistrationInitRequest());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueRegistrationInitRequest> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[0]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationInitRequest() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationInitRequest(OpaqueRegistrationInitRequest other) : this() {\n      peerOprf_ = other.peerOprf_;\n      membershipIdentifier_ = other.membershipIdentifier_;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationInitRequest Clone() {\n      return new OpaqueRegistrationInitRequest(this);\n    }\n\n    /// <summary>Field number for the \"peer_oprf\" field.</summary>\n    public const int PeerOprfFieldNumber = 1;\n    private pb::ByteString peerOprf_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString PeerOprf {\n      get { return peerOprf_; }\n      set {\n        peerOprf_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"membership_identifier\" field.</summary>\n    public const int MembershipIdentifierFieldNumber = 2;\n    private pb::ByteString membershipIdentifier_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString MembershipIdentifier {\n      get { return membershipIdentifier_; }\n      set {\n        membershipIdentifier_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueRegistrationInitRequest);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueRegistrationInitRequest other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (PeerOprf != other.PeerOprf) return false;\n      if (MembershipIdentifier != other.MembershipIdentifier) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (PeerOprf.Length != 0) hash ^= PeerOprf.GetHashCode();\n      if (MembershipIdentifier.Length != 0) hash ^= MembershipIdentifier.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (PeerOprf.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerOprf);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(MembershipIdentifier);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (PeerOprf.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerOprf);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(MembershipIdentifier);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (PeerOprf.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerOprf);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MembershipIdentifier);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueRegistrationInitRequest other) {\n      if (other == null) {\n        return;\n      }\n      if (other.PeerOprf.Length != 0) {\n        PeerOprf = other.PeerOprf;\n      }\n      if (other.MembershipIdentifier.Length != 0) {\n        MembershipIdentifier = other.MembershipIdentifier;\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            PeerOprf = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            MembershipIdentifier = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            PeerOprf = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            MembershipIdentifier = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueRegistrationInitResponse : pb::IMessage<OpaqueRegistrationInitResponse>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueRegistrationInitResponse> _parser = new pb::MessageParser<OpaqueRegistrationInitResponse>(() => new OpaqueRegistrationInitResponse());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueRegistrationInitResponse> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[1]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationInitResponse() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationInitResponse(OpaqueRegistrationInitResponse other) : this() {\n      peerOprf_ = other.peerOprf_;\n      result_ = other.result_;\n      message_ = other.message_;\n      membership_ = other.membership_ != null ? other.membership_.Clone() : null;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationInitResponse Clone() {\n      return new OpaqueRegistrationInitResponse(this);\n    }\n\n    /// <summary>Field number for the \"peer_oprf\" field.</summary>\n    public const int PeerOprfFieldNumber = 1;\n    private pb::ByteString peerOprf_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString PeerOprf {\n      get { return peerOprf_; }\n      set {\n        peerOprf_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"result\" field.</summary>\n    public const int ResultFieldNumber = 2;\n    private global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult result_ = global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult Result {\n      get { return result_; }\n      set {\n        result_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"message\" field.</summary>\n    public const int MessageFieldNumber = 3;\n    private readonly static string MessageDefaultValue = \"\";\n\n    private string message_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public string Message {\n      get { return message_ ?? MessageDefaultValue; }\n      set {\n        message_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n    /// <summary>Gets whether the \"message\" field is set</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool HasMessage {\n      get { return message_ != null; }\n    }\n    /// <summary>Clears the value of the \"message\" field</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void ClearMessage() {\n      message_ = null;\n    }\n\n    /// <summary>Field number for the \"membership\" field.</summary>\n    public const int MembershipFieldNumber = 4;\n    private global::Ecliptix.Protobuf.Membership.Membership membership_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Membership.Membership Membership {\n      get { return membership_; }\n      set {\n        membership_ = value;\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueRegistrationInitResponse);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueRegistrationInitResponse other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (PeerOprf != other.PeerOprf) return false;\n      if (Result != other.Result) return false;\n      if (Message != other.Message) return false;\n      if (!object.Equals(Membership, other.Membership)) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (PeerOprf.Length != 0) hash ^= PeerOprf.GetHashCode();\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded) hash ^= Result.GetHashCode();\n      if (HasMessage) hash ^= Message.GetHashCode();\n      if (membership_ != null) hash ^= Membership.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (PeerOprf.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerOprf);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded) {\n        output.WriteRawTag(16);\n        output.WriteEnum((int) Result);\n      }\n      if (HasMessage) {\n        output.WriteRawTag(26);\n        output.WriteString(Message);\n      }\n      if (membership_ != null) {\n        output.WriteRawTag(34);\n        output.WriteMessage(Membership);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (PeerOprf.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerOprf);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded) {\n        output.WriteRawTag(16);\n        output.WriteEnum((int) Result);\n      }\n      if (HasMessage) {\n        output.WriteRawTag(26);\n        output.WriteString(Message);\n      }\n      if (membership_ != null) {\n        output.WriteRawTag(34);\n        output.WriteMessage(Membership);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (PeerOprf.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerOprf);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded) {\n        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Result);\n      }\n      if (HasMessage) {\n        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);\n      }\n      if (membership_ != null) {\n        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Membership);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueRegistrationInitResponse other) {\n      if (other == null) {\n        return;\n      }\n      if (other.PeerOprf.Length != 0) {\n        PeerOprf = other.PeerOprf;\n      }\n      if (other.Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded) {\n        Result = other.Result;\n      }\n      if (other.HasMessage) {\n        Message = other.Message;\n      }\n      if (other.membership_ != null) {\n        if (membership_ == null) {\n          Membership = new global::Ecliptix.Protobuf.Membership.Membership();\n        }\n        Membership.MergeFrom(other.Membership);\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            PeerOprf = input.ReadBytes();\n            break;\n          }\n          case 16: {\n            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult) input.ReadEnum();\n            break;\n          }\n          case 26: {\n            Message = input.ReadString();\n            break;\n          }\n          case 34: {\n            if (membership_ == null) {\n              Membership = new global::Ecliptix.Protobuf.Membership.Membership();\n            }\n            input.ReadMessage(Membership);\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            PeerOprf = input.ReadBytes();\n            break;\n          }\n          case 16: {\n            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult) input.ReadEnum();\n            break;\n          }\n          case 26: {\n            Message = input.ReadString();\n            break;\n          }\n          case 34: {\n            if (membership_ == null) {\n              Membership = new global::Ecliptix.Protobuf.Membership.Membership();\n            }\n            input.ReadMessage(Membership);\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n    #region Nested types\n    /// <summary>Container for nested types declared in the OpaqueRegistrationInitResponse message type.</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static partial class Types {\n      public enum UpdateResult {\n        [pbr::OriginalName(\"SUCCEEDED\")] Succeeded = 0,\n        [pbr::OriginalName(\"INVALID_CREDENTIALS\")] InvalidCredentials = 1,\n      }\n\n    }\n    #endregion\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueRegistrationCompleteRequest : pb::IMessage<OpaqueRegistrationCompleteRequest>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueRegistrationCompleteRequest> _parser = new pb::MessageParser<OpaqueRegistrationCompleteRequest>(() => new OpaqueRegistrationCompleteRequest());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueRegistrationCompleteRequest> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[2]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationCompleteRequest() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationCompleteRequest(OpaqueRegistrationCompleteRequest other) : this() {\n      peerRegistrationRecord_ = other.peerRegistrationRecord_;\n      membershipIdentifier_ = other.membershipIdentifier_;\n      masterKey_ = other.masterKey_;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationCompleteRequest Clone() {\n      return new OpaqueRegistrationCompleteRequest(this);\n    }\n\n    /// <summary>Field number for the \"peer_registration_record\" field.</summary>\n    public const int PeerRegistrationRecordFieldNumber = 1;\n    private pb::ByteString peerRegistrationRecord_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString PeerRegistrationRecord {\n      get { return peerRegistrationRecord_; }\n      set {\n        peerRegistrationRecord_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"membership_identifier\" field.</summary>\n    public const int MembershipIdentifierFieldNumber = 2;\n    private pb::ByteString membershipIdentifier_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString MembershipIdentifier {\n      get { return membershipIdentifier_; }\n      set {\n        membershipIdentifier_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"master_key\" field.</summary>\n    public const int MasterKeyFieldNumber = 3;\n    private pb::ByteString masterKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString MasterKey {\n      get { return masterKey_; }\n      set {\n        masterKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueRegistrationCompleteRequest);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueRegistrationCompleteRequest other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (PeerRegistrationRecord != other.PeerRegistrationRecord) return false;\n      if (MembershipIdentifier != other.MembershipIdentifier) return false;\n      if (MasterKey != other.MasterKey) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (PeerRegistrationRecord.Length != 0) hash ^= PeerRegistrationRecord.GetHashCode();\n      if (MembershipIdentifier.Length != 0) hash ^= MembershipIdentifier.GetHashCode();\n      if (MasterKey.Length != 0) hash ^= MasterKey.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (PeerRegistrationRecord.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerRegistrationRecord);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(MembershipIdentifier);\n      }\n      if (MasterKey.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(MasterKey);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (PeerRegistrationRecord.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerRegistrationRecord);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(MembershipIdentifier);\n      }\n      if (MasterKey.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(MasterKey);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (PeerRegistrationRecord.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerRegistrationRecord);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MembershipIdentifier);\n      }\n      if (MasterKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MasterKey);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueRegistrationCompleteRequest other) {\n      if (other == null) {\n        return;\n      }\n      if (other.PeerRegistrationRecord.Length != 0) {\n        PeerRegistrationRecord = other.PeerRegistrationRecord;\n      }\n      if (other.MembershipIdentifier.Length != 0) {\n        MembershipIdentifier = other.MembershipIdentifier;\n      }\n      if (other.MasterKey.Length != 0) {\n        MasterKey = other.MasterKey;\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            PeerRegistrationRecord = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            MembershipIdentifier = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            MasterKey = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            PeerRegistrationRecord = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            MembershipIdentifier = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            MasterKey = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueRegistrationCompleteResponse : pb::IMessage<OpaqueRegistrationCompleteResponse>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueRegistrationCompleteResponse> _parser = new pb::MessageParser<OpaqueRegistrationCompleteResponse>(() => new OpaqueRegistrationCompleteResponse());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueRegistrationCompleteResponse> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[3]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationCompleteResponse() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationCompleteResponse(OpaqueRegistrationCompleteResponse other) : this() {\n      result_ = other.result_;\n      message_ = other.message_;\n      sessionKey_ = other.sessionKey_;\n      availableAccounts_ = other.availableAccounts_.Clone();\n      activeAccount_ = other.activeAccount_ != null ? other.activeAccount_.Clone() : null;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRegistrationCompleteResponse Clone() {\n      return new OpaqueRegistrationCompleteResponse(this);\n    }\n\n    /// <summary>Field number for the \"result\" field.</summary>\n    public const int ResultFieldNumber = 1;\n    private global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult result_ = global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult Result {\n      get { return result_; }\n      set {\n        result_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"message\" field.</summary>\n    public const int MessageFieldNumber = 2;\n    private readonly static string MessageDefaultValue = \"\";\n\n    private string message_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public string Message {\n      get { return message_ ?? MessageDefaultValue; }\n      set {\n        message_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n    /// <summary>Gets whether the \"message\" field is set</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool HasMessage {\n      get { return message_ != null; }\n    }\n    /// <summary>Clears the value of the \"message\" field</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void ClearMessage() {\n      message_ = null;\n    }\n\n    /// <summary>Field number for the \"session_key\" field.</summary>\n    public const int SessionKeyFieldNumber = 3;\n    private readonly static pb::ByteString SessionKeyDefaultValue = pb::ByteString.Empty;\n\n    private pb::ByteString sessionKey_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString SessionKey {\n      get { return sessionKey_ ?? SessionKeyDefaultValue; }\n      set {\n        sessionKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n    /// <summary>Gets whether the \"session_key\" field is set</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool HasSessionKey {\n      get { return sessionKey_ != null; }\n    }\n    /// <summary>Clears the value of the \"session_key\" field</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void ClearSessionKey() {\n      sessionKey_ = null;\n    }\n\n    /// <summary>Field number for the \"available_accounts\" field.</summary>\n    public const int AvailableAccountsFieldNumber = 4;\n    private static readonly pb::FieldCodec<global::Ecliptix.Protobuf.Account.Account> _repeated_availableAccounts_codec\n        = pb::FieldCodec.ForMessage(34, global::Ecliptix.Protobuf.Account.Account.Parser);\n    private readonly pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account> availableAccounts_ = new pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account>();\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account> AvailableAccounts {\n      get { return availableAccounts_; }\n    }\n\n    /// <summary>Field number for the \"active_account\" field.</summary>\n    public const int ActiveAccountFieldNumber = 5;\n    private global::Ecliptix.Protobuf.Account.Account activeAccount_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Account.Account ActiveAccount {\n      get { return activeAccount_; }\n      set {\n        activeAccount_ = value;\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueRegistrationCompleteResponse);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueRegistrationCompleteResponse other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (Result != other.Result) return false;\n      if (Message != other.Message) return false;\n      if (SessionKey != other.SessionKey) return false;\n      if(!availableAccounts_.Equals(other.availableAccounts_)) return false;\n      if (!object.Equals(ActiveAccount, other.ActiveAccount)) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded) hash ^= Result.GetHashCode();\n      if (HasMessage) hash ^= Message.GetHashCode();\n      if (HasSessionKey) hash ^= SessionKey.GetHashCode();\n      hash ^= availableAccounts_.GetHashCode();\n      if (activeAccount_ != null) hash ^= ActiveAccount.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded) {\n        output.WriteRawTag(8);\n        output.WriteEnum((int) Result);\n      }\n      if (HasMessage) {\n        output.WriteRawTag(18);\n        output.WriteString(Message);\n      }\n      if (HasSessionKey) {\n        output.WriteRawTag(26);\n        output.WriteBytes(SessionKey);\n      }\n      availableAccounts_.WriteTo(output, _repeated_availableAccounts_codec);\n      if (activeAccount_ != null) {\n        output.WriteRawTag(42);\n        output.WriteMessage(ActiveAccount);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded) {\n        output.WriteRawTag(8);\n        output.WriteEnum((int) Result);\n      }\n      if (HasMessage) {\n        output.WriteRawTag(18);\n        output.WriteString(Message);\n      }\n      if (HasSessionKey) {\n        output.WriteRawTag(26);\n        output.WriteBytes(SessionKey);\n      }\n      availableAccounts_.WriteTo(ref output, _repeated_availableAccounts_codec);\n      if (activeAccount_ != null) {\n        output.WriteRawTag(42);\n        output.WriteMessage(ActiveAccount);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded) {\n        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Result);\n      }\n      if (HasMessage) {\n        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);\n      }\n      if (HasSessionKey) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SessionKey);\n      }\n      size += availableAccounts_.CalculateSize(_repeated_availableAccounts_codec);\n      if (activeAccount_ != null) {\n        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ActiveAccount);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueRegistrationCompleteResponse other) {\n      if (other == null) {\n        return;\n      }\n      if (other.Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded) {\n        Result = other.Result;\n      }\n      if (other.HasMessage) {\n        Message = other.Message;\n      }\n      if (other.HasSessionKey) {\n        SessionKey = other.SessionKey;\n      }\n      availableAccounts_.Add(other.availableAccounts_);\n      if (other.activeAccount_ != null) {\n        if (activeAccount_ == null) {\n          ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();\n        }\n        ActiveAccount.MergeFrom(other.ActiveAccount);\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 8: {\n            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult) input.ReadEnum();\n            break;\n          }\n          case 18: {\n            Message = input.ReadString();\n            break;\n          }\n          case 26: {\n            SessionKey = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            availableAccounts_.AddEntriesFrom(input, _repeated_availableAccounts_codec);\n            break;\n          }\n          case 42: {\n            if (activeAccount_ == null) {\n              ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();\n            }\n            input.ReadMessage(ActiveAccount);\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 8: {\n            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult) input.ReadEnum();\n            break;\n          }\n          case 18: {\n            Message = input.ReadString();\n            break;\n          }\n          case 26: {\n            SessionKey = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            availableAccounts_.AddEntriesFrom(ref input, _repeated_availableAccounts_codec);\n            break;\n          }\n          case 42: {\n            if (activeAccount_ == null) {\n              ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();\n            }\n            input.ReadMessage(ActiveAccount);\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n    #region Nested types\n    /// <summary>Container for nested types declared in the OpaqueRegistrationCompleteResponse message type.</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static partial class Types {\n      public enum RegistrationResult {\n        [pbr::OriginalName(\"SUCCEEDED\")] Succeeded = 0,\n      }\n\n    }\n    #endregion\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueSignInInitRequest : pb::IMessage<OpaqueSignInInitRequest>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueSignInInitRequest> _parser = new pb::MessageParser<OpaqueSignInInitRequest>(() => new OpaqueSignInInitRequest());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueSignInInitRequest> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[4]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInInitRequest() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInInitRequest(OpaqueSignInInitRequest other) : this() {\n      mobileNumber_ = other.mobileNumber_;\n      peerOprf_ = other.peerOprf_;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInInitRequest Clone() {\n      return new OpaqueSignInInitRequest(this);\n    }\n\n    /// <summary>Field number for the \"mobile_number\" field.</summary>\n    public const int MobileNumberFieldNumber = 1;\n    private string mobileNumber_ = \"\";\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public string MobileNumber {\n      get { return mobileNumber_; }\n      set {\n        mobileNumber_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"peer_oprf\" field.</summary>\n    public const int PeerOprfFieldNumber = 2;\n    private pb::ByteString peerOprf_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString PeerOprf {\n      get { return peerOprf_; }\n      set {\n        peerOprf_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueSignInInitRequest);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueSignInInitRequest other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (MobileNumber != other.MobileNumber) return false;\n      if (PeerOprf != other.PeerOprf) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (MobileNumber.Length != 0) hash ^= MobileNumber.GetHashCode();\n      if (PeerOprf.Length != 0) hash ^= PeerOprf.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (MobileNumber.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteString(MobileNumber);\n      }\n      if (PeerOprf.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(PeerOprf);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (MobileNumber.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteString(MobileNumber);\n      }\n      if (PeerOprf.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(PeerOprf);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (MobileNumber.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeStringSize(MobileNumber);\n      }\n      if (PeerOprf.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerOprf);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueSignInInitRequest other) {\n      if (other == null) {\n        return;\n      }\n      if (other.MobileNumber.Length != 0) {\n        MobileNumber = other.MobileNumber;\n      }\n      if (other.PeerOprf.Length != 0) {\n        PeerOprf = other.PeerOprf;\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            MobileNumber = input.ReadString();\n            break;\n          }\n          case 18: {\n            PeerOprf = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            MobileNumber = input.ReadString();\n            break;\n          }\n          case 18: {\n            PeerOprf = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueSignInInitResponse : pb::IMessage<OpaqueSignInInitResponse>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueSignInInitResponse> _parser = new pb::MessageParser<OpaqueSignInInitResponse>(() => new OpaqueSignInInitResponse());\n    private pb::UnknownFieldSet _unknownFields;\n    private int _hasBits0;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueSignInInitResponse> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[5]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInInitResponse() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInInitResponse(OpaqueSignInInitResponse other) : this() {\n      _hasBits0 = other._hasBits0;\n      serverOprfResponse_ = other.serverOprfResponse_;\n      serverEphemeralPublicKey_ = other.serverEphemeralPublicKey_;\n      registrationRecord_ = other.registrationRecord_;\n      serverStateToken_ = other.serverStateToken_;\n      message_ = other.message_;\n      minutesUntilRetry_ = other.minutesUntilRetry_;\n      result_ = other.result_;\n      serverMac_ = other.serverMac_;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInInitResponse Clone() {\n      return new OpaqueSignInInitResponse(this);\n    }\n\n    /// <summary>Field number for the \"server_oprf_response\" field.</summary>\n    public const int ServerOprfResponseFieldNumber = 1;\n    private pb::ByteString serverOprfResponse_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString ServerOprfResponse {\n      get { return serverOprfResponse_; }\n      set {\n        serverOprfResponse_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"server_ephemeral_public_key\" field.</summary>\n    public const int ServerEphemeralPublicKeyFieldNumber = 2;\n    private pb::ByteString serverEphemeralPublicKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString ServerEphemeralPublicKey {\n      get { return serverEphemeralPublicKey_; }\n      set {\n        serverEphemeralPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"registration_record\" field.</summary>\n    public const int RegistrationRecordFieldNumber = 3;\n    private pb::ByteString registrationRecord_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString RegistrationRecord {\n      get { return registrationRecord_; }\n      set {\n        registrationRecord_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"server_state_token\" field.</summary>\n    public const int ServerStateTokenFieldNumber = 4;\n    private pb::ByteString serverStateToken_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString ServerStateToken {\n      get { return serverStateToken_; }\n      set {\n        serverStateToken_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"message\" field.</summary>\n    public const int MessageFieldNumber = 5;\n    private readonly static string MessageDefaultValue = \"\";\n\n    private string message_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public string Message {\n      get { return message_ ?? MessageDefaultValue; }\n      set {\n        message_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n    /// <summary>Gets whether the \"message\" field is set</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool HasMessage {\n      get { return message_ != null; }\n    }\n    /// <summary>Clears the value of the \"message\" field</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void ClearMessage() {\n      message_ = null;\n    }\n\n    /// <summary>Field number for the \"minutes_until_retry\" field.</summary>\n    public const int MinutesUntilRetryFieldNumber = 6;\n    private readonly static int MinutesUntilRetryDefaultValue = 0;\n\n    private int minutesUntilRetry_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int MinutesUntilRetry {\n      get { if ((_hasBits0 & 1) != 0) { return minutesUntilRetry_; } else { return MinutesUntilRetryDefaultValue; } }\n      set {\n        _hasBits0 |= 1;\n        minutesUntilRetry_ = value;\n      }\n    }\n    /// <summary>Gets whether the \"minutes_until_retry\" field is set</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool HasMinutesUntilRetry {\n      get { return (_hasBits0 & 1) != 0; }\n    }\n    /// <summary>Clears the value of the \"minutes_until_retry\" field</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void ClearMinutesUntilRetry() {\n      _hasBits0 &= ~1;\n    }\n\n    /// <summary>Field number for the \"result\" field.</summary>\n    public const int ResultFieldNumber = 7;\n    private global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult result_ = global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult Result {\n      get { return result_; }\n      set {\n        result_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"server_mac\" field.</summary>\n    public const int ServerMacFieldNumber = 8;\n    private pb::ByteString serverMac_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString ServerMac {\n      get { return serverMac_; }\n      set {\n        serverMac_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueSignInInitResponse);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueSignInInitResponse other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (ServerOprfResponse != other.ServerOprfResponse) return false;\n      if (ServerEphemeralPublicKey != other.ServerEphemeralPublicKey) return false;\n      if (RegistrationRecord != other.RegistrationRecord) return false;\n      if (ServerStateToken != other.ServerStateToken) return false;\n      if (Message != other.Message) return false;\n      if (MinutesUntilRetry != other.MinutesUntilRetry) return false;\n      if (Result != other.Result) return false;\n      if (ServerMac != other.ServerMac) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (ServerOprfResponse.Length != 0) hash ^= ServerOprfResponse.GetHashCode();\n      if (ServerEphemeralPublicKey.Length != 0) hash ^= ServerEphemeralPublicKey.GetHashCode();\n      if (RegistrationRecord.Length != 0) hash ^= RegistrationRecord.GetHashCode();\n      if (ServerStateToken.Length != 0) hash ^= ServerStateToken.GetHashCode();\n      if (HasMessage) hash ^= Message.GetHashCode();\n      if (HasMinutesUntilRetry) hash ^= MinutesUntilRetry.GetHashCode();\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded) hash ^= Result.GetHashCode();\n      if (ServerMac.Length != 0) hash ^= ServerMac.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (ServerOprfResponse.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(ServerOprfResponse);\n      }\n      if (ServerEphemeralPublicKey.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(ServerEphemeralPublicKey);\n      }\n      if (RegistrationRecord.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(RegistrationRecord);\n      }\n      if (ServerStateToken.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(ServerStateToken);\n      }\n      if (HasMessage) {\n        output.WriteRawTag(42);\n        output.WriteString(Message);\n      }\n      if (HasMinutesUntilRetry) {\n        output.WriteRawTag(48);\n        output.WriteInt32(MinutesUntilRetry);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded) {\n        output.WriteRawTag(56);\n        output.WriteEnum((int) Result);\n      }\n      if (ServerMac.Length != 0) {\n        output.WriteRawTag(66);\n        output.WriteBytes(ServerMac);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (ServerOprfResponse.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(ServerOprfResponse);\n      }\n      if (ServerEphemeralPublicKey.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(ServerEphemeralPublicKey);\n      }\n      if (RegistrationRecord.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(RegistrationRecord);\n      }\n      if (ServerStateToken.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(ServerStateToken);\n      }\n      if (HasMessage) {\n        output.WriteRawTag(42);\n        output.WriteString(Message);\n      }\n      if (HasMinutesUntilRetry) {\n        output.WriteRawTag(48);\n        output.WriteInt32(MinutesUntilRetry);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded) {\n        output.WriteRawTag(56);\n        output.WriteEnum((int) Result);\n      }\n      if (ServerMac.Length != 0) {\n        output.WriteRawTag(66);\n        output.WriteBytes(ServerMac);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (ServerOprfResponse.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerOprfResponse);\n      }\n      if (ServerEphemeralPublicKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerEphemeralPublicKey);\n      }\n      if (RegistrationRecord.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RegistrationRecord);\n      }\n      if (ServerStateToken.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerStateToken);\n      }\n      if (HasMessage) {\n        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);\n      }\n      if (HasMinutesUntilRetry) {\n        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinutesUntilRetry);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded) {\n        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Result);\n      }\n      if (ServerMac.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerMac);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueSignInInitResponse other) {\n      if (other == null) {\n        return;\n      }\n      if (other.ServerOprfResponse.Length != 0) {\n        ServerOprfResponse = other.ServerOprfResponse;\n      }\n      if (other.ServerEphemeralPublicKey.Length != 0) {\n        ServerEphemeralPublicKey = other.ServerEphemeralPublicKey;\n      }\n      if (other.RegistrationRecord.Length != 0) {\n        RegistrationRecord = other.RegistrationRecord;\n      }\n      if (other.ServerStateToken.Length != 0) {\n        ServerStateToken = other.ServerStateToken;\n      }\n      if (other.HasMessage) {\n        Message = other.Message;\n      }\n      if (other.HasMinutesUntilRetry) {\n        MinutesUntilRetry = other.MinutesUntilRetry;\n      }\n      if (other.Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded) {\n        Result = other.Result;\n      }\n      if (other.ServerMac.Length != 0) {\n        ServerMac = other.ServerMac;\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            ServerOprfResponse = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            ServerEphemeralPublicKey = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            RegistrationRecord = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            ServerStateToken = input.ReadBytes();\n            break;\n          }\n          case 42: {\n            Message = input.ReadString();\n            break;\n          }\n          case 48: {\n            MinutesUntilRetry = input.ReadInt32();\n            break;\n          }\n          case 56: {\n            Result = (global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult) input.ReadEnum();\n            break;\n          }\n          case 66: {\n            ServerMac = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            ServerOprfResponse = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            ServerEphemeralPublicKey = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            RegistrationRecord = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            ServerStateToken = input.ReadBytes();\n            break;\n          }\n          case 42: {\n            Message = input.ReadString();\n            break;\n          }\n          case 48: {\n            MinutesUntilRetry = input.ReadInt32();\n            break;\n          }\n          case 56: {\n            Result = (global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult) input.ReadEnum();\n            break;\n          }\n          case 66: {\n            ServerMac = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n    #region Nested types\n    /// <summary>Container for nested types declared in the OpaqueSignInInitResponse message type.</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static partial class Types {\n      public enum SignInResult {\n        [pbr::OriginalName(\"SUCCEEDED\")] Succeeded = 0,\n        [pbr::OriginalName(\"INVALID_CREDENTIALS\")] InvalidCredentials = 1,\n        [pbr::OriginalName(\"LOGIN_ATTEMPT_EXCEEDED\")] LoginAttemptExceeded = 2,\n      }\n\n    }\n    #endregion\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueSignInFinalizeRequest : pb::IMessage<OpaqueSignInFinalizeRequest>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueSignInFinalizeRequest> _parser = new pb::MessageParser<OpaqueSignInFinalizeRequest>(() => new OpaqueSignInFinalizeRequest());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueSignInFinalizeRequest> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[6]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInFinalizeRequest() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInFinalizeRequest(OpaqueSignInFinalizeRequest other) : this() {\n      mobileNumber_ = other.mobileNumber_;\n      clientEphemeralPublicKey_ = other.clientEphemeralPublicKey_;\n      clientMac_ = other.clientMac_;\n      serverStateToken_ = other.serverStateToken_;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInFinalizeRequest Clone() {\n      return new OpaqueSignInFinalizeRequest(this);\n    }\n\n    /// <summary>Field number for the \"mobile_number\" field.</summary>\n    public const int MobileNumberFieldNumber = 1;\n    private string mobileNumber_ = \"\";\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public string MobileNumber {\n      get { return mobileNumber_; }\n      set {\n        mobileNumber_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"client_ephemeral_public_key\" field.</summary>\n    public const int ClientEphemeralPublicKeyFieldNumber = 2;\n    private pb::ByteString clientEphemeralPublicKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString ClientEphemeralPublicKey {\n      get { return clientEphemeralPublicKey_; }\n      set {\n        clientEphemeralPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"client_mac\" field.</summary>\n    public const int ClientMacFieldNumber = 3;\n    private pb::ByteString clientMac_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString ClientMac {\n      get { return clientMac_; }\n      set {\n        clientMac_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"server_state_token\" field.</summary>\n    public const int ServerStateTokenFieldNumber = 4;\n    private pb::ByteString serverStateToken_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString ServerStateToken {\n      get { return serverStateToken_; }\n      set {\n        serverStateToken_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueSignInFinalizeRequest);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueSignInFinalizeRequest other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (MobileNumber != other.MobileNumber) return false;\n      if (ClientEphemeralPublicKey != other.ClientEphemeralPublicKey) return false;\n      if (ClientMac != other.ClientMac) return false;\n      if (ServerStateToken != other.ServerStateToken) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (MobileNumber.Length != 0) hash ^= MobileNumber.GetHashCode();\n      if (ClientEphemeralPublicKey.Length != 0) hash ^= ClientEphemeralPublicKey.GetHashCode();\n      if (ClientMac.Length != 0) hash ^= ClientMac.GetHashCode();\n      if (ServerStateToken.Length != 0) hash ^= ServerStateToken.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (MobileNumber.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteString(MobileNumber);\n      }\n      if (ClientEphemeralPublicKey.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(ClientEphemeralPublicKey);\n      }\n      if (ClientMac.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(ClientMac);\n      }\n      if (ServerStateToken.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(ServerStateToken);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (MobileNumber.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteString(MobileNumber);\n      }\n      if (ClientEphemeralPublicKey.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(ClientEphemeralPublicKey);\n      }\n      if (ClientMac.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(ClientMac);\n      }\n      if (ServerStateToken.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(ServerStateToken);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (MobileNumber.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeStringSize(MobileNumber);\n      }\n      if (ClientEphemeralPublicKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ClientEphemeralPublicKey);\n      }\n      if (ClientMac.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ClientMac);\n      }\n      if (ServerStateToken.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerStateToken);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueSignInFinalizeRequest other) {\n      if (other == null) {\n        return;\n      }\n      if (other.MobileNumber.Length != 0) {\n        MobileNumber = other.MobileNumber;\n      }\n      if (other.ClientEphemeralPublicKey.Length != 0) {\n        ClientEphemeralPublicKey = other.ClientEphemeralPublicKey;\n      }\n      if (other.ClientMac.Length != 0) {\n        ClientMac = other.ClientMac;\n      }\n      if (other.ServerStateToken.Length != 0) {\n        ServerStateToken = other.ServerStateToken;\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            MobileNumber = input.ReadString();\n            break;\n          }\n          case 18: {\n            ClientEphemeralPublicKey = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            ClientMac = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            ServerStateToken = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            MobileNumber = input.ReadString();\n            break;\n          }\n          case 18: {\n            ClientEphemeralPublicKey = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            ClientMac = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            ServerStateToken = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueSignInFinalizeResponse : pb::IMessage<OpaqueSignInFinalizeResponse>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueSignInFinalizeResponse> _parser = new pb::MessageParser<OpaqueSignInFinalizeResponse>(() => new OpaqueSignInFinalizeResponse());\n    private pb::UnknownFieldSet _unknownFields;\n    private int _hasBits0;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueSignInFinalizeResponse> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[7]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInFinalizeResponse() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInFinalizeResponse(OpaqueSignInFinalizeResponse other) : this() {\n      _hasBits0 = other._hasBits0;\n      serverMac_ = other.serverMac_;\n      membership_ = other.membership_ != null ? other.membership_.Clone() : null;\n      result_ = other.result_;\n      message_ = other.message_;\n      minutesUntilRetry_ = other.minutesUntilRetry_;\n      availableAccounts_ = other.availableAccounts_.Clone();\n      activeAccount_ = other.activeAccount_ != null ? other.activeAccount_.Clone() : null;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueSignInFinalizeResponse Clone() {\n      return new OpaqueSignInFinalizeResponse(this);\n    }\n\n    /// <summary>Field number for the \"server_mac\" field.</summary>\n    public const int ServerMacFieldNumber = 1;\n    private pb::ByteString serverMac_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString ServerMac {\n      get { return serverMac_; }\n      set {\n        serverMac_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"membership\" field.</summary>\n    public const int MembershipFieldNumber = 2;\n    private global::Ecliptix.Protobuf.Membership.Membership membership_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Membership.Membership Membership {\n      get { return membership_; }\n      set {\n        membership_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"result\" field.</summary>\n    public const int ResultFieldNumber = 3;\n    private global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult result_ = global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult Result {\n      get { return result_; }\n      set {\n        result_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"message\" field.</summary>\n    public const int MessageFieldNumber = 4;\n    private readonly static string MessageDefaultValue = \"\";\n\n    private string message_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public string Message {\n      get { return message_ ?? MessageDefaultValue; }\n      set {\n        message_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n    /// <summary>Gets whether the \"message\" field is set</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool HasMessage {\n      get { return message_ != null; }\n    }\n    /// <summary>Clears the value of the \"message\" field</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void ClearMessage() {\n      message_ = null;\n    }\n\n    /// <summary>Field number for the \"minutes_until_retry\" field.</summary>\n    public const int MinutesUntilRetryFieldNumber = 5;\n    private readonly static int MinutesUntilRetryDefaultValue = 0;\n\n    private int minutesUntilRetry_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int MinutesUntilRetry {\n      get { if ((_hasBits0 & 1) != 0) { return minutesUntilRetry_; } else { return MinutesUntilRetryDefaultValue; } }\n      set {\n        _hasBits0 |= 1;\n        minutesUntilRetry_ = value;\n      }\n    }\n    /// <summary>Gets whether the \"minutes_until_retry\" field is set</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool HasMinutesUntilRetry {\n      get { return (_hasBits0 & 1) != 0; }\n    }\n    /// <summary>Clears the value of the \"minutes_until_retry\" field</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void ClearMinutesUntilRetry() {\n      _hasBits0 &= ~1;\n    }\n\n    /// <summary>Field number for the \"available_accounts\" field.</summary>\n    public const int AvailableAccountsFieldNumber = 6;\n    private static readonly pb::FieldCodec<global::Ecliptix.Protobuf.Account.Account> _repeated_availableAccounts_codec\n        = pb::FieldCodec.ForMessage(50, global::Ecliptix.Protobuf.Account.Account.Parser);\n    private readonly pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account> availableAccounts_ = new pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account>();\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account> AvailableAccounts {\n      get { return availableAccounts_; }\n    }\n\n    /// <summary>Field number for the \"active_account\" field.</summary>\n    public const int ActiveAccountFieldNumber = 7;\n    private global::Ecliptix.Protobuf.Account.Account activeAccount_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Account.Account ActiveAccount {\n      get { return activeAccount_; }\n      set {\n        activeAccount_ = value;\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueSignInFinalizeResponse);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueSignInFinalizeResponse other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (ServerMac != other.ServerMac) return false;\n      if (!object.Equals(Membership, other.Membership)) return false;\n      if (Result != other.Result) return false;\n      if (Message != other.Message) return false;\n      if (MinutesUntilRetry != other.MinutesUntilRetry) return false;\n      if(!availableAccounts_.Equals(other.availableAccounts_)) return false;\n      if (!object.Equals(ActiveAccount, other.ActiveAccount)) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (ServerMac.Length != 0) hash ^= ServerMac.GetHashCode();\n      if (membership_ != null) hash ^= Membership.GetHashCode();\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded) hash ^= Result.GetHashCode();\n      if (HasMessage) hash ^= Message.GetHashCode();\n      if (HasMinutesUntilRetry) hash ^= MinutesUntilRetry.GetHashCode();\n      hash ^= availableAccounts_.GetHashCode();\n      if (activeAccount_ != null) hash ^= ActiveAccount.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (ServerMac.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(ServerMac);\n      }\n      if (membership_ != null) {\n        output.WriteRawTag(18);\n        output.WriteMessage(Membership);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded) {\n        output.WriteRawTag(24);\n        output.WriteEnum((int) Result);\n      }\n      if (HasMessage) {\n        output.WriteRawTag(34);\n        output.WriteString(Message);\n      }\n      if (HasMinutesUntilRetry) {\n        output.WriteRawTag(40);\n        output.WriteInt32(MinutesUntilRetry);\n      }\n      availableAccounts_.WriteTo(output, _repeated_availableAccounts_codec);\n      if (activeAccount_ != null) {\n        output.WriteRawTag(58);\n        output.WriteMessage(ActiveAccount);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (ServerMac.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(ServerMac);\n      }\n      if (membership_ != null) {\n        output.WriteRawTag(18);\n        output.WriteMessage(Membership);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded) {\n        output.WriteRawTag(24);\n        output.WriteEnum((int) Result);\n      }\n      if (HasMessage) {\n        output.WriteRawTag(34);\n        output.WriteString(Message);\n      }\n      if (HasMinutesUntilRetry) {\n        output.WriteRawTag(40);\n        output.WriteInt32(MinutesUntilRetry);\n      }\n      availableAccounts_.WriteTo(ref output, _repeated_availableAccounts_codec);\n      if (activeAccount_ != null) {\n        output.WriteRawTag(58);\n        output.WriteMessage(ActiveAccount);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (ServerMac.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerMac);\n      }\n      if (membership_ != null) {\n        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Membership);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded) {\n        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Result);\n      }\n      if (HasMessage) {\n        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);\n      }\n      if (HasMinutesUntilRetry) {\n        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinutesUntilRetry);\n      }\n      size += availableAccounts_.CalculateSize(_repeated_availableAccounts_codec);\n      if (activeAccount_ != null) {\n        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ActiveAccount);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueSignInFinalizeResponse other) {\n      if (other == null) {\n        return;\n      }\n      if (other.ServerMac.Length != 0) {\n        ServerMac = other.ServerMac;\n      }\n      if (other.membership_ != null) {\n        if (membership_ == null) {\n          Membership = new global::Ecliptix.Protobuf.Membership.Membership();\n        }\n        Membership.MergeFrom(other.Membership);\n      }\n      if (other.Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded) {\n        Result = other.Result;\n      }\n      if (other.HasMessage) {\n        Message = other.Message;\n      }\n      if (other.HasMinutesUntilRetry) {\n        MinutesUntilRetry = other.MinutesUntilRetry;\n      }\n      availableAccounts_.Add(other.availableAccounts_);\n      if (other.activeAccount_ != null) {\n        if (activeAccount_ == null) {\n          ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();\n        }\n        ActiveAccount.MergeFrom(other.ActiveAccount);\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            ServerMac = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            if (membership_ == null) {\n              Membership = new global::Ecliptix.Protobuf.Membership.Membership();\n            }\n            input.ReadMessage(Membership);\n            break;\n          }\n          case 24: {\n            Result = (global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult) input.ReadEnum();\n            break;\n          }\n          case 34: {\n            Message = input.ReadString();\n            break;\n          }\n          case 40: {\n            MinutesUntilRetry = input.ReadInt32();\n            break;\n          }\n          case 50: {\n            availableAccounts_.AddEntriesFrom(input, _repeated_availableAccounts_codec);\n            break;\n          }\n          case 58: {\n            if (activeAccount_ == null) {\n              ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();\n            }\n            input.ReadMessage(ActiveAccount);\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            ServerMac = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            if (membership_ == null) {\n              Membership = new global::Ecliptix.Protobuf.Membership.Membership();\n            }\n            input.ReadMessage(Membership);\n            break;\n          }\n          case 24: {\n            Result = (global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult) input.ReadEnum();\n            break;\n          }\n          case 34: {\n            Message = input.ReadString();\n            break;\n          }\n          case 40: {\n            MinutesUntilRetry = input.ReadInt32();\n            break;\n          }\n          case 50: {\n            availableAccounts_.AddEntriesFrom(ref input, _repeated_availableAccounts_codec);\n            break;\n          }\n          case 58: {\n            if (activeAccount_ == null) {\n              ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();\n            }\n            input.ReadMessage(ActiveAccount);\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n    #region Nested types\n    /// <summary>Container for nested types declared in the OpaqueSignInFinalizeResponse message type.</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static partial class Types {\n      public enum SignInResult {\n        [pbr::OriginalName(\"SUCCEEDED\")] Succeeded = 0,\n        [pbr::OriginalName(\"INVALID_CREDENTIALS\")] InvalidCredentials = 1,\n        [pbr::OriginalName(\"LOGIN_ATTEMPT_EXCEEDED\")] LoginAttemptExceeded = 2,\n      }\n\n    }\n    #endregion\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueRecoverySecureKeyInitRequest : pb::IMessage<OpaqueRecoverySecureKeyInitRequest>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueRecoverySecureKeyInitRequest> _parser = new pb::MessageParser<OpaqueRecoverySecureKeyInitRequest>(() => new OpaqueRecoverySecureKeyInitRequest());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueRecoverySecureKeyInitRequest> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[8]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecureKeyInitRequest() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecureKeyInitRequest(OpaqueRecoverySecureKeyInitRequest other) : this() {\n      peerOprf_ = other.peerOprf_;\n      membershipIdentifier_ = other.membershipIdentifier_;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecureKeyInitRequest Clone() {\n      return new OpaqueRecoverySecureKeyInitRequest(this);\n    }\n\n    /// <summary>Field number for the \"peer_oprf\" field.</summary>\n    public const int PeerOprfFieldNumber = 1;\n    private pb::ByteString peerOprf_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString PeerOprf {\n      get { return peerOprf_; }\n      set {\n        peerOprf_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"membership_identifier\" field.</summary>\n    public const int MembershipIdentifierFieldNumber = 2;\n    private pb::ByteString membershipIdentifier_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString MembershipIdentifier {\n      get { return membershipIdentifier_; }\n      set {\n        membershipIdentifier_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueRecoverySecureKeyInitRequest);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueRecoverySecureKeyInitRequest other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (PeerOprf != other.PeerOprf) return false;\n      if (MembershipIdentifier != other.MembershipIdentifier) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (PeerOprf.Length != 0) hash ^= PeerOprf.GetHashCode();\n      if (MembershipIdentifier.Length != 0) hash ^= MembershipIdentifier.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (PeerOprf.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerOprf);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(MembershipIdentifier);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (PeerOprf.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerOprf);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(MembershipIdentifier);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (PeerOprf.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerOprf);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MembershipIdentifier);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueRecoverySecureKeyInitRequest other) {\n      if (other == null) {\n        return;\n      }\n      if (other.PeerOprf.Length != 0) {\n        PeerOprf = other.PeerOprf;\n      }\n      if (other.MembershipIdentifier.Length != 0) {\n        MembershipIdentifier = other.MembershipIdentifier;\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            PeerOprf = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            MembershipIdentifier = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            PeerOprf = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            MembershipIdentifier = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueRecoverySecureKeyInitResponse : pb::IMessage<OpaqueRecoverySecureKeyInitResponse>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueRecoverySecureKeyInitResponse> _parser = new pb::MessageParser<OpaqueRecoverySecureKeyInitResponse>(() => new OpaqueRecoverySecureKeyInitResponse());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueRecoverySecureKeyInitResponse> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[9]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecureKeyInitResponse() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecureKeyInitResponse(OpaqueRecoverySecureKeyInitResponse other) : this() {\n      peerOprf_ = other.peerOprf_;\n      result_ = other.result_;\n      message_ = other.message_;\n      membership_ = other.membership_ != null ? other.membership_.Clone() : null;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecureKeyInitResponse Clone() {\n      return new OpaqueRecoverySecureKeyInitResponse(this);\n    }\n\n    /// <summary>Field number for the \"peer_oprf\" field.</summary>\n    public const int PeerOprfFieldNumber = 1;\n    private pb::ByteString peerOprf_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString PeerOprf {\n      get { return peerOprf_; }\n      set {\n        peerOprf_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"result\" field.</summary>\n    public const int ResultFieldNumber = 2;\n    private global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult result_ = global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult Result {\n      get { return result_; }\n      set {\n        result_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"message\" field.</summary>\n    public const int MessageFieldNumber = 3;\n    private readonly static string MessageDefaultValue = \"\";\n\n    private string message_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public string Message {\n      get { return message_ ?? MessageDefaultValue; }\n      set {\n        message_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n    /// <summary>Gets whether the \"message\" field is set</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool HasMessage {\n      get { return message_ != null; }\n    }\n    /// <summary>Clears the value of the \"message\" field</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void ClearMessage() {\n      message_ = null;\n    }\n\n    /// <summary>Field number for the \"membership\" field.</summary>\n    public const int MembershipFieldNumber = 4;\n    private global::Ecliptix.Protobuf.Membership.Membership membership_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Ecliptix.Protobuf.Membership.Membership Membership {\n      get { return membership_; }\n      set {\n        membership_ = value;\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueRecoverySecureKeyInitResponse);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueRecoverySecureKeyInitResponse other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (PeerOprf != other.PeerOprf) return false;\n      if (Result != other.Result) return false;\n      if (Message != other.Message) return false;\n      if (!object.Equals(Membership, other.Membership)) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (PeerOprf.Length != 0) hash ^= PeerOprf.GetHashCode();\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded) hash ^= Result.GetHashCode();\n      if (HasMessage) hash ^= Message.GetHashCode();\n      if (membership_ != null) hash ^= Membership.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (PeerOprf.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerOprf);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded) {\n        output.WriteRawTag(16);\n        output.WriteEnum((int) Result);\n      }\n      if (HasMessage) {\n        output.WriteRawTag(26);\n        output.WriteString(Message);\n      }\n      if (membership_ != null) {\n        output.WriteRawTag(34);\n        output.WriteMessage(Membership);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (PeerOprf.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerOprf);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded) {\n        output.WriteRawTag(16);\n        output.WriteEnum((int) Result);\n      }\n      if (HasMessage) {\n        output.WriteRawTag(26);\n        output.WriteString(Message);\n      }\n      if (membership_ != null) {\n        output.WriteRawTag(34);\n        output.WriteMessage(Membership);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (PeerOprf.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerOprf);\n      }\n      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded) {\n        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Result);\n      }\n      if (HasMessage) {\n        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);\n      }\n      if (membership_ != null) {\n        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Membership);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueRecoverySecureKeyInitResponse other) {\n      if (other == null) {\n        return;\n      }\n      if (other.PeerOprf.Length != 0) {\n        PeerOprf = other.PeerOprf;\n      }\n      if (other.Result != global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded) {\n        Result = other.Result;\n      }\n      if (other.HasMessage) {\n        Message = other.Message;\n      }\n      if (other.membership_ != null) {\n        if (membership_ == null) {\n          Membership = new global::Ecliptix.Protobuf.Membership.Membership();\n        }\n        Membership.MergeFrom(other.Membership);\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            PeerOprf = input.ReadBytes();\n            break;\n          }\n          case 16: {\n            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult) input.ReadEnum();\n            break;\n          }\n          case 26: {\n            Message = input.ReadString();\n            break;\n          }\n          case 34: {\n            if (membership_ == null) {\n              Membership = new global::Ecliptix.Protobuf.Membership.Membership();\n            }\n            input.ReadMessage(Membership);\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            PeerOprf = input.ReadBytes();\n            break;\n          }\n          case 16: {\n            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult) input.ReadEnum();\n            break;\n          }\n          case 26: {\n            Message = input.ReadString();\n            break;\n          }\n          case 34: {\n            if (membership_ == null) {\n              Membership = new global::Ecliptix.Protobuf.Membership.Membership();\n            }\n            input.ReadMessage(Membership);\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n    #region Nested types\n    /// <summary>Container for nested types declared in the OpaqueRecoverySecureKeyInitResponse message type.</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static partial class Types {\n      public enum RecoveryResult {\n        [pbr::OriginalName(\"SUCCEEDED\")] Succeeded = 0,\n        [pbr::OriginalName(\"INVALID_CREDENTIALS\")] InvalidCredentials = 1,\n      }\n\n    }\n    #endregion\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueRecoverySecretKeyCompleteRequest : pb::IMessage<OpaqueRecoverySecretKeyCompleteRequest>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueRecoverySecretKeyCompleteRequest> _parser = new pb::MessageParser<OpaqueRecoverySecretKeyCompleteRequest>(() => new OpaqueRecoverySecretKeyCompleteRequest());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueRecoverySecretKeyCompleteRequest> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[10]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecretKeyCompleteRequest() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecretKeyCompleteRequest(OpaqueRecoverySecretKeyCompleteRequest other) : this() {\n      peerRecoveryRecord_ = other.peerRecoveryRecord_;\n      membershipIdentifier_ = other.membershipIdentifier_;\n      masterKey_ = other.masterKey_;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecretKeyCompleteRequest Clone() {\n      return new OpaqueRecoverySecretKeyCompleteRequest(this);\n    }\n\n    /// <summary>Field number for the \"peer_recovery_record\" field.</summary>\n    public const int PeerRecoveryRecordFieldNumber = 1;\n    private pb::ByteString peerRecoveryRecord_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString PeerRecoveryRecord {\n      get { return peerRecoveryRecord_; }\n      set {\n        peerRecoveryRecord_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"membership_identifier\" field.</summary>\n    public const int MembershipIdentifierFieldNumber = 2;\n    private pb::ByteString membershipIdentifier_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString MembershipIdentifier {\n      get { return membershipIdentifier_; }\n      set {\n        membershipIdentifier_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"master_key\" field.</summary>\n    public const int MasterKeyFieldNumber = 3;\n    private pb::ByteString masterKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString MasterKey {\n      get { return masterKey_; }\n      set {\n        masterKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueRecoverySecretKeyCompleteRequest);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueRecoverySecretKeyCompleteRequest other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (PeerRecoveryRecord != other.PeerRecoveryRecord) return false;\n      if (MembershipIdentifier != other.MembershipIdentifier) return false;\n      if (MasterKey != other.MasterKey) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (PeerRecoveryRecord.Length != 0) hash ^= PeerRecoveryRecord.GetHashCode();\n      if (MembershipIdentifier.Length != 0) hash ^= MembershipIdentifier.GetHashCode();\n      if (MasterKey.Length != 0) hash ^= MasterKey.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (PeerRecoveryRecord.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerRecoveryRecord);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(MembershipIdentifier);\n      }\n      if (MasterKey.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(MasterKey);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (PeerRecoveryRecord.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(PeerRecoveryRecord);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(MembershipIdentifier);\n      }\n      if (MasterKey.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(MasterKey);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (PeerRecoveryRecord.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerRecoveryRecord);\n      }\n      if (MembershipIdentifier.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MembershipIdentifier);\n      }\n      if (MasterKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MasterKey);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueRecoverySecretKeyCompleteRequest other) {\n      if (other == null) {\n        return;\n      }\n      if (other.PeerRecoveryRecord.Length != 0) {\n        PeerRecoveryRecord = other.PeerRecoveryRecord;\n      }\n      if (other.MembershipIdentifier.Length != 0) {\n        MembershipIdentifier = other.MembershipIdentifier;\n      }\n      if (other.MasterKey.Length != 0) {\n        MasterKey = other.MasterKey;\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            PeerRecoveryRecord = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            MembershipIdentifier = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            MasterKey = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            PeerRecoveryRecord = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            MembershipIdentifier = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            MasterKey = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class OpaqueRecoverySecretKeyCompleteResponse : pb::IMessage<OpaqueRecoverySecretKeyCompleteResponse>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<OpaqueRecoverySecretKeyCompleteResponse> _parser = new pb::MessageParser<OpaqueRecoverySecretKeyCompleteResponse>(() => new OpaqueRecoverySecretKeyCompleteResponse());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<OpaqueRecoverySecretKeyCompleteResponse> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[11]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecretKeyCompleteResponse() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecretKeyCompleteResponse(OpaqueRecoverySecretKeyCompleteResponse other) : this() {\n      message_ = other.message_;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public OpaqueRecoverySecretKeyCompleteResponse Clone() {\n      return new OpaqueRecoverySecretKeyCompleteResponse(this);\n    }\n\n    /// <summary>Field number for the \"message\" field.</summary>\n    public const int MessageFieldNumber = 1;\n    private readonly static string MessageDefaultValue = \"\";\n\n    private string message_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public string Message {\n      get { return message_ ?? MessageDefaultValue; }\n      set {\n        message_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n    /// <summary>Gets whether the \"message\" field is set</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool HasMessage {\n      get { return message_ != null; }\n    }\n    /// <summary>Clears the value of the \"message\" field</summary>\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void ClearMessage() {\n      message_ = null;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as OpaqueRecoverySecretKeyCompleteResponse);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(OpaqueRecoverySecretKeyCompleteResponse other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (Message != other.Message) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (HasMessage) hash ^= Message.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (HasMessage) {\n        output.WriteRawTag(10);\n        output.WriteString(Message);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (HasMessage) {\n        output.WriteRawTag(10);\n        output.WriteString(Message);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (HasMessage) {\n        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(OpaqueRecoverySecretKeyCompleteResponse other) {\n      if (other == null) {\n        return;\n      }\n      if (other.HasMessage) {\n        Message = other.Message;\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            Message = input.ReadString();\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            Message = input.ReadString();\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class AkeServerState : pb::IMessage<AkeServerState>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<AkeServerState> _parser = new pb::MessageParser<AkeServerState>(() => new AkeServerState());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<AkeServerState> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[12]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public AkeServerState() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public AkeServerState(AkeServerState other) : this() {\n      serverEphemeralPrivateKeyBytes_ = other.serverEphemeralPrivateKeyBytes_;\n      serverEphemeralPublicKey_ = other.serverEphemeralPublicKey_;\n      clientStaticPublicKey_ = other.clientStaticPublicKey_;\n      oprfResponse_ = other.oprfResponse_;\n      username_ = other.username_;\n      registrationRecord_ = other.registrationRecord_;\n      expiration_ = other.expiration_ != null ? other.expiration_.Clone() : null;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public AkeServerState Clone() {\n      return new AkeServerState(this);\n    }\n\n    /// <summary>Field number for the \"server_ephemeral_private_key_bytes\" field.</summary>\n    public const int ServerEphemeralPrivateKeyBytesFieldNumber = 1;\n    private pb::ByteString serverEphemeralPrivateKeyBytes_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString ServerEphemeralPrivateKeyBytes {\n      get { return serverEphemeralPrivateKeyBytes_; }\n      set {\n        serverEphemeralPrivateKeyBytes_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"server_ephemeral_public_key\" field.</summary>\n    public const int ServerEphemeralPublicKeyFieldNumber = 2;\n    private pb::ByteString serverEphemeralPublicKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString ServerEphemeralPublicKey {\n      get { return serverEphemeralPublicKey_; }\n      set {\n        serverEphemeralPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"client_static_public_key\" field.</summary>\n    public const int ClientStaticPublicKeyFieldNumber = 3;\n    private pb::ByteString clientStaticPublicKey_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString ClientStaticPublicKey {\n      get { return clientStaticPublicKey_; }\n      set {\n        clientStaticPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"oprf_response\" field.</summary>\n    public const int OprfResponseFieldNumber = 4;\n    private pb::ByteString oprfResponse_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString OprfResponse {\n      get { return oprfResponse_; }\n      set {\n        oprfResponse_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"username\" field.</summary>\n    public const int UsernameFieldNumber = 5;\n    private string username_ = \"\";\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public string Username {\n      get { return username_; }\n      set {\n        username_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"registration_record\" field.</summary>\n    public const int RegistrationRecordFieldNumber = 6;\n    private pb::ByteString registrationRecord_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public pb::ByteString RegistrationRecord {\n      get { return registrationRecord_; }\n      set {\n        registrationRecord_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"expiration\" field.</summary>\n    public const int ExpirationFieldNumber = 7;\n    private global::Google.Protobuf.WellKnownTypes.Timestamp expiration_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Google.Protobuf.WellKnownTypes.Timestamp Expiration {\n      get { return expiration_; }\n      set {\n        expiration_ = value;\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as AkeServerState);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(AkeServerState other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (ServerEphemeralPrivateKeyBytes != other.ServerEphemeralPrivateKeyBytes) return false;\n      if (ServerEphemeralPublicKey != other.ServerEphemeralPublicKey) return false;\n      if (ClientStaticPublicKey != other.ClientStaticPublicKey) return false;\n      if (OprfResponse != other.OprfResponse) return false;\n      if (Username != other.Username) return false;\n      if (RegistrationRecord != other.RegistrationRecord) return false;\n      if (!object.Equals(Expiration, other.Expiration)) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (ServerEphemeralPrivateKeyBytes.Length != 0) hash ^= ServerEphemeralPrivateKeyBytes.GetHashCode();\n      if (ServerEphemeralPublicKey.Length != 0) hash ^= ServerEphemeralPublicKey.GetHashCode();\n      if (ClientStaticPublicKey.Length != 0) hash ^= ClientStaticPublicKey.GetHashCode();\n      if (OprfResponse.Length != 0) hash ^= OprfResponse.GetHashCode();\n      if (Username.Length != 0) hash ^= Username.GetHashCode();\n      if (RegistrationRecord.Length != 0) hash ^= RegistrationRecord.GetHashCode();\n      if (expiration_ != null) hash ^= Expiration.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (ServerEphemeralPrivateKeyBytes.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(ServerEphemeralPrivateKeyBytes);\n      }\n      if (ServerEphemeralPublicKey.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(ServerEphemeralPublicKey);\n      }\n      if (ClientStaticPublicKey.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(ClientStaticPublicKey);\n      }\n      if (OprfResponse.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(OprfResponse);\n      }\n      if (Username.Length != 0) {\n        output.WriteRawTag(42);\n        output.WriteString(Username);\n      }\n      if (RegistrationRecord.Length != 0) {\n        output.WriteRawTag(50);\n        output.WriteBytes(RegistrationRecord);\n      }\n      if (expiration_ != null) {\n        output.WriteRawTag(58);\n        output.WriteMessage(Expiration);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (ServerEphemeralPrivateKeyBytes.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteBytes(ServerEphemeralPrivateKeyBytes);\n      }\n      if (ServerEphemeralPublicKey.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(ServerEphemeralPublicKey);\n      }\n      if (ClientStaticPublicKey.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(ClientStaticPublicKey);\n      }\n      if (OprfResponse.Length != 0) {\n        output.WriteRawTag(34);\n        output.WriteBytes(OprfResponse);\n      }\n      if (Username.Length != 0) {\n        output.WriteRawTag(42);\n        output.WriteString(Username);\n      }\n      if (RegistrationRecord.Length != 0) {\n        output.WriteRawTag(50);\n        output.WriteBytes(RegistrationRecord);\n      }\n      if (expiration_ != null) {\n        output.WriteRawTag(58);\n        output.WriteMessage(Expiration);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (ServerEphemeralPrivateKeyBytes.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerEphemeralPrivateKeyBytes);\n      }\n      if (ServerEphemeralPublicKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerEphemeralPublicKey);\n      }\n      if (ClientStaticPublicKey.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ClientStaticPublicKey);\n      }\n      if (OprfResponse.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(OprfResponse);\n      }\n      if (Username.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeStringSize(Username);\n      }\n      if (RegistrationRecord.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RegistrationRecord);\n      }\n      if (expiration_ != null) {\n        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Expiration);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(AkeServerState other) {\n      if (other == null) {\n        return;\n      }\n      if (other.ServerEphemeralPrivateKeyBytes.Length != 0) {\n        ServerEphemeralPrivateKeyBytes = other.ServerEphemeralPrivateKeyBytes;\n      }\n      if (other.ServerEphemeralPublicKey.Length != 0) {\n        ServerEphemeralPublicKey = other.ServerEphemeralPublicKey;\n      }\n      if (other.ClientStaticPublicKey.Length != 0) {\n        ClientStaticPublicKey = other.ClientStaticPublicKey;\n      }\n      if (other.OprfResponse.Length != 0) {\n        OprfResponse = other.OprfResponse;\n      }\n      if (other.Username.Length != 0) {\n        Username = other.Username;\n      }\n      if (other.RegistrationRecord.Length != 0) {\n        RegistrationRecord = other.RegistrationRecord;\n      }\n      if (other.expiration_ != null) {\n        if (expiration_ == null) {\n          Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();\n        }\n        Expiration.MergeFrom(other.Expiration);\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            ServerEphemeralPrivateKeyBytes = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            ServerEphemeralPublicKey = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            ClientStaticPublicKey = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            OprfResponse = input.ReadBytes();\n            break;\n          }\n          case 42: {\n            Username = input.ReadString();\n            break;\n          }\n          case 50: {\n            RegistrationRecord = input.ReadBytes();\n            break;\n          }\n          case 58: {\n            if (expiration_ == null) {\n              Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();\n            }\n            input.ReadMessage(Expiration);\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            ServerEphemeralPrivateKeyBytes = input.ReadBytes();\n            break;\n          }\n          case 18: {\n            ServerEphemeralPublicKey = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            ClientStaticPublicKey = input.ReadBytes();\n            break;\n          }\n          case 34: {\n            OprfResponse = input.ReadBytes();\n            break;\n          }\n          case 42: {\n            Username = input.ReadString();\n            break;\n          }\n          case 50: {\n            RegistrationRecord = input.ReadBytes();\n            break;\n          }\n          case 58: {\n            if (expiration_ == null) {\n              Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();\n            }\n            input.ReadMessage(Expiration);\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n  }\n\n  [global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]\n  public sealed partial class AkeSecureKeyResetState : pb::IMessage<AkeSecureKeyResetState>\n  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      , pb::IBufferMessage\n  #endif\n  {\n    private static readonly pb::MessageParser<AkeSecureKeyResetState> _parser = new pb::MessageParser<AkeSecureKeyResetState>(() => new AkeSecureKeyResetState());\n    private pb::UnknownFieldSet _unknownFields;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pb::MessageParser<AkeSecureKeyResetState> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[13]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public AkeSecureKeyResetState() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public AkeSecureKeyResetState(AkeSecureKeyResetState other) : this() {\n      username_ = other.username_;\n      resetToken_ = other.resetToken_;\n      expiration_ = other.expiration_ != null ? other.expiration_.Clone() : null;\n      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public AkeSecureKeyResetState Clone() {\n      return new AkeSecureKeyResetState(this);\n    }\n\n    /// <summary>Field number for the \"username\" field.</summary>\n    public const int UsernameFieldNumber = 1;\n    private string username_ = \"\";\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public string Username {\n      get { return username_; }\n      set {\n        username_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"reset_token\" field.</summary>\n    public const int ResetTokenFieldNumber = 2;\n    private string resetToken_ = \"\";\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public string ResetToken {\n      get { return resetToken_; }\n      set {\n        resetToken_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"expiration\" field.</summary>\n    public const int ExpirationFieldNumber = 3;\n    private global::Google.Protobuf.WellKnownTypes.Timestamp expiration_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public global::Google.Protobuf.WellKnownTypes.Timestamp Expiration {\n      get { return expiration_; }\n      set {\n        expiration_ = value;\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override bool Equals(object other) {\n      return Equals(other as AkeSecureKeyResetState);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public bool Equals(AkeSecureKeyResetState other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (Username != other.Username) return false;\n      if (ResetToken != other.ResetToken) return false;\n      if (!object.Equals(Expiration, other.Expiration)) return false;\n      return Equals(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (Username.Length != 0) hash ^= Username.GetHashCode();\n      if (ResetToken.Length != 0) hash ^= ResetToken.GetHashCode();\n      if (expiration_ != null) hash ^= Expiration.GetHashCode();\n      if (_unknownFields != null) {\n        hash ^= _unknownFields.GetHashCode();\n      }\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void WriteTo(pb::CodedOutputStream output) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      output.WriteRawMessage(this);\n    #else\n      if (Username.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteString(Username);\n      }\n      if (ResetToken.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteString(ResetToken);\n      }\n      if (expiration_ != null) {\n        output.WriteRawTag(26);\n        output.WriteMessage(Expiration);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(output);\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {\n      if (Username.Length != 0) {\n        output.WriteRawTag(10);\n        output.WriteString(Username);\n      }\n      if (ResetToken.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteString(ResetToken);\n      }\n      if (expiration_ != null) {\n        output.WriteRawTag(26);\n        output.WriteMessage(Expiration);\n      }\n      if (_unknownFields != null) {\n        _unknownFields.WriteTo(ref output);\n      }\n    }\n    #endif\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public int CalculateSize() {\n      int size = 0;\n      if (Username.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeStringSize(Username);\n      }\n      if (ResetToken.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeStringSize(ResetToken);\n      }\n      if (expiration_ != null) {\n        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Expiration);\n      }\n      if (_unknownFields != null) {\n        size += _unknownFields.CalculateSize();\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(AkeSecureKeyResetState other) {\n      if (other == null) {\n        return;\n      }\n      if (other.Username.Length != 0) {\n        Username = other.Username;\n      }\n      if (other.ResetToken.Length != 0) {\n        ResetToken = other.ResetToken;\n      }\n      if (other.expiration_ != null) {\n        if (expiration_ == null) {\n          Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();\n        }\n        Expiration.MergeFrom(other.Expiration);\n      }\n      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    public void MergeFrom(pb::CodedInputStream input) {\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n      input.ReadRawMessage(this);\n    #else\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n            break;\n          case 10: {\n            Username = input.ReadString();\n            break;\n          }\n          case 18: {\n            ResetToken = input.ReadString();\n            break;\n          }\n          case 26: {\n            if (expiration_ == null) {\n              Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();\n            }\n            input.ReadMessage(Expiration);\n            break;\n          }\n        }\n      }\n    #endif\n    }\n\n    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.CodeDom.Compiler.GeneratedCode(\"protoc\", null)]\n    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n      if ((tag & 7) == 4) {\n        // Abort on any end group tag.\n        return;\n      }\n      switch(tag) {\n          default:\n            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);\n            break;\n          case 10: {\n            Username = input.ReadString();\n            break;\n          }\n          case 18: {\n            ResetToken = input.ReadString();\n            break;\n          }\n          case 26: {\n            if (expiration_ == null) {\n              Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();\n            }\n            input.ReadMessage(Expiration);\n            break;\n          }\n        }\n      }\n    }\n    #endif\n\n  }\n\n  #endregion\n\n}\n\n#endregion Designer generated code\n"
  }
}
 [2025-11-04T12:57:52.104] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/OpaqueModels.cs with new text:
// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: membership/opaque_models.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Ecliptix.Protobuf.Membership {

  /// <summary>Holder for reflection information generated from membership/opaque_models.proto</summary>
  public static partial class OpaqueModelsReflection {

    #region Descriptor
    /// <summary>File descriptor for membership/opaque_models.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static OpaqueModelsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch5tZW1iZXJzaGlwL29wYXF1ZV9tb2RlbHMucHJvdG8SGWVjbGlwdGl4LnBy",
            "b3RvLm1lbWJlcnNoaXAaIG1lbWJlcnNoaXAvbWVtYmVyc2hpcF9jb3JlLnBy",
            "b3RvGhxhY2NvdW50L2FjY291bnRfbW9kZWxzLnByb3RvGh9nb29nbGUvcHJv",
            "dG9idWYvdGltZXN0YW1wLnByb3RvIlEKHU9wYXF1ZVJlZ2lzdHJhdGlvbklu",
            "aXRSZXF1ZXN0EhEKCXBlZXJfb3ByZhgBIAEoDBIdChVtZW1iZXJzaGlwX2lk",
            "ZW50aWZpZXIYAiABKAwitAIKHk9wYXF1ZVJlZ2lzdHJhdGlvbkluaXRSZXNw",
            "b25zZRIRCglwZWVyX29wcmYYASABKAwSVgoGcmVzdWx0GAIgASgOMkYuZWNs",
            "aXB0aXgucHJvdG8ubWVtYmVyc2hpcC5PcGFxdWVSZWdpc3RyYXRpb25Jbml0",
            "UmVzcG9uc2UuVXBkYXRlUmVzdWx0EhQKB21lc3NhZ2UYAyABKAlIAIgBARI+",
            "CgptZW1iZXJzaGlwGAQgASgLMiUuZWNsaXB0aXgucHJvdG8ubWVtYmVyc2hp",
            "cC5NZW1iZXJzaGlwSAGIAQEiNgoMVXBkYXRlUmVzdWx0Eg0KCVNVQ0NFRURF",
            "RBAAEhcKE0lOVkFMSURfQ1JFREVOVElBTFMQAUIKCghfbWVzc2FnZUINCgtf",
            "bWVtYmVyc2hpcCJ4CiFPcGFxdWVSZWdpc3RyYXRpb25Db21wbGV0ZVJlcXVl",
            "c3QSIAoYcGVlcl9yZWdpc3RyYXRpb25fcmVjb3JkGAEgASgMEh0KFW1lbWJl",
            "cnNoaXBfaWRlbnRpZmllchgCIAEoDBISCgptYXN0ZXJfa2V5GAMgASgMIoUD",
            "CiJPcGFxdWVSZWdpc3RyYXRpb25Db21wbGV0ZVJlc3BvbnNlEmAKBnJlc3Vs",
            "dBgBIAEoDjJQLmVjbGlwdGl4LnByb3RvLm1lbWJlcnNoaXAuT3BhcXVlUmVn",
            "aXN0cmF0aW9uQ29tcGxldGVSZXNwb25zZS5SZWdpc3RyYXRpb25SZXN1bHQS",
            "FAoHbWVzc2FnZRgCIAEoCUgAiAEBEhgKC3Nlc3Npb25fa2V5GAMgASgMSAGI",
            "AQESOwoSYXZhaWxhYmxlX2FjY291bnRzGAQgAygLMh8uZWNsaXB0aXgucHJv",
            "dG8uYWNjb3VudC5BY2NvdW50EjwKDmFjdGl2ZV9hY2NvdW50GAUgASgLMh8u",
            "ZWNsaXB0aXgucHJvdG8uYWNjb3VudC5BY2NvdW50SAKIAQEiIwoSUmVnaXN0",
            "cmF0aW9uUmVzdWx0Eg0KCVNVQ0NFRURFRBAAQgoKCF9tZXNzYWdlQg4KDF9z",
            "ZXNzaW9uX2tleUIRCg9fYWN0aXZlX2FjY291bnQiQwoXT3BhcXVlU2lnbklu",
            "SW5pdFJlcXVlc3QSFQoNbW9iaWxlX251bWJlchgBIAEoCRIRCglwZWVyX29w",
            "cmYYAiABKAwirAMKGE9wYXF1ZVNpZ25JbkluaXRSZXNwb25zZRIcChRzZXJ2",
            "ZXJfb3ByZl9yZXNwb25zZRgBIAEoDBIjChtzZXJ2ZXJfZXBoZW1lcmFsX3B1",
            "YmxpY19rZXkYAiABKAwSGwoTcmVnaXN0cmF0aW9uX3JlY29yZBgDIAEoDBIa",
            "ChJzZXJ2ZXJfc3RhdGVfdG9rZW4YBCABKAwSFAoHbWVzc2FnZRgFIAEoCUgA",
            "iAEBEiAKE21pbnV0ZXNfdW50aWxfcmV0cnkYBiABKAVIAYgBARJQCgZyZXN1",
            "bHQYByABKA4yQC5lY2xpcHRpeC5wcm90by5tZW1iZXJzaGlwLk9wYXF1ZVNp",
            "Z25JbkluaXRSZXNwb25zZS5TaWduSW5SZXN1bHQSEgoKc2VydmVyX21hYxgI",
            "IAEoDCJSCgxTaWduSW5SZXN1bHQSDQoJU1VDQ0VFREVEEAASFwoTSU5WQUxJ",
            "RF9DUkVERU5USUFMUxABEhoKFkxPR0lOX0FUVEVNUFRfRVhDRUVERUQQAkIK",
            "CghfbWVzc2FnZUIWChRfbWludXRlc191bnRpbF9yZXRyeSKJAQobT3BhcXVl",
            "U2lnbkluRmluYWxpemVSZXF1ZXN0EhUKDW1vYmlsZV9udW1iZXIYASABKAkS",
            "IwobY2xpZW50X2VwaGVtZXJhbF9wdWJsaWNfa2V5GAIgASgMEhIKCmNsaWVu",
            "dF9tYWMYAyABKAwSGgoSc2VydmVyX3N0YXRlX3Rva2VuGAQgASgMIpUEChxP",
            "cGFxdWVTaWduSW5GaW5hbGl6ZVJlc3BvbnNlEhIKCnNlcnZlcl9tYWMYASAB",
            "KAwSPgoKbWVtYmVyc2hpcBgCIAEoCzIlLmVjbGlwdGl4LnByb3RvLm1lbWJl",
            "cnNoaXAuTWVtYmVyc2hpcEgAiAEBElQKBnJlc3VsdBgDIAEoDjJELmVjbGlw",
            "dGl4LnByb3RvLm1lbWJlcnNoaXAuT3BhcXVlU2lnbkluRmluYWxpemVSZXNw",
            "b25zZS5TaWduSW5SZXN1bHQSFAoHbWVzc2FnZRgEIAEoCUgBiAEBEiAKE21p",
            "bnV0ZXNfdW50aWxfcmV0cnkYBSABKAVIAogBARI7ChJhdmFpbGFibGVfYWNj",
            "b3VudHMYBiADKAsyHy5lY2xpcHRpeC5wcm90by5hY2NvdW50LkFjY291bnQS",
            "PAoOYWN0aXZlX2FjY291bnQYByABKAsyHy5lY2xpcHRpeC5wcm90by5hY2Nv",
            "dW50LkFjY291bnRIA4gBASJSCgxTaWduSW5SZXN1bHQSDQoJU1VDQ0VFREVE",
            "EAASFwoTSU5WQUxJRF9DUkVERU5USUFMUxABEhoKFkxPR0lOX0FUVEVNUFRf",
            "RVhDRUVERUQQAkINCgtfbWVtYmVyc2hpcEIKCghfbWVzc2FnZUIWChRfbWlu",
            "dXRlc191bnRpbF9yZXRyeUIRCg9fYWN0aXZlX2FjY291bnQiVgoiT3BhcXVl",
            "UmVjb3ZlcnlTZWN1cmVLZXlJbml0UmVxdWVzdBIRCglwZWVyX29wcmYYASAB",
            "KAwSHQoVbWVtYmVyc2hpcF9pZGVudGlmaWVyGAIgASgMIsICCiNPcGFxdWVS",
            "ZWNvdmVyeVNlY3VyZUtleUluaXRSZXNwb25zZRIRCglwZWVyX29wcmYYASAB",
            "KAwSXQoGcmVzdWx0GAIgASgOMk0uZWNsaXB0aXgucHJvdG8ubWVtYmVyc2hp",
            "cC5PcGFxdWVSZWNvdmVyeVNlY3VyZUtleUluaXRSZXNwb25zZS5SZWNvdmVy",
            "eVJlc3VsdBIUCgdtZXNzYWdlGAMgASgJSACIAQESPgoKbWVtYmVyc2hpcBgE",
            "IAEoCzIlLmVjbGlwdGl4LnByb3RvLm1lbWJlcnNoaXAuTWVtYmVyc2hpcEgB",
            "iAEBIjgKDlJlY292ZXJ5UmVzdWx0Eg0KCVNVQ0NFRURFRBAAEhcKE0lOVkFM",
            "SURfQ1JFREVOVElBTFMQAUIKCghfbWVzc2FnZUINCgtfbWVtYmVyc2hpcCJ5",
            "CiZPcGFxdWVSZWNvdmVyeVNlY3JldEtleUNvbXBsZXRlUmVxdWVzdBIcChRw",
            "ZWVyX3JlY292ZXJ5X3JlY29yZBgBIAEoDBIdChVtZW1iZXJzaGlwX2lkZW50",
            "aWZpZXIYAiABKAwSEgoKbWFzdGVyX2tleRgDIAEoDCJLCidPcGFxdWVSZWNv",
            "dmVyeVNlY3JldEtleUNvbXBsZXRlUmVzcG9uc2USFAoHbWVzc2FnZRgBIAEo",
            "CUgAiAEBQgoKCF9tZXNzYWdlIvkBCg5Ba2VTZXJ2ZXJTdGF0ZRIqCiJzZXJ2",
            "ZXJfZXBoZW1lcmFsX3ByaXZhdGVfa2V5X2J5dGVzGAEgASgMEiMKG3NlcnZl",
            "cl9lcGhlbWVyYWxfcHVibGljX2tleRgCIAEoDBIgChhjbGllbnRfc3RhdGlj",
            "X3B1YmxpY19rZXkYAyABKAwSFQoNb3ByZl9yZXNwb25zZRgEIAEoDBIQCgh1",
            "c2VybmFtZRgFIAEoCRIbChNyZWdpc3RyYXRpb25fcmVjb3JkGAYgASgMEi4K",
            "CmV4cGlyYXRpb24YByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1w",
            "Im8KFkFrZVNlY3VyZUtleVJlc2V0U3RhdGUSEAoIdXNlcm5hbWUYASABKAkS",
            "EwoLcmVzZXRfdG9rZW4YAiABKAkSLgoKZXhwaXJhdGlvbhgDIAEoCzIaLmdv",
            "b2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCH6oCHEVjbGlwdGl4LlByb3RvYnVm",
            "Lk1lbWJlcnNoaXBiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Ecliptix.Protobuf.Membership.MembershipCoreReflection.Descriptor, global::Ecliptix.Protobuf.Account.AccountModelsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitRequest), global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitRequest.Parser, new[]{ "PeerOprf", "MembershipIdentifier" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse), global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Parser, new[]{ "PeerOprf", "Result", "Message", "Membership" }, new[]{ "Message", "Membership" }, new[]{ typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteRequest), global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteRequest.Parser, new[]{ "PeerRegistrationRecord", "MembershipIdentifier", "MasterKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse), global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Parser, new[]{ "Result", "Message", "SessionKey", "AvailableAccounts", "ActiveAccount" }, new[]{ "Message", "SessionKey", "ActiveAccount" }, new[]{ typeof(global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInInitRequest), global::Ecliptix.Protobuf.Membership.OpaqueSignInInitRequest.Parser, new[]{ "MobileNumber", "PeerOprf" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse), global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Parser, new[]{ "ServerOprfResponse", "ServerEphemeralPublicKey", "RegistrationRecord", "ServerStateToken", "Message", "MinutesUntilRetry", "Result", "ServerMac" }, new[]{ "Message", "MinutesUntilRetry" }, new[]{ typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeRequest), global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeRequest.Parser, new[]{ "MobileNumber", "ClientEphemeralPublicKey", "ClientMac", "ServerStateToken" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse), global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Parser, new[]{ "ServerMac", "Membership", "Result", "Message", "MinutesUntilRetry", "AvailableAccounts", "ActiveAccount" }, new[]{ "Membership", "Message", "MinutesUntilRetry", "ActiveAccount" }, new[]{ typeof(global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitRequest), global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitRequest.Parser, new[]{ "PeerOprf", "MembershipIdentifier" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse), global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Parser, new[]{ "PeerOprf", "Result", "Message", "Membership" }, new[]{ "Message", "Membership" }, new[]{ typeof(global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecretKeyCompleteRequest), global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecretKeyCompleteRequest.Parser, new[]{ "PeerRecoveryRecord", "MembershipIdentifier", "MasterKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecretKeyCompleteResponse), global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecretKeyCompleteResponse.Parser, new[]{ "Message" }, new[]{ "Message" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.AkeServerState), global::Ecliptix.Protobuf.Membership.AkeServerState.Parser, new[]{ "ServerEphemeralPrivateKeyBytes", "ServerEphemeralPublicKey", "ClientStaticPublicKey", "OprfResponse", "Username", "RegistrationRecord", "Expiration" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ecliptix.Protobuf.Membership.AkeSecureKeyResetState), global::Ecliptix.Protobuf.Membership.AkeSecureKeyResetState.Parser, new[]{ "Username", "ResetToken", "Expiration" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueRegistrationInitRequest : pb::IMessage<OpaqueRegistrationInitRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueRegistrationInitRequest> _parser = new pb::MessageParser<OpaqueRegistrationInitRequest>(() => new OpaqueRegistrationInitRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueRegistrationInitRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationInitRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationInitRequest(OpaqueRegistrationInitRequest other) : this() {
      peerOprf_ = other.peerOprf_;
      membershipIdentifier_ = other.membershipIdentifier_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationInitRequest Clone() {
      return new OpaqueRegistrationInitRequest(this);
    }

    /// <summary>Field number for the "peer_oprf" field.</summary>
    public const int PeerOprfFieldNumber = 1;
    private pb::ByteString peerOprf_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PeerOprf {
      get { return peerOprf_; }
      set {
        peerOprf_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "membership_identifier" field.</summary>
    public const int MembershipIdentifierFieldNumber = 2;
    private pb::ByteString membershipIdentifier_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString MembershipIdentifier {
      get { return membershipIdentifier_; }
      set {
        membershipIdentifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueRegistrationInitRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueRegistrationInitRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PeerOprf != other.PeerOprf) return false;
      if (MembershipIdentifier != other.MembershipIdentifier) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (PeerOprf.Length != 0) hash ^= PeerOprf.GetHashCode();
      if (MembershipIdentifier.Length != 0) hash ^= MembershipIdentifier.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (PeerOprf.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerOprf);
      }
      if (MembershipIdentifier.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(MembershipIdentifier);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (PeerOprf.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerOprf);
      }
      if (MembershipIdentifier.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(MembershipIdentifier);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (PeerOprf.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerOprf);
      }
      if (MembershipIdentifier.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MembershipIdentifier);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueRegistrationInitRequest other) {
      if (other == null) {
        return;
      }
      if (other.PeerOprf.Length != 0) {
        PeerOprf = other.PeerOprf;
      }
      if (other.MembershipIdentifier.Length != 0) {
        MembershipIdentifier = other.MembershipIdentifier;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PeerOprf = input.ReadBytes();
            break;
          }
          case 18: {
            MembershipIdentifier = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PeerOprf = input.ReadBytes();
            break;
          }
          case 18: {
            MembershipIdentifier = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueRegistrationInitResponse : pb::IMessage<OpaqueRegistrationInitResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueRegistrationInitResponse> _parser = new pb::MessageParser<OpaqueRegistrationInitResponse>(() => new OpaqueRegistrationInitResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueRegistrationInitResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationInitResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationInitResponse(OpaqueRegistrationInitResponse other) : this() {
      peerOprf_ = other.peerOprf_;
      result_ = other.result_;
      message_ = other.message_;
      membership_ = other.membership_ != null ? other.membership_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationInitResponse Clone() {
      return new OpaqueRegistrationInitResponse(this);
    }

    /// <summary>Field number for the "peer_oprf" field.</summary>
    public const int PeerOprfFieldNumber = 1;
    private pb::ByteString peerOprf_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PeerOprf {
      get { return peerOprf_; }
      set {
        peerOprf_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "result" field.</summary>
    public const int ResultFieldNumber = 2;
    private global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult result_ = global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult Result {
      get { return result_; }
      set {
        result_ = value;
      }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 3;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "membership" field.</summary>
    public const int MembershipFieldNumber = 4;
    private global::Ecliptix.Protobuf.Membership.Membership membership_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Membership.Membership Membership {
      get { return membership_; }
      set {
        membership_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueRegistrationInitResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueRegistrationInitResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PeerOprf != other.PeerOprf) return false;
      if (Result != other.Result) return false;
      if (Message != other.Message) return false;
      if (!object.Equals(Membership, other.Membership)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (PeerOprf.Length != 0) hash ^= PeerOprf.GetHashCode();
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded) hash ^= Result.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (membership_ != null) hash ^= Membership.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (PeerOprf.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerOprf);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Result);
      }
      if (HasMessage) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (membership_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Membership);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (PeerOprf.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerOprf);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Result);
      }
      if (HasMessage) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (membership_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Membership);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (PeerOprf.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerOprf);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Result);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (membership_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Membership);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueRegistrationInitResponse other) {
      if (other == null) {
        return;
      }
      if (other.PeerOprf.Length != 0) {
        PeerOprf = other.PeerOprf;
      }
      if (other.Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult.Succeeded) {
        Result = other.Result;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.membership_ != null) {
        if (membership_ == null) {
          Membership = new global::Ecliptix.Protobuf.Membership.Membership();
        }
        Membership.MergeFrom(other.Membership);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PeerOprf = input.ReadBytes();
            break;
          }
          case 16: {
            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult) input.ReadEnum();
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            if (membership_ == null) {
              Membership = new global::Ecliptix.Protobuf.Membership.Membership();
            }
            input.ReadMessage(Membership);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PeerOprf = input.ReadBytes();
            break;
          }
          case 16: {
            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRegistrationInitResponse.Types.UpdateResult) input.ReadEnum();
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            if (membership_ == null) {
              Membership = new global::Ecliptix.Protobuf.Membership.Membership();
            }
            input.ReadMessage(Membership);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the OpaqueRegistrationInitResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum UpdateResult {
        [pbr::OriginalName("SUCCEEDED")] Succeeded = 0,
        [pbr::OriginalName("INVALID_CREDENTIALS")] InvalidCredentials = 1,
      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueRegistrationCompleteRequest : pb::IMessage<OpaqueRegistrationCompleteRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueRegistrationCompleteRequest> _parser = new pb::MessageParser<OpaqueRegistrationCompleteRequest>(() => new OpaqueRegistrationCompleteRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueRegistrationCompleteRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationCompleteRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationCompleteRequest(OpaqueRegistrationCompleteRequest other) : this() {
      peerRegistrationRecord_ = other.peerRegistrationRecord_;
      membershipIdentifier_ = other.membershipIdentifier_;
      masterKey_ = other.masterKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationCompleteRequest Clone() {
      return new OpaqueRegistrationCompleteRequest(this);
    }

    /// <summary>Field number for the "peer_registration_record" field.</summary>
    public const int PeerRegistrationRecordFieldNumber = 1;
    private pb::ByteString peerRegistrationRecord_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PeerRegistrationRecord {
      get { return peerRegistrationRecord_; }
      set {
        peerRegistrationRecord_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "membership_identifier" field.</summary>
    public const int MembershipIdentifierFieldNumber = 2;
    private pb::ByteString membershipIdentifier_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString MembershipIdentifier {
      get { return membershipIdentifier_; }
      set {
        membershipIdentifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "master_key" field.</summary>
    public const int MasterKeyFieldNumber = 3;
    private pb::ByteString masterKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString MasterKey {
      get { return masterKey_; }
      set {
        masterKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueRegistrationCompleteRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueRegistrationCompleteRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PeerRegistrationRecord != other.PeerRegistrationRecord) return false;
      if (MembershipIdentifier != other.MembershipIdentifier) return false;
      if (MasterKey != other.MasterKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (PeerRegistrationRecord.Length != 0) hash ^= PeerRegistrationRecord.GetHashCode();
      if (MembershipIdentifier.Length != 0) hash ^= MembershipIdentifier.GetHashCode();
      if (MasterKey.Length != 0) hash ^= MasterKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (PeerRegistrationRecord.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerRegistrationRecord);
      }
      if (MembershipIdentifier.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(MembershipIdentifier);
      }
      if (MasterKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(MasterKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (PeerRegistrationRecord.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerRegistrationRecord);
      }
      if (MembershipIdentifier.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(MembershipIdentifier);
      }
      if (MasterKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(MasterKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (PeerRegistrationRecord.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerRegistrationRecord);
      }
      if (MembershipIdentifier.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MembershipIdentifier);
      }
      if (MasterKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MasterKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueRegistrationCompleteRequest other) {
      if (other == null) {
        return;
      }
      if (other.PeerRegistrationRecord.Length != 0) {
        PeerRegistrationRecord = other.PeerRegistrationRecord;
      }
      if (other.MembershipIdentifier.Length != 0) {
        MembershipIdentifier = other.MembershipIdentifier;
      }
      if (other.MasterKey.Length != 0) {
        MasterKey = other.MasterKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PeerRegistrationRecord = input.ReadBytes();
            break;
          }
          case 18: {
            MembershipIdentifier = input.ReadBytes();
            break;
          }
          case 26: {
            MasterKey = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PeerRegistrationRecord = input.ReadBytes();
            break;
          }
          case 18: {
            MembershipIdentifier = input.ReadBytes();
            break;
          }
          case 26: {
            MasterKey = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueRegistrationCompleteResponse : pb::IMessage<OpaqueRegistrationCompleteResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueRegistrationCompleteResponse> _parser = new pb::MessageParser<OpaqueRegistrationCompleteResponse>(() => new OpaqueRegistrationCompleteResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueRegistrationCompleteResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationCompleteResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationCompleteResponse(OpaqueRegistrationCompleteResponse other) : this() {
      result_ = other.result_;
      message_ = other.message_;
      sessionKey_ = other.sessionKey_;
      availableAccounts_ = other.availableAccounts_.Clone();
      activeAccount_ = other.activeAccount_ != null ? other.activeAccount_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRegistrationCompleteResponse Clone() {
      return new OpaqueRegistrationCompleteResponse(this);
    }

    /// <summary>Field number for the "result" field.</summary>
    public const int ResultFieldNumber = 1;
    private global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult result_ = global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult Result {
      get { return result_; }
      set {
        result_ = value;
      }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 2;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "session_key" field.</summary>
    public const int SessionKeyFieldNumber = 3;
    private readonly static pb::ByteString SessionKeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString sessionKey_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString SessionKey {
      get { return sessionKey_ ?? SessionKeyDefaultValue; }
      set {
        sessionKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "session_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSessionKey {
      get { return sessionKey_ != null; }
    }
    /// <summary>Clears the value of the "session_key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSessionKey() {
      sessionKey_ = null;
    }

    /// <summary>Field number for the "available_accounts" field.</summary>
    public const int AvailableAccountsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Ecliptix.Protobuf.Account.Account> _repeated_availableAccounts_codec
        = pb::FieldCodec.ForMessage(34, global::Ecliptix.Protobuf.Account.Account.Parser);
    private readonly pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account> availableAccounts_ = new pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account> AvailableAccounts {
      get { return availableAccounts_; }
    }

    /// <summary>Field number for the "active_account" field.</summary>
    public const int ActiveAccountFieldNumber = 5;
    private global::Ecliptix.Protobuf.Account.Account activeAccount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Account.Account ActiveAccount {
      get { return activeAccount_; }
      set {
        activeAccount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueRegistrationCompleteResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueRegistrationCompleteResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Result != other.Result) return false;
      if (Message != other.Message) return false;
      if (SessionKey != other.SessionKey) return false;
      if(!availableAccounts_.Equals(other.availableAccounts_)) return false;
      if (!object.Equals(ActiveAccount, other.ActiveAccount)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded) hash ^= Result.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (HasSessionKey) hash ^= SessionKey.GetHashCode();
      hash ^= availableAccounts_.GetHashCode();
      if (activeAccount_ != null) hash ^= ActiveAccount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Result);
      }
      if (HasMessage) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      if (HasSessionKey) {
        output.WriteRawTag(26);
        output.WriteBytes(SessionKey);
      }
      availableAccounts_.WriteTo(output, _repeated_availableAccounts_codec);
      if (activeAccount_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ActiveAccount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Result);
      }
      if (HasMessage) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      if (HasSessionKey) {
        output.WriteRawTag(26);
        output.WriteBytes(SessionKey);
      }
      availableAccounts_.WriteTo(ref output, _repeated_availableAccounts_codec);
      if (activeAccount_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ActiveAccount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Result);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (HasSessionKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SessionKey);
      }
      size += availableAccounts_.CalculateSize(_repeated_availableAccounts_codec);
      if (activeAccount_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ActiveAccount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueRegistrationCompleteResponse other) {
      if (other == null) {
        return;
      }
      if (other.Result != global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult.Succeeded) {
        Result = other.Result;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.HasSessionKey) {
        SessionKey = other.SessionKey;
      }
      availableAccounts_.Add(other.availableAccounts_);
      if (other.activeAccount_ != null) {
        if (activeAccount_ == null) {
          ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();
        }
        ActiveAccount.MergeFrom(other.ActiveAccount);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult) input.ReadEnum();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
          case 26: {
            SessionKey = input.ReadBytes();
            break;
          }
          case 34: {
            availableAccounts_.AddEntriesFrom(input, _repeated_availableAccounts_codec);
            break;
          }
          case 42: {
            if (activeAccount_ == null) {
              ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();
            }
            input.ReadMessage(ActiveAccount);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRegistrationCompleteResponse.Types.RegistrationResult) input.ReadEnum();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
          case 26: {
            SessionKey = input.ReadBytes();
            break;
          }
          case 34: {
            availableAccounts_.AddEntriesFrom(ref input, _repeated_availableAccounts_codec);
            break;
          }
          case 42: {
            if (activeAccount_ == null) {
              ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();
            }
            input.ReadMessage(ActiveAccount);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the OpaqueRegistrationCompleteResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum RegistrationResult {
        [pbr::OriginalName("SUCCEEDED")] Succeeded = 0,
      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueSignInInitRequest : pb::IMessage<OpaqueSignInInitRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueSignInInitRequest> _parser = new pb::MessageParser<OpaqueSignInInitRequest>(() => new OpaqueSignInInitRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueSignInInitRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInInitRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInInitRequest(OpaqueSignInInitRequest other) : this() {
      mobileNumber_ = other.mobileNumber_;
      peerOprf_ = other.peerOprf_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInInitRequest Clone() {
      return new OpaqueSignInInitRequest(this);
    }

    /// <summary>Field number for the "mobile_number" field.</summary>
    public const int MobileNumberFieldNumber = 1;
    private string mobileNumber_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MobileNumber {
      get { return mobileNumber_; }
      set {
        mobileNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "peer_oprf" field.</summary>
    public const int PeerOprfFieldNumber = 2;
    private pb::ByteString peerOprf_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PeerOprf {
      get { return peerOprf_; }
      set {
        peerOprf_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueSignInInitRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueSignInInitRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MobileNumber != other.MobileNumber) return false;
      if (PeerOprf != other.PeerOprf) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (MobileNumber.Length != 0) hash ^= MobileNumber.GetHashCode();
      if (PeerOprf.Length != 0) hash ^= PeerOprf.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MobileNumber.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(MobileNumber);
      }
      if (PeerOprf.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(PeerOprf);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MobileNumber.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(MobileNumber);
      }
      if (PeerOprf.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(PeerOprf);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (MobileNumber.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MobileNumber);
      }
      if (PeerOprf.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerOprf);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueSignInInitRequest other) {
      if (other == null) {
        return;
      }
      if (other.MobileNumber.Length != 0) {
        MobileNumber = other.MobileNumber;
      }
      if (other.PeerOprf.Length != 0) {
        PeerOprf = other.PeerOprf;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            MobileNumber = input.ReadString();
            break;
          }
          case 18: {
            PeerOprf = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            MobileNumber = input.ReadString();
            break;
          }
          case 18: {
            PeerOprf = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueSignInInitResponse : pb::IMessage<OpaqueSignInInitResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueSignInInitResponse> _parser = new pb::MessageParser<OpaqueSignInInitResponse>(() => new OpaqueSignInInitResponse());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueSignInInitResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInInitResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInInitResponse(OpaqueSignInInitResponse other) : this() {
      _hasBits0 = other._hasBits0;
      serverOprfResponse_ = other.serverOprfResponse_;
      serverEphemeralPublicKey_ = other.serverEphemeralPublicKey_;
      registrationRecord_ = other.registrationRecord_;
      serverStateToken_ = other.serverStateToken_;
      message_ = other.message_;
      minutesUntilRetry_ = other.minutesUntilRetry_;
      result_ = other.result_;
      serverMac_ = other.serverMac_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInInitResponse Clone() {
      return new OpaqueSignInInitResponse(this);
    }

    /// <summary>Field number for the "server_oprf_response" field.</summary>
    public const int ServerOprfResponseFieldNumber = 1;
    private pb::ByteString serverOprfResponse_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ServerOprfResponse {
      get { return serverOprfResponse_; }
      set {
        serverOprfResponse_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "server_ephemeral_public_key" field.</summary>
    public const int ServerEphemeralPublicKeyFieldNumber = 2;
    private pb::ByteString serverEphemeralPublicKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ServerEphemeralPublicKey {
      get { return serverEphemeralPublicKey_; }
      set {
        serverEphemeralPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "registration_record" field.</summary>
    public const int RegistrationRecordFieldNumber = 3;
    private pb::ByteString registrationRecord_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString RegistrationRecord {
      get { return registrationRecord_; }
      set {
        registrationRecord_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "server_state_token" field.</summary>
    public const int ServerStateTokenFieldNumber = 4;
    private pb::ByteString serverStateToken_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ServerStateToken {
      get { return serverStateToken_; }
      set {
        serverStateToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 5;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "minutes_until_retry" field.</summary>
    public const int MinutesUntilRetryFieldNumber = 6;
    private readonly static int MinutesUntilRetryDefaultValue = 0;

    private int minutesUntilRetry_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MinutesUntilRetry {
      get { if ((_hasBits0 & 1) != 0) { return minutesUntilRetry_; } else { return MinutesUntilRetryDefaultValue; } }
      set {
        _hasBits0 |= 1;
        minutesUntilRetry_ = value;
      }
    }
    /// <summary>Gets whether the "minutes_until_retry" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinutesUntilRetry {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "minutes_until_retry" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinutesUntilRetry() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "result" field.</summary>
    public const int ResultFieldNumber = 7;
    private global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult result_ = global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult Result {
      get { return result_; }
      set {
        result_ = value;
      }
    }

    /// <summary>Field number for the "server_mac" field.</summary>
    public const int ServerMacFieldNumber = 8;
    private pb::ByteString serverMac_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ServerMac {
      get { return serverMac_; }
      set {
        serverMac_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueSignInInitResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueSignInInitResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ServerOprfResponse != other.ServerOprfResponse) return false;
      if (ServerEphemeralPublicKey != other.ServerEphemeralPublicKey) return false;
      if (RegistrationRecord != other.RegistrationRecord) return false;
      if (ServerStateToken != other.ServerStateToken) return false;
      if (Message != other.Message) return false;
      if (MinutesUntilRetry != other.MinutesUntilRetry) return false;
      if (Result != other.Result) return false;
      if (ServerMac != other.ServerMac) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ServerOprfResponse.Length != 0) hash ^= ServerOprfResponse.GetHashCode();
      if (ServerEphemeralPublicKey.Length != 0) hash ^= ServerEphemeralPublicKey.GetHashCode();
      if (RegistrationRecord.Length != 0) hash ^= RegistrationRecord.GetHashCode();
      if (ServerStateToken.Length != 0) hash ^= ServerStateToken.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (HasMinutesUntilRetry) hash ^= MinutesUntilRetry.GetHashCode();
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded) hash ^= Result.GetHashCode();
      if (ServerMac.Length != 0) hash ^= ServerMac.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ServerOprfResponse.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(ServerOprfResponse);
      }
      if (ServerEphemeralPublicKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(ServerEphemeralPublicKey);
      }
      if (RegistrationRecord.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(RegistrationRecord);
      }
      if (ServerStateToken.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(ServerStateToken);
      }
      if (HasMessage) {
        output.WriteRawTag(42);
        output.WriteString(Message);
      }
      if (HasMinutesUntilRetry) {
        output.WriteRawTag(48);
        output.WriteInt32(MinutesUntilRetry);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Result);
      }
      if (ServerMac.Length != 0) {
        output.WriteRawTag(66);
        output.WriteBytes(ServerMac);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ServerOprfResponse.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(ServerOprfResponse);
      }
      if (ServerEphemeralPublicKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(ServerEphemeralPublicKey);
      }
      if (RegistrationRecord.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(RegistrationRecord);
      }
      if (ServerStateToken.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(ServerStateToken);
      }
      if (HasMessage) {
        output.WriteRawTag(42);
        output.WriteString(Message);
      }
      if (HasMinutesUntilRetry) {
        output.WriteRawTag(48);
        output.WriteInt32(MinutesUntilRetry);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Result);
      }
      if (ServerMac.Length != 0) {
        output.WriteRawTag(66);
        output.WriteBytes(ServerMac);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ServerOprfResponse.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerOprfResponse);
      }
      if (ServerEphemeralPublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerEphemeralPublicKey);
      }
      if (RegistrationRecord.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RegistrationRecord);
      }
      if (ServerStateToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerStateToken);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (HasMinutesUntilRetry) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinutesUntilRetry);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Result);
      }
      if (ServerMac.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerMac);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueSignInInitResponse other) {
      if (other == null) {
        return;
      }
      if (other.ServerOprfResponse.Length != 0) {
        ServerOprfResponse = other.ServerOprfResponse;
      }
      if (other.ServerEphemeralPublicKey.Length != 0) {
        ServerEphemeralPublicKey = other.ServerEphemeralPublicKey;
      }
      if (other.RegistrationRecord.Length != 0) {
        RegistrationRecord = other.RegistrationRecord;
      }
      if (other.ServerStateToken.Length != 0) {
        ServerStateToken = other.ServerStateToken;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.HasMinutesUntilRetry) {
        MinutesUntilRetry = other.MinutesUntilRetry;
      }
      if (other.Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult.Succeeded) {
        Result = other.Result;
      }
      if (other.ServerMac.Length != 0) {
        ServerMac = other.ServerMac;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ServerOprfResponse = input.ReadBytes();
            break;
          }
          case 18: {
            ServerEphemeralPublicKey = input.ReadBytes();
            break;
          }
          case 26: {
            RegistrationRecord = input.ReadBytes();
            break;
          }
          case 34: {
            ServerStateToken = input.ReadBytes();
            break;
          }
          case 42: {
            Message = input.ReadString();
            break;
          }
          case 48: {
            MinutesUntilRetry = input.ReadInt32();
            break;
          }
          case 56: {
            Result = (global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult) input.ReadEnum();
            break;
          }
          case 66: {
            ServerMac = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ServerOprfResponse = input.ReadBytes();
            break;
          }
          case 18: {
            ServerEphemeralPublicKey = input.ReadBytes();
            break;
          }
          case 26: {
            RegistrationRecord = input.ReadBytes();
            break;
          }
          case 34: {
            ServerStateToken = input.ReadBytes();
            break;
          }
          case 42: {
            Message = input.ReadString();
            break;
          }
          case 48: {
            MinutesUntilRetry = input.ReadInt32();
            break;
          }
          case 56: {
            Result = (global::Ecliptix.Protobuf.Membership.OpaqueSignInInitResponse.Types.SignInResult) input.ReadEnum();
            break;
          }
          case 66: {
            ServerMac = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the OpaqueSignInInitResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum SignInResult {
        [pbr::OriginalName("SUCCEEDED")] Succeeded = 0,
        [pbr::OriginalName("INVALID_CREDENTIALS")] InvalidCredentials = 1,
        [pbr::OriginalName("LOGIN_ATTEMPT_EXCEEDED")] LoginAttemptExceeded = 2,
      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueSignInFinalizeRequest : pb::IMessage<OpaqueSignInFinalizeRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueSignInFinalizeRequest> _parser = new pb::MessageParser<OpaqueSignInFinalizeRequest>(() => new OpaqueSignInFinalizeRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueSignInFinalizeRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInFinalizeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInFinalizeRequest(OpaqueSignInFinalizeRequest other) : this() {
      mobileNumber_ = other.mobileNumber_;
      clientEphemeralPublicKey_ = other.clientEphemeralPublicKey_;
      clientMac_ = other.clientMac_;
      serverStateToken_ = other.serverStateToken_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInFinalizeRequest Clone() {
      return new OpaqueSignInFinalizeRequest(this);
    }

    /// <summary>Field number for the "mobile_number" field.</summary>
    public const int MobileNumberFieldNumber = 1;
    private string mobileNumber_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MobileNumber {
      get { return mobileNumber_; }
      set {
        mobileNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "client_ephemeral_public_key" field.</summary>
    public const int ClientEphemeralPublicKeyFieldNumber = 2;
    private pb::ByteString clientEphemeralPublicKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ClientEphemeralPublicKey {
      get { return clientEphemeralPublicKey_; }
      set {
        clientEphemeralPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "client_mac" field.</summary>
    public const int ClientMacFieldNumber = 3;
    private pb::ByteString clientMac_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ClientMac {
      get { return clientMac_; }
      set {
        clientMac_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "server_state_token" field.</summary>
    public const int ServerStateTokenFieldNumber = 4;
    private pb::ByteString serverStateToken_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ServerStateToken {
      get { return serverStateToken_; }
      set {
        serverStateToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueSignInFinalizeRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueSignInFinalizeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MobileNumber != other.MobileNumber) return false;
      if (ClientEphemeralPublicKey != other.ClientEphemeralPublicKey) return false;
      if (ClientMac != other.ClientMac) return false;
      if (ServerStateToken != other.ServerStateToken) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (MobileNumber.Length != 0) hash ^= MobileNumber.GetHashCode();
      if (ClientEphemeralPublicKey.Length != 0) hash ^= ClientEphemeralPublicKey.GetHashCode();
      if (ClientMac.Length != 0) hash ^= ClientMac.GetHashCode();
      if (ServerStateToken.Length != 0) hash ^= ServerStateToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MobileNumber.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(MobileNumber);
      }
      if (ClientEphemeralPublicKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(ClientEphemeralPublicKey);
      }
      if (ClientMac.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(ClientMac);
      }
      if (ServerStateToken.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(ServerStateToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MobileNumber.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(MobileNumber);
      }
      if (ClientEphemeralPublicKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(ClientEphemeralPublicKey);
      }
      if (ClientMac.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(ClientMac);
      }
      if (ServerStateToken.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(ServerStateToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (MobileNumber.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MobileNumber);
      }
      if (ClientEphemeralPublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ClientEphemeralPublicKey);
      }
      if (ClientMac.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ClientMac);
      }
      if (ServerStateToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerStateToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueSignInFinalizeRequest other) {
      if (other == null) {
        return;
      }
      if (other.MobileNumber.Length != 0) {
        MobileNumber = other.MobileNumber;
      }
      if (other.ClientEphemeralPublicKey.Length != 0) {
        ClientEphemeralPublicKey = other.ClientEphemeralPublicKey;
      }
      if (other.ClientMac.Length != 0) {
        ClientMac = other.ClientMac;
      }
      if (other.ServerStateToken.Length != 0) {
        ServerStateToken = other.ServerStateToken;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            MobileNumber = input.ReadString();
            break;
          }
          case 18: {
            ClientEphemeralPublicKey = input.ReadBytes();
            break;
          }
          case 26: {
            ClientMac = input.ReadBytes();
            break;
          }
          case 34: {
            ServerStateToken = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            MobileNumber = input.ReadString();
            break;
          }
          case 18: {
            ClientEphemeralPublicKey = input.ReadBytes();
            break;
          }
          case 26: {
            ClientMac = input.ReadBytes();
            break;
          }
          case 34: {
            ServerStateToken = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueSignInFinalizeResponse : pb::IMessage<OpaqueSignInFinalizeResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueSignInFinalizeResponse> _parser = new pb::MessageParser<OpaqueSignInFinalizeResponse>(() => new OpaqueSignInFinalizeResponse());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueSignInFinalizeResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInFinalizeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInFinalizeResponse(OpaqueSignInFinalizeResponse other) : this() {
      _hasBits0 = other._hasBits0;
      serverMac_ = other.serverMac_;
      membership_ = other.membership_ != null ? other.membership_.Clone() : null;
      result_ = other.result_;
      message_ = other.message_;
      minutesUntilRetry_ = other.minutesUntilRetry_;
      availableAccounts_ = other.availableAccounts_.Clone();
      activeAccount_ = other.activeAccount_ != null ? other.activeAccount_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueSignInFinalizeResponse Clone() {
      return new OpaqueSignInFinalizeResponse(this);
    }

    /// <summary>Field number for the "server_mac" field.</summary>
    public const int ServerMacFieldNumber = 1;
    private pb::ByteString serverMac_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ServerMac {
      get { return serverMac_; }
      set {
        serverMac_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "membership" field.</summary>
    public const int MembershipFieldNumber = 2;
    private global::Ecliptix.Protobuf.Membership.Membership membership_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Membership.Membership Membership {
      get { return membership_; }
      set {
        membership_ = value;
      }
    }

    /// <summary>Field number for the "result" field.</summary>
    public const int ResultFieldNumber = 3;
    private global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult result_ = global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult Result {
      get { return result_; }
      set {
        result_ = value;
      }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 4;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "minutes_until_retry" field.</summary>
    public const int MinutesUntilRetryFieldNumber = 5;
    private readonly static int MinutesUntilRetryDefaultValue = 0;

    private int minutesUntilRetry_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MinutesUntilRetry {
      get { if ((_hasBits0 & 1) != 0) { return minutesUntilRetry_; } else { return MinutesUntilRetryDefaultValue; } }
      set {
        _hasBits0 |= 1;
        minutesUntilRetry_ = value;
      }
    }
    /// <summary>Gets whether the "minutes_until_retry" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinutesUntilRetry {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "minutes_until_retry" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinutesUntilRetry() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "available_accounts" field.</summary>
    public const int AvailableAccountsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Ecliptix.Protobuf.Account.Account> _repeated_availableAccounts_codec
        = pb::FieldCodec.ForMessage(50, global::Ecliptix.Protobuf.Account.Account.Parser);
    private readonly pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account> availableAccounts_ = new pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Ecliptix.Protobuf.Account.Account> AvailableAccounts {
      get { return availableAccounts_; }
    }

    /// <summary>Field number for the "active_account" field.</summary>
    public const int ActiveAccountFieldNumber = 7;
    private global::Ecliptix.Protobuf.Account.Account activeAccount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Account.Account ActiveAccount {
      get { return activeAccount_; }
      set {
        activeAccount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueSignInFinalizeResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueSignInFinalizeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ServerMac != other.ServerMac) return false;
      if (!object.Equals(Membership, other.Membership)) return false;
      if (Result != other.Result) return false;
      if (Message != other.Message) return false;
      if (MinutesUntilRetry != other.MinutesUntilRetry) return false;
      if(!availableAccounts_.Equals(other.availableAccounts_)) return false;
      if (!object.Equals(ActiveAccount, other.ActiveAccount)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ServerMac.Length != 0) hash ^= ServerMac.GetHashCode();
      if (membership_ != null) hash ^= Membership.GetHashCode();
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded) hash ^= Result.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (HasMinutesUntilRetry) hash ^= MinutesUntilRetry.GetHashCode();
      hash ^= availableAccounts_.GetHashCode();
      if (activeAccount_ != null) hash ^= ActiveAccount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ServerMac.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(ServerMac);
      }
      if (membership_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Membership);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Result);
      }
      if (HasMessage) {
        output.WriteRawTag(34);
        output.WriteString(Message);
      }
      if (HasMinutesUntilRetry) {
        output.WriteRawTag(40);
        output.WriteInt32(MinutesUntilRetry);
      }
      availableAccounts_.WriteTo(output, _repeated_availableAccounts_codec);
      if (activeAccount_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(ActiveAccount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ServerMac.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(ServerMac);
      }
      if (membership_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Membership);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Result);
      }
      if (HasMessage) {
        output.WriteRawTag(34);
        output.WriteString(Message);
      }
      if (HasMinutesUntilRetry) {
        output.WriteRawTag(40);
        output.WriteInt32(MinutesUntilRetry);
      }
      availableAccounts_.WriteTo(ref output, _repeated_availableAccounts_codec);
      if (activeAccount_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(ActiveAccount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ServerMac.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerMac);
      }
      if (membership_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Membership);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Result);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (HasMinutesUntilRetry) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinutesUntilRetry);
      }
      size += availableAccounts_.CalculateSize(_repeated_availableAccounts_codec);
      if (activeAccount_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ActiveAccount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueSignInFinalizeResponse other) {
      if (other == null) {
        return;
      }
      if (other.ServerMac.Length != 0) {
        ServerMac = other.ServerMac;
      }
      if (other.membership_ != null) {
        if (membership_ == null) {
          Membership = new global::Ecliptix.Protobuf.Membership.Membership();
        }
        Membership.MergeFrom(other.Membership);
      }
      if (other.Result != global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult.Succeeded) {
        Result = other.Result;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.HasMinutesUntilRetry) {
        MinutesUntilRetry = other.MinutesUntilRetry;
      }
      availableAccounts_.Add(other.availableAccounts_);
      if (other.activeAccount_ != null) {
        if (activeAccount_ == null) {
          ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();
        }
        ActiveAccount.MergeFrom(other.ActiveAccount);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ServerMac = input.ReadBytes();
            break;
          }
          case 18: {
            if (membership_ == null) {
              Membership = new global::Ecliptix.Protobuf.Membership.Membership();
            }
            input.ReadMessage(Membership);
            break;
          }
          case 24: {
            Result = (global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult) input.ReadEnum();
            break;
          }
          case 34: {
            Message = input.ReadString();
            break;
          }
          case 40: {
            MinutesUntilRetry = input.ReadInt32();
            break;
          }
          case 50: {
            availableAccounts_.AddEntriesFrom(input, _repeated_availableAccounts_codec);
            break;
          }
          case 58: {
            if (activeAccount_ == null) {
              ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();
            }
            input.ReadMessage(ActiveAccount);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ServerMac = input.ReadBytes();
            break;
          }
          case 18: {
            if (membership_ == null) {
              Membership = new global::Ecliptix.Protobuf.Membership.Membership();
            }
            input.ReadMessage(Membership);
            break;
          }
          case 24: {
            Result = (global::Ecliptix.Protobuf.Membership.OpaqueSignInFinalizeResponse.Types.SignInResult) input.ReadEnum();
            break;
          }
          case 34: {
            Message = input.ReadString();
            break;
          }
          case 40: {
            MinutesUntilRetry = input.ReadInt32();
            break;
          }
          case 50: {
            availableAccounts_.AddEntriesFrom(ref input, _repeated_availableAccounts_codec);
            break;
          }
          case 58: {
            if (activeAccount_ == null) {
              ActiveAccount = new global::Ecliptix.Protobuf.Account.Account();
            }
            input.ReadMessage(ActiveAccount);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the OpaqueSignInFinalizeResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum SignInResult {
        [pbr::OriginalName("SUCCEEDED")] Succeeded = 0,
        [pbr::OriginalName("INVALID_CREDENTIALS")] InvalidCredentials = 1,
        [pbr::OriginalName("LOGIN_ATTEMPT_EXCEEDED")] LoginAttemptExceeded = 2,
      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueRecoverySecureKeyInitRequest : pb::IMessage<OpaqueRecoverySecureKeyInitRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueRecoverySecureKeyInitRequest> _parser = new pb::MessageParser<OpaqueRecoverySecureKeyInitRequest>(() => new OpaqueRecoverySecureKeyInitRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueRecoverySecureKeyInitRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecureKeyInitRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecureKeyInitRequest(OpaqueRecoverySecureKeyInitRequest other) : this() {
      peerOprf_ = other.peerOprf_;
      membershipIdentifier_ = other.membershipIdentifier_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecureKeyInitRequest Clone() {
      return new OpaqueRecoverySecureKeyInitRequest(this);
    }

    /// <summary>Field number for the "peer_oprf" field.</summary>
    public const int PeerOprfFieldNumber = 1;
    private pb::ByteString peerOprf_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PeerOprf {
      get { return peerOprf_; }
      set {
        peerOprf_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "membership_identifier" field.</summary>
    public const int MembershipIdentifierFieldNumber = 2;
    private pb::ByteString membershipIdentifier_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString MembershipIdentifier {
      get { return membershipIdentifier_; }
      set {
        membershipIdentifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueRecoverySecureKeyInitRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueRecoverySecureKeyInitRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PeerOprf != other.PeerOprf) return false;
      if (MembershipIdentifier != other.MembershipIdentifier) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (PeerOprf.Length != 0) hash ^= PeerOprf.GetHashCode();
      if (MembershipIdentifier.Length != 0) hash ^= MembershipIdentifier.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (PeerOprf.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerOprf);
      }
      if (MembershipIdentifier.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(MembershipIdentifier);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (PeerOprf.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerOprf);
      }
      if (MembershipIdentifier.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(MembershipIdentifier);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (PeerOprf.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerOprf);
      }
      if (MembershipIdentifier.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MembershipIdentifier);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueRecoverySecureKeyInitRequest other) {
      if (other == null) {
        return;
      }
      if (other.PeerOprf.Length != 0) {
        PeerOprf = other.PeerOprf;
      }
      if (other.MembershipIdentifier.Length != 0) {
        MembershipIdentifier = other.MembershipIdentifier;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PeerOprf = input.ReadBytes();
            break;
          }
          case 18: {
            MembershipIdentifier = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PeerOprf = input.ReadBytes();
            break;
          }
          case 18: {
            MembershipIdentifier = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueRecoverySecureKeyInitResponse : pb::IMessage<OpaqueRecoverySecureKeyInitResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueRecoverySecureKeyInitResponse> _parser = new pb::MessageParser<OpaqueRecoverySecureKeyInitResponse>(() => new OpaqueRecoverySecureKeyInitResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueRecoverySecureKeyInitResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecureKeyInitResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecureKeyInitResponse(OpaqueRecoverySecureKeyInitResponse other) : this() {
      peerOprf_ = other.peerOprf_;
      result_ = other.result_;
      message_ = other.message_;
      membership_ = other.membership_ != null ? other.membership_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecureKeyInitResponse Clone() {
      return new OpaqueRecoverySecureKeyInitResponse(this);
    }

    /// <summary>Field number for the "peer_oprf" field.</summary>
    public const int PeerOprfFieldNumber = 1;
    private pb::ByteString peerOprf_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PeerOprf {
      get { return peerOprf_; }
      set {
        peerOprf_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "result" field.</summary>
    public const int ResultFieldNumber = 2;
    private global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult result_ = global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult Result {
      get { return result_; }
      set {
        result_ = value;
      }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 3;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "membership" field.</summary>
    public const int MembershipFieldNumber = 4;
    private global::Ecliptix.Protobuf.Membership.Membership membership_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Ecliptix.Protobuf.Membership.Membership Membership {
      get { return membership_; }
      set {
        membership_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueRecoverySecureKeyInitResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueRecoverySecureKeyInitResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PeerOprf != other.PeerOprf) return false;
      if (Result != other.Result) return false;
      if (Message != other.Message) return false;
      if (!object.Equals(Membership, other.Membership)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (PeerOprf.Length != 0) hash ^= PeerOprf.GetHashCode();
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded) hash ^= Result.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (membership_ != null) hash ^= Membership.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (PeerOprf.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerOprf);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Result);
      }
      if (HasMessage) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (membership_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Membership);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (PeerOprf.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerOprf);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Result);
      }
      if (HasMessage) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (membership_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Membership);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (PeerOprf.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerOprf);
      }
      if (Result != global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Result);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (membership_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Membership);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueRecoverySecureKeyInitResponse other) {
      if (other == null) {
        return;
      }
      if (other.PeerOprf.Length != 0) {
        PeerOprf = other.PeerOprf;
      }
      if (other.Result != global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult.Succeeded) {
        Result = other.Result;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.membership_ != null) {
        if (membership_ == null) {
          Membership = new global::Ecliptix.Protobuf.Membership.Membership();
        }
        Membership.MergeFrom(other.Membership);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PeerOprf = input.ReadBytes();
            break;
          }
          case 16: {
            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult) input.ReadEnum();
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            if (membership_ == null) {
              Membership = new global::Ecliptix.Protobuf.Membership.Membership();
            }
            input.ReadMessage(Membership);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PeerOprf = input.ReadBytes();
            break;
          }
          case 16: {
            Result = (global::Ecliptix.Protobuf.Membership.OpaqueRecoverySecureKeyInitResponse.Types.RecoveryResult) input.ReadEnum();
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            if (membership_ == null) {
              Membership = new global::Ecliptix.Protobuf.Membership.Membership();
            }
            input.ReadMessage(Membership);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the OpaqueRecoverySecureKeyInitResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum RecoveryResult {
        [pbr::OriginalName("SUCCEEDED")] Succeeded = 0,
        [pbr::OriginalName("INVALID_CREDENTIALS")] InvalidCredentials = 1,
      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueRecoverySecretKeyCompleteRequest : pb::IMessage<OpaqueRecoverySecretKeyCompleteRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueRecoverySecretKeyCompleteRequest> _parser = new pb::MessageParser<OpaqueRecoverySecretKeyCompleteRequest>(() => new OpaqueRecoverySecretKeyCompleteRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueRecoverySecretKeyCompleteRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecretKeyCompleteRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecretKeyCompleteRequest(OpaqueRecoverySecretKeyCompleteRequest other) : this() {
      peerRecoveryRecord_ = other.peerRecoveryRecord_;
      membershipIdentifier_ = other.membershipIdentifier_;
      masterKey_ = other.masterKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecretKeyCompleteRequest Clone() {
      return new OpaqueRecoverySecretKeyCompleteRequest(this);
    }

    /// <summary>Field number for the "peer_recovery_record" field.</summary>
    public const int PeerRecoveryRecordFieldNumber = 1;
    private pb::ByteString peerRecoveryRecord_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PeerRecoveryRecord {
      get { return peerRecoveryRecord_; }
      set {
        peerRecoveryRecord_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "membership_identifier" field.</summary>
    public const int MembershipIdentifierFieldNumber = 2;
    private pb::ByteString membershipIdentifier_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString MembershipIdentifier {
      get { return membershipIdentifier_; }
      set {
        membershipIdentifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "master_key" field.</summary>
    public const int MasterKeyFieldNumber = 3;
    private pb::ByteString masterKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString MasterKey {
      get { return masterKey_; }
      set {
        masterKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueRecoverySecretKeyCompleteRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueRecoverySecretKeyCompleteRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PeerRecoveryRecord != other.PeerRecoveryRecord) return false;
      if (MembershipIdentifier != other.MembershipIdentifier) return false;
      if (MasterKey != other.MasterKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (PeerRecoveryRecord.Length != 0) hash ^= PeerRecoveryRecord.GetHashCode();
      if (MembershipIdentifier.Length != 0) hash ^= MembershipIdentifier.GetHashCode();
      if (MasterKey.Length != 0) hash ^= MasterKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (PeerRecoveryRecord.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerRecoveryRecord);
      }
      if (MembershipIdentifier.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(MembershipIdentifier);
      }
      if (MasterKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(MasterKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (PeerRecoveryRecord.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PeerRecoveryRecord);
      }
      if (MembershipIdentifier.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(MembershipIdentifier);
      }
      if (MasterKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(MasterKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (PeerRecoveryRecord.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PeerRecoveryRecord);
      }
      if (MembershipIdentifier.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MembershipIdentifier);
      }
      if (MasterKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(MasterKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueRecoverySecretKeyCompleteRequest other) {
      if (other == null) {
        return;
      }
      if (other.PeerRecoveryRecord.Length != 0) {
        PeerRecoveryRecord = other.PeerRecoveryRecord;
      }
      if (other.MembershipIdentifier.Length != 0) {
        MembershipIdentifier = other.MembershipIdentifier;
      }
      if (other.MasterKey.Length != 0) {
        MasterKey = other.MasterKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PeerRecoveryRecord = input.ReadBytes();
            break;
          }
          case 18: {
            MembershipIdentifier = input.ReadBytes();
            break;
          }
          case 26: {
            MasterKey = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PeerRecoveryRecord = input.ReadBytes();
            break;
          }
          case 18: {
            MembershipIdentifier = input.ReadBytes();
            break;
          }
          case 26: {
            MasterKey = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpaqueRecoverySecretKeyCompleteResponse : pb::IMessage<OpaqueRecoverySecretKeyCompleteResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpaqueRecoverySecretKeyCompleteResponse> _parser = new pb::MessageParser<OpaqueRecoverySecretKeyCompleteResponse>(() => new OpaqueRecoverySecretKeyCompleteResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpaqueRecoverySecretKeyCompleteResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecretKeyCompleteResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecretKeyCompleteResponse(OpaqueRecoverySecretKeyCompleteResponse other) : this() {
      message_ = other.message_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpaqueRecoverySecretKeyCompleteResponse Clone() {
      return new OpaqueRecoverySecretKeyCompleteResponse(this);
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 1;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpaqueRecoverySecretKeyCompleteResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpaqueRecoverySecretKeyCompleteResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Message != other.Message) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMessage) hash ^= Message.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasMessage) {
        output.WriteRawTag(10);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasMessage) {
        output.WriteRawTag(10);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpaqueRecoverySecretKeyCompleteResponse other) {
      if (other == null) {
        return;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Message = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Message = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AkeServerState : pb::IMessage<AkeServerState>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AkeServerState> _parser = new pb::MessageParser<AkeServerState>(() => new AkeServerState());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AkeServerState> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AkeServerState() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AkeServerState(AkeServerState other) : this() {
      serverEphemeralPrivateKeyBytes_ = other.serverEphemeralPrivateKeyBytes_;
      serverEphemeralPublicKey_ = other.serverEphemeralPublicKey_;
      clientStaticPublicKey_ = other.clientStaticPublicKey_;
      oprfResponse_ = other.oprfResponse_;
      username_ = other.username_;
      registrationRecord_ = other.registrationRecord_;
      expiration_ = other.expiration_ != null ? other.expiration_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AkeServerState Clone() {
      return new AkeServerState(this);
    }

    /// <summary>Field number for the "server_ephemeral_private_key_bytes" field.</summary>
    public const int ServerEphemeralPrivateKeyBytesFieldNumber = 1;
    private pb::ByteString serverEphemeralPrivateKeyBytes_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ServerEphemeralPrivateKeyBytes {
      get { return serverEphemeralPrivateKeyBytes_; }
      set {
        serverEphemeralPrivateKeyBytes_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "server_ephemeral_public_key" field.</summary>
    public const int ServerEphemeralPublicKeyFieldNumber = 2;
    private pb::ByteString serverEphemeralPublicKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ServerEphemeralPublicKey {
      get { return serverEphemeralPublicKey_; }
      set {
        serverEphemeralPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "client_static_public_key" field.</summary>
    public const int ClientStaticPublicKeyFieldNumber = 3;
    private pb::ByteString clientStaticPublicKey_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ClientStaticPublicKey {
      get { return clientStaticPublicKey_; }
      set {
        clientStaticPublicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "oprf_response" field.</summary>
    public const int OprfResponseFieldNumber = 4;
    private pb::ByteString oprfResponse_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString OprfResponse {
      get { return oprfResponse_; }
      set {
        oprfResponse_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "username" field.</summary>
    public const int UsernameFieldNumber = 5;
    private string username_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Username {
      get { return username_; }
      set {
        username_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "registration_record" field.</summary>
    public const int RegistrationRecordFieldNumber = 6;
    private pb::ByteString registrationRecord_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString RegistrationRecord {
      get { return registrationRecord_; }
      set {
        registrationRecord_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "expiration" field.</summary>
    public const int ExpirationFieldNumber = 7;
    private global::Google.Protobuf.WellKnownTypes.Timestamp expiration_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Expiration {
      get { return expiration_; }
      set {
        expiration_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AkeServerState);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AkeServerState other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ServerEphemeralPrivateKeyBytes != other.ServerEphemeralPrivateKeyBytes) return false;
      if (ServerEphemeralPublicKey != other.ServerEphemeralPublicKey) return false;
      if (ClientStaticPublicKey != other.ClientStaticPublicKey) return false;
      if (OprfResponse != other.OprfResponse) return false;
      if (Username != other.Username) return false;
      if (RegistrationRecord != other.RegistrationRecord) return false;
      if (!object.Equals(Expiration, other.Expiration)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ServerEphemeralPrivateKeyBytes.Length != 0) hash ^= ServerEphemeralPrivateKeyBytes.GetHashCode();
      if (ServerEphemeralPublicKey.Length != 0) hash ^= ServerEphemeralPublicKey.GetHashCode();
      if (ClientStaticPublicKey.Length != 0) hash ^= ClientStaticPublicKey.GetHashCode();
      if (OprfResponse.Length != 0) hash ^= OprfResponse.GetHashCode();
      if (Username.Length != 0) hash ^= Username.GetHashCode();
      if (RegistrationRecord.Length != 0) hash ^= RegistrationRecord.GetHashCode();
      if (expiration_ != null) hash ^= Expiration.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ServerEphemeralPrivateKeyBytes.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(ServerEphemeralPrivateKeyBytes);
      }
      if (ServerEphemeralPublicKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(ServerEphemeralPublicKey);
      }
      if (ClientStaticPublicKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(ClientStaticPublicKey);
      }
      if (OprfResponse.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(OprfResponse);
      }
      if (Username.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Username);
      }
      if (RegistrationRecord.Length != 0) {
        output.WriteRawTag(50);
        output.WriteBytes(RegistrationRecord);
      }
      if (expiration_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Expiration);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ServerEphemeralPrivateKeyBytes.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(ServerEphemeralPrivateKeyBytes);
      }
      if (ServerEphemeralPublicKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(ServerEphemeralPublicKey);
      }
      if (ClientStaticPublicKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(ClientStaticPublicKey);
      }
      if (OprfResponse.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(OprfResponse);
      }
      if (Username.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Username);
      }
      if (RegistrationRecord.Length != 0) {
        output.WriteRawTag(50);
        output.WriteBytes(RegistrationRecord);
      }
      if (expiration_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Expiration);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ServerEphemeralPrivateKeyBytes.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerEphemeralPrivateKeyBytes);
      }
      if (ServerEphemeralPublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServerEphemeralPublicKey);
      }
      if (ClientStaticPublicKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ClientStaticPublicKey);
      }
      if (OprfResponse.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(OprfResponse);
      }
      if (Username.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Username);
      }
      if (RegistrationRecord.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RegistrationRecord);
      }
      if (expiration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Expiration);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AkeServerState other) {
      if (other == null) {
        return;
      }
      if (other.ServerEphemeralPrivateKeyBytes.Length != 0) {
        ServerEphemeralPrivateKeyBytes = other.ServerEphemeralPrivateKeyBytes;
      }
      if (other.ServerEphemeralPublicKey.Length != 0) {
        ServerEphemeralPublicKey = other.ServerEphemeralPublicKey;
      }
      if (other.ClientStaticPublicKey.Length != 0) {
        ClientStaticPublicKey = other.ClientStaticPublicKey;
      }
      if (other.OprfResponse.Length != 0) {
        OprfResponse = other.OprfResponse;
      }
      if (other.Username.Length != 0) {
        Username = other.Username;
      }
      if (other.RegistrationRecord.Length != 0) {
        RegistrationRecord = other.RegistrationRecord;
      }
      if (other.expiration_ != null) {
        if (expiration_ == null) {
          Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Expiration.MergeFrom(other.Expiration);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ServerEphemeralPrivateKeyBytes = input.ReadBytes();
            break;
          }
          case 18: {
            ServerEphemeralPublicKey = input.ReadBytes();
            break;
          }
          case 26: {
            ClientStaticPublicKey = input.ReadBytes();
            break;
          }
          case 34: {
            OprfResponse = input.ReadBytes();
            break;
          }
          case 42: {
            Username = input.ReadString();
            break;
          }
          case 50: {
            RegistrationRecord = input.ReadBytes();
            break;
          }
          case 58: {
            if (expiration_ == null) {
              Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Expiration);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ServerEphemeralPrivateKeyBytes = input.ReadBytes();
            break;
          }
          case 18: {
            ServerEphemeralPublicKey = input.ReadBytes();
            break;
          }
          case 26: {
            ClientStaticPublicKey = input.ReadBytes();
            break;
          }
          case 34: {
            OprfResponse = input.ReadBytes();
            break;
          }
          case 42: {
            Username = input.ReadString();
            break;
          }
          case 50: {
            RegistrationRecord = input.ReadBytes();
            break;
          }
          case 58: {
            if (expiration_ == null) {
              Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Expiration);
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AkeSecureKeyResetState : pb::IMessage<AkeSecureKeyResetState>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AkeSecureKeyResetState> _parser = new pb::MessageParser<AkeSecureKeyResetState>(() => new AkeSecureKeyResetState());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AkeSecureKeyResetState> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ecliptix.Protobuf.Membership.OpaqueModelsReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AkeSecureKeyResetState() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AkeSecureKeyResetState(AkeSecureKeyResetState other) : this() {
      username_ = other.username_;
      resetToken_ = other.resetToken_;
      expiration_ = other.expiration_ != null ? other.expiration_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AkeSecureKeyResetState Clone() {
      return new AkeSecureKeyResetState(this);
    }

    /// <summary>Field number for the "username" field.</summary>
    public const int UsernameFieldNumber = 1;
    private string username_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Username {
      get { return username_; }
      set {
        username_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "reset_token" field.</summary>
    public const int ResetTokenFieldNumber = 2;
    private string resetToken_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ResetToken {
      get { return resetToken_; }
      set {
        resetToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "expiration" field.</summary>
    public const int ExpirationFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Timestamp expiration_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Expiration {
      get { return expiration_; }
      set {
        expiration_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AkeSecureKeyResetState);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AkeSecureKeyResetState other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Username != other.Username) return false;
      if (ResetToken != other.ResetToken) return false;
      if (!object.Equals(Expiration, other.Expiration)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Username.Length != 0) hash ^= Username.GetHashCode();
      if (ResetToken.Length != 0) hash ^= ResetToken.GetHashCode();
      if (expiration_ != null) hash ^= Expiration.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Username.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Username);
      }
      if (ResetToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ResetToken);
      }
      if (expiration_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Expiration);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Username.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Username);
      }
      if (ResetToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ResetToken);
      }
      if (expiration_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Expiration);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Username.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Username);
      }
      if (ResetToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ResetToken);
      }
      if (expiration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Expiration);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AkeSecureKeyResetState other) {
      if (other == null) {
        return;
      }
      if (other.Username.Length != 0) {
        Username = other.Username;
      }
      if (other.ResetToken.Length != 0) {
        ResetToken = other.ResetToken;
      }
      if (other.expiration_ != null) {
        if (expiration_ == null) {
          Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Expiration.MergeFrom(other.Expiration);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Username = input.ReadString();
            break;
          }
          case 18: {
            ResetToken = input.ReadString();
            break;
          }
          case 26: {
            if (expiration_ == null) {
              Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Expiration);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Username = input.ReadString();
            break;
          }
          case 18: {
            ResetToken = input.ReadString();
            break;
          }
          case 26: {
            if (expiration_ == null) {
              Expiration = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Expiration);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code

 [2025-11-04T12:57:52.104] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (3.6043ms) ************
{
  "Request_seq": 9359,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 549987,
  "Type": "response"
}
 [2025-11-04T12:57:52.104] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9360,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/OpaqueModels.cs"
  }
}
 [2025-11-04T12:57:52.723] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (618.1400ms) ************
{
  "Request_seq": 9360,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 549991,
  "Type": "response"
}
 [2025-11-04T12:57:52.724] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9361,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/BottomSheetModal/DefaultBottomSheetVariables.cs",
    "Buffer": "using System;\nusing Avalonia.Media;\n\nnamespace Ecliptix.Core.Controls.Modals.BottomSheetModal;\n\npublic static class DefaultBottomSheetVariables\n{\n    public const double MinHeight = 10.0;\n    public const double MaxHeight = 600.0;\n    public const double DefaultWidth = 400.0;\n\n    private const double ContentDelayMs = 40.0;\n\n    public const double DefaultScrimOpacity = 0.15;\n\n    public static readonly SolidColorBrush ScrimBrush = new(Color.Parse(\"#000000\"));\n    public static readonly TimeSpan ContentDelay = TimeSpan.FromMilliseconds(ContentDelayMs);\n\n    public const bool DefaultIsDismissableOnScrimClick = true;\n}\n"
  }
}
 [2025-11-04T12:57:52.724] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/BottomSheetModal/DefaultBottomSheetVariables.cs with new text:
using System;
using Avalonia.Media;

namespace Ecliptix.Core.Controls.Modals.BottomSheetModal;

public static class DefaultBottomSheetVariables
{
    public const double MinHeight = 10.0;
    public const double MaxHeight = 600.0;
    public const double DefaultWidth = 400.0;

    private const double ContentDelayMs = 40.0;

    public const double DefaultScrimOpacity = 0.15;

    public static readonly SolidColorBrush ScrimBrush = new(Color.Parse("#000000"));
    public static readonly TimeSpan ContentDelay = TimeSpan.FromMilliseconds(ContentDelayMs);

    public const bool DefaultIsDismissableOnScrimClick = true;
}

 [2025-11-04T12:57:52.724] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3950ms) ************
{
  "Request_seq": 9361,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550000,
  "Type": "response"
}
 [2025-11-04T12:57:52.724] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9362,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/BottomSheetModal/DefaultBottomSheetVariables.cs"
  }
}
 [2025-11-04T12:57:52.832] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (107.6311ms) ************
{
  "Request_seq": 9362,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550004,
  "Type": "response"
}
 [2025-11-04T12:57:52.833] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9363,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/MobileNumberValidator.cs",
    "Buffer": "using System;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing Ecliptix.Core.Services.Abstractions.Core;\nusing Ecliptix.Core.Services.Membership.Constants;\n\nnamespace Ecliptix.Core.Services.Membership;\n\npublic static partial class MobileNumberValidator\n{\n    public static string Validate(string mobileNumber, ILocalizationService localizationService)\n    {\n        List<(Func<string, bool> IsInvalid, string ErrorMessageKey, object[]? Args)> validationRules =\n        [\n            (string.IsNullOrWhiteSpace, MobileNumberValidatorConstants.LocalizationKeys.CannotBeEmpty, null),\n            (s => !s.StartsWith(MobileNumberValidatorConstants.ValidationRules.CountryCodePrefix),\n                MobileNumberValidatorConstants.LocalizationKeys.MustStartWithCountryCode, null),\n            (s => s.Length > 1 && ContainsNonDigitsRegex().IsMatch(s[1..]),\n                MobileNumberValidatorConstants.LocalizationKeys.ContainsNonDigits, null),\n            (s => s.Length is < MobileNumberValidatorConstants.ValidationRules.MinDigits + 1\n                or > MobileNumberValidatorConstants.ValidationRules.MaxDigits + 1,\n                MobileNumberValidatorConstants.LocalizationKeys.IncorrectLength,\n                [MobileNumberValidatorConstants.ValidationRules.MinDigits,\n                 MobileNumberValidatorConstants.ValidationRules.MaxDigits])\n        ];\n\n        foreach ((Func<string, bool> isInvalid, string errorMessageKey, object[]? args) in validationRules)\n        {\n            if (isInvalid(mobileNumber))\n            {\n                string message = localizationService[errorMessageKey];\n                return args != null ? string.Format(message, args) : message;\n            }\n        }\n\n        return string.Empty;\n    }\n\n    [GeneratedRegex(@\"\\D\")]\n    private static partial Regex ContainsNonDigitsRegex();\n}\n"
  }
}
 [2025-11-04T12:57:52.834] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/MobileNumberValidator.cs with new text:
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Ecliptix.Core.Services.Abstractions.Core;
using Ecliptix.Core.Services.Membership.Constants;

namespace Ecliptix.Core.Services.Membership;

public static partial class MobileNumberValidator
{
    public static string Validate(string mobileNumber, ILocalizationService localizationService)
    {
        List<(Func<string, bool> IsInvalid, string ErrorMessageKey, object[]? Args)> validationRules =
        [
            (string.IsNullOrWhiteSpace, MobileNumberValidatorConstants.LocalizationKeys.CannotBeEmpty, null),
            (s => !s.StartsWith(MobileNumberValidatorConstants.ValidationRules.CountryCodePrefix),
                MobileNumberValidatorConstants.LocalizationKeys.MustStartWithCountryCode, null),
            (s => s.Length > 1 && ContainsNonDigitsRegex().IsMatch(s[1..]),
                MobileNumberValidatorConstants.LocalizationKeys.ContainsNonDigits, null),
            (s => s.Length is < MobileNumberValidatorConstants.ValidationRules.MinDigits + 1
                or > MobileNumberValidatorConstants.ValidationRules.MaxDigits + 1,
                MobileNumberValidatorConstants.LocalizationKeys.IncorrectLength,
                [MobileNumberValidatorConstants.ValidationRules.MinDigits,
                 MobileNumberValidatorConstants.ValidationRules.MaxDigits])
        ];

        foreach ((Func<string, bool> isInvalid, string errorMessageKey, object[]? args) in validationRules)
        {
            if (isInvalid(mobileNumber))
            {
                string message = localizationService[errorMessageKey];
                return args != null ? string.Format(message, args) : message;
            }
        }

        return string.Empty;
    }

    [GeneratedRegex(@"\D")]
    private static partial Regex ContainsNonDigitsRegex();
}

 [2025-11-04T12:57:52.834] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.4616ms) ************
{
  "Request_seq": 9363,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550008,
  "Type": "response"
}
 [2025-11-04T12:57:52.834] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9364,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/MobileNumberValidator.cs"
  }
}
 [2025-11-04T12:57:52.955] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (121.0315ms) ************
{
  "Request_seq": 9364,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550012,
  "Type": "response"
}
 [2025-11-04T12:57:52.956] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9365,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/Views/Components/WelcomeView.axaml.cs",
    "Buffer": "using Avalonia.Controls;\nusing Avalonia.Markup.Xaml;\n\nnamespace Ecliptix.Core.Features.Main.Views.Components;\n\npublic partial class WelcomeView : UserControl\n{\n    public WelcomeView()\n    {\n        AvaloniaXamlLoader.Load(this);\n    }\n}\n"
  }
}
 [2025-11-04T12:57:52.956] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/Views/Components/WelcomeView.axaml.cs with new text:
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace Ecliptix.Core.Features.Main.Views.Components;

public partial class WelcomeView : UserControl
{
    public WelcomeView()
    {
        AvaloniaXamlLoader.Load(this);
    }
}

 [2025-11-04T12:57:52.956] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3191ms) ************
{
  "Request_seq": 9365,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550016,
  "Type": "response"
}
 [2025-11-04T12:57:52.956] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9366,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/Views/Components/WelcomeView.axaml.cs"
  }
}
 [2025-11-04T12:57:53.052] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (96.0360ms) ************
{
  "Request_seq": 9366,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550020,
  "Type": "response"
}
 [2025-11-04T12:57:53.052] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9367,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/MVVM/ReactiveUIViewLocatorAdapter.cs",
    "Buffer": "using System;\nusing System.Diagnostics.CodeAnalysis;\nusing Ecliptix.Utilities;\nusing ReactiveUI;\nusing Serilog;\n\nnamespace Ecliptix.Core.Core.MVVM;\n\npublic class ReactiveUiViewLocatorAdapter(Abstractions.IViewLocator moduleViewLocator) : IViewLocator\n{\n    [UnconditionalSuppressMessage(\"Trimming\", \"IL2026\",\n        Justification = \"ViewLocator is registered with explicit view/viewmodel mappings at startup\")]\n    public IViewFor? ResolveView<T>(T? viewModel, string? contract = null)\n    {\n        if (object.Equals(viewModel, default(T)))\n        {\n            return null;\n        }\n\n        Option<object> viewOption = moduleViewLocator.ResolveView(viewModel);\n\n        if (!viewOption.IsSome)\n        {\n            return null;\n        }\n\n        object view = viewOption.Value!;\n\n        if (view is not IViewFor viewForInstance)\n        {\n            return null;\n        }\n\n        viewForInstance.ViewModel ??= viewModel;\n        return viewForInstance;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:53.053] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/MVVM/ReactiveUIViewLocatorAdapter.cs with new text:
using System;
using System.Diagnostics.CodeAnalysis;
using Ecliptix.Utilities;
using ReactiveUI;
using Serilog;

namespace Ecliptix.Core.Core.MVVM;

public class ReactiveUiViewLocatorAdapter(Abstractions.IViewLocator moduleViewLocator) : IViewLocator
{
    [UnconditionalSuppressMessage("Trimming", "IL2026",
        Justification = "ViewLocator is registered with explicit view/viewmodel mappings at startup")]
    public IViewFor? ResolveView<T>(T? viewModel, string? contract = null)
    {
        if (object.Equals(viewModel, default(T)))
        {
            return null;
        }

        Option<object> viewOption = moduleViewLocator.ResolveView(viewModel);

        if (!viewOption.IsSome)
        {
            return null;
        }

        object view = viewOption.Value!;

        if (view is not IViewFor viewForInstance)
        {
            return null;
        }

        viewForInstance.ViewModel ??= viewModel;
        return viewForInstance;
    }
}

 [2025-11-04T12:57:53.053] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.4062ms) ************
{
  "Request_seq": 9367,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550024,
  "Type": "response"
}
 [2025-11-04T12:57:53.053] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9368,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/MVVM/ReactiveUIViewLocatorAdapter.cs"
  }
}
 [2025-11-04T12:57:53.164] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (111.1959ms) ************
{
  "Request_seq": 9368,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550028,
  "Type": "response"
}
 [2025-11-04T12:57:53.165] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9369,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleResourceManager.cs",
    "Buffer": "using System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing Ecliptix.Core.Core.Abstractions;\nusing Microsoft.Extensions.DependencyInjection;\nusing Serilog;\n\nnamespace Ecliptix.Core.Core.Modularity;\n\ninternal sealed class ModuleServiceContext(IServiceProvider parentProvider)\n{\n    public T GetParentService<T>() where T : notnull => parentProvider.GetRequiredService<T>();\n}\n\ninternal class ModuleResourceManager(IServiceProvider serviceProvider) : IDisposable\n{\n    private readonly ConcurrentDictionary<string, IModuleScope> _moduleScopes = new();\n    private bool _disposed;\n\n    public IModuleScope CreateModuleScope(string moduleName, Action<IServiceCollection>? configureServices = null)\n    {\n        IServiceScope serviceScope;\n\n        if (configureServices != null)\n        {\n            IServiceScope parentScope = serviceProvider.CreateScope();\n            ServiceCollection moduleServices = new();\n\n            ModuleServiceContext context = new(parentScope.ServiceProvider);\n            moduleServices.AddSingleton(context);\n\n            AutoForwardCoreServices(moduleServices, context);\n\n            configureServices(moduleServices);\n\n            ServiceProvider moduleServiceProvider = moduleServices.BuildServiceProvider();\n            serviceScope = new CompositeServiceScope(moduleServiceProvider, parentScope);\n        }\n        else\n        {\n            serviceScope = serviceProvider.CreateScope();\n        }\n\n        ModuleScope moduleScope = new(moduleName, serviceScope);\n\n        if (!_moduleScopes.TryAdd(moduleName, moduleScope))\n        {\n            moduleScope.Dispose();\n            throw new InvalidOperationException($\"Module scope for '{moduleName}' already exists\");\n        }\n\n        Log.Information(\"Created module scope for {ModuleName}\", moduleName);\n\n        return moduleScope;\n    }\n\n    private static void AutoForwardCoreServices(IServiceCollection moduleServices, ModuleServiceContext context)\n    {\n        moduleServices.AddSingleton(context.GetParentService<Core.Messaging.Services.IConnectivityService>());\n        moduleServices.AddSingleton(context.GetParentService<Core.Messaging.Services.IBottomSheetService>());\n        moduleServices.AddSingleton(context.GetParentService<Core.Messaging.Services.ILanguageDetectionService>());\n        moduleServices.AddSingleton(context.GetParentService<Infrastructure.Network.Core.Providers.NetworkProvider>());\n        moduleServices.AddSingleton(context.GetParentService<Infrastructure.Network.Abstractions.Core.IInternetConnectivityObserver>());\n        moduleServices.AddSingleton(context.GetParentService<Infrastructure.Network.Abstractions.Transport.IRpcMetaDataProvider>());\n        moduleServices.AddSingleton(context.GetParentService<Infrastructure.Data.Abstractions.IApplicationSecureStorageProvider>());\n        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Core.ILocalizationService>());\n        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Core.IApplicationRouter>());\n        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Membership.ILogoutService>());\n        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Authentication.IAuthenticationService>());\n        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Authentication.IOpaqueRegistrationService>());\n        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Authentication.ISecureKeyRecoveryService>());\n        moduleServices.AddSingleton(context.GetParentService<Ecliptix.Core.Controls.Core.ConnectivityNotificationViewModel>());\n\n        Log.Debug(\"Auto-forwarded core services to module service collection\");\n    }\n\n    public bool RemoveModuleScope(string moduleName)\n    {\n        if (_moduleScopes.TryRemove(moduleName, out IModuleScope? scope))\n        {\n            scope.Dispose();\n            Log.Information(\"Removed module scope for {ModuleName}\", moduleName);\n            return true;\n        }\n\n        return false;\n    }\n\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    private void Dispose(bool disposing)\n    {\n        if (_disposed)\n        {\n            return;\n        }\n\n        if (disposing)\n        {\n            foreach (KeyValuePair<string, IModuleScope> kvp in _moduleScopes)\n            {\n                try\n                {\n                    kvp.Value.Dispose();\n                }\n                catch (Exception ex)\n                {\n                    Log.Error(ex, \"Error disposing module scope for {ModuleName}\", kvp.Key);\n                }\n            }\n\n            _moduleScopes.Clear();\n        }\n\n        _disposed = true;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:53.165] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleResourceManager.cs with new text:
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using Ecliptix.Core.Core.Abstractions;
using Microsoft.Extensions.DependencyInjection;
using Serilog;

namespace Ecliptix.Core.Core.Modularity;

internal sealed class ModuleServiceContext(IServiceProvider parentProvider)
{
    public T GetParentService<T>() where T : notnull => parentProvider.GetRequiredService<T>();
}

internal class ModuleResourceManager(IServiceProvider serviceProvider) : IDisposable
{
    private readonly ConcurrentDictionary<string, IModuleScope> _moduleScopes = new();
    private bool _disposed;

    public IModuleScope CreateModuleScope(string moduleName, Action<IServiceCollection>? configureServices = null)
    {
        IServiceScope serviceScope;

        if (configureServices != null)
        {
            IServiceScope parentScope = serviceProvider.CreateScope();
            ServiceCollection moduleServices = new();

            ModuleServiceContext context = new(parentScope.ServiceProvider);
            moduleServices.AddSingleton(context);

            AutoForwardCoreServices(moduleServices, context);

            configureServices(moduleServices);

            ServiceProvider moduleServiceProvider = moduleServices.BuildServiceProvider();
            serviceScope = new CompositeServiceScope(moduleServiceProvider, parentScope);
        }
        else
        {
            serviceScope = serviceProvider.CreateScope();
        }

        ModuleScope moduleScope = new(moduleName, serviceScope);

        if (!_moduleScopes.TryAdd(moduleName, moduleScope))
        {
            moduleScope.Dispose();
            throw new InvalidOperationException($"Module scope for '{moduleName}' already exists");
        }

        Log.Information("Created module scope for {ModuleName}", moduleName);

        return moduleScope;
    }

    private static void AutoForwardCoreServices(IServiceCollection moduleServices, ModuleServiceContext context)
    {
        moduleServices.AddSingleton(context.GetParentService<Core.Messaging.Services.IConnectivityService>());
        moduleServices.AddSingleton(context.GetParentService<Core.Messaging.Services.IBottomSheetService>());
        moduleServices.AddSingleton(context.GetParentService<Core.Messaging.Services.ILanguageDetectionService>());
        moduleServices.AddSingleton(context.GetParentService<Infrastructure.Network.Core.Providers.NetworkProvider>());
        moduleServices.AddSingleton(context.GetParentService<Infrastructure.Network.Abstractions.Core.IInternetConnectivityObserver>());
        moduleServices.AddSingleton(context.GetParentService<Infrastructure.Network.Abstractions.Transport.IRpcMetaDataProvider>());
        moduleServices.AddSingleton(context.GetParentService<Infrastructure.Data.Abstractions.IApplicationSecureStorageProvider>());
        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Core.ILocalizationService>());
        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Core.IApplicationRouter>());
        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Membership.ILogoutService>());
        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Authentication.IAuthenticationService>());
        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Authentication.IOpaqueRegistrationService>());
        moduleServices.AddSingleton(context.GetParentService<Services.Abstractions.Authentication.ISecureKeyRecoveryService>());
        moduleServices.AddSingleton(context.GetParentService<Ecliptix.Core.Controls.Core.ConnectivityNotificationViewModel>());

        Log.Debug("Auto-forwarded core services to module service collection");
    }

    public bool RemoveModuleScope(string moduleName)
    {
        if (_moduleScopes.TryRemove(moduleName, out IModuleScope? scope))
        {
            scope.Dispose();
            Log.Information("Removed module scope for {ModuleName}", moduleName);
            return true;
        }

        return false;
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    private void Dispose(bool disposing)
    {
        if (_disposed)
        {
            return;
        }

        if (disposing)
        {
            foreach (KeyValuePair<string, IModuleScope> kvp in _moduleScopes)
            {
                try
                {
                    kvp.Value.Dispose();
                }
                catch (Exception ex)
                {
                    Log.Error(ex, "Error disposing module scope for {ModuleName}", kvp.Key);
                }
            }

            _moduleScopes.Clear();
        }

        _disposed = true;
    }
}

 [2025-11-04T12:57:53.165] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3927ms) ************
{
  "Request_seq": 9369,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550032,
  "Type": "response"
}
 [2025-11-04T12:57:53.165] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9370,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleResourceManager.cs"
  }
}
 [2025-11-04T12:57:53.285] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (119.7882ms) ************
{
  "Request_seq": 9370,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": [
      {
        "AdditionalLocations": [
          {
            "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleResourceManager.cs",
            "Line": 15,
            "Column": 16,
            "EndLine": 15,
            "EndColumn": 37,
            "Text": "Provide 'protected' overridable implementation of 'Dispose(bool)' on 'ModuleResourceManager' or mark the type as 'sealed'."
          },
          {
            "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleResourceManager.cs",
            "Line": 89,
            "Column": 17,
            "EndLine": 89,
            "EndColumn": 24,
            "Text": "'ModuleResourceManager.Dispose()' should also call 'Dispose(true)'."
          }
        ],
        "QuickFixes": [],
        "LogLevel": "Warning",
        "Id": "S3881",
        "Tags": [],
        "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleResourceManager.cs",
        "Line": 15,
        "Column": 16,
        "EndLine": 15,
        "EndColumn": 37,
        "Text": "Fix this implementation of 'IDisposable' to conform to the dispose pattern.",
        "Projects": [
          "Ecliptix.Core"
        ]
      }
    ]
  },
  "Seq": 550036,
  "Type": "response"
}
 [2025-11-04T12:57:53.287] [sonarlint-analysis-scheduler] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleResourceManager.cs
 [2025-11-04T12:57:53.289] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9371,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/SecureKeyStrength.cs",
    "Buffer": "namespace Ecliptix.Core.Services.Membership;\n\npublic enum SecureKeyStrength\n{\n    Invalid,\n    VeryWeak,\n    Weak,\n    Good,\n    Strong,\n    VeryStrong\n}\n"
  }
}
 [2025-11-04T12:57:53.289] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/SecureKeyStrength.cs with new text:
namespace Ecliptix.Core.Services.Membership;

public enum SecureKeyStrength
{
    Invalid,
    VeryWeak,
    Weak,
    Good,
    Strong,
    VeryStrong
}

 [2025-11-04T12:57:53.289] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3440ms) ************
{
  "Request_seq": 9371,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550041,
  "Type": "response"
}
 [2025-11-04T12:57:53.289] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9372,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/SecureKeyStrength.cs"
  }
}
 [2025-11-04T12:57:53.382] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (93.1029ms) ************
{
  "Request_seq": 9372,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550045,
  "Type": "response"
}
 [2025-11-04T12:57:53.383] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9373,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/MessageBus.cs",
    "Buffer": "using System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Reactive.Disposables;\nusing System.Reactive.Linq;\nusing System.Reactive.Subjects;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Ecliptix.Core.Core.Messaging.Subscriptions;\nusing Ecliptix.Core.Core.Utilities;\n\nnamespace Ecliptix.Core.Core.Messaging;\n\npublic sealed class MessageBus : IMessageBus\n{\n    private readonly SubscriptionManager _subscriptionManager;\n    private readonly ConcurrentDictionary<string, IMessageRequest> _pendingRequests = new();\n\n    private readonly ConcurrentDictionary<Type, ReactiveSubjectWrapper> _reactiveSubjects = new();\n    private readonly Timer _subjectCleanupTimer;\n\n    private long _totalMessagesPublished;\n    private long _totalRequestsProcessed;\n\n    private bool _disposed;\n    public bool IsDisposed => _disposed;\n\n    public MessageBus()\n    {\n        _subscriptionManager = new SubscriptionManager();\n\n        _subjectCleanupTimer = new Timer(CleanupUnusedSubjects, null, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(2));\n    }\n\n    public IObservable<TMessage> GetEvent<TMessage>() where TMessage : class\n    {\n        if (_disposed)\n        {\n            throw new ObjectDisposedException(nameof(MessageBus));\n        }\n\n        ReactiveSubjectWrapper wrapper = _reactiveSubjects.GetOrAdd(\n            typeof(TMessage),\n            _ => new ReactiveSubjectWrapper(new Subject<TMessage>()));\n\n        wrapper.IncrementReference();\n\n        IObservable<TMessage> observable = ((Subject<TMessage>)wrapper.Subject).AsObservable();\n\n        return Observable.Create<TMessage>(observer =>\n        {\n            IDisposable subscription = observable.Subscribe(observer);\n            return new CompositeDisposable(subscription, new DisposableAction(() => wrapper.DecrementReference()));\n        });\n    }\n\n    public void Publish<TMessage>(TMessage message) where TMessage : class\n    {\n        if (_disposed)\n        {\n            return;\n        }\n\n        if (_reactiveSubjects.TryGetValue(typeof(TMessage), out ReactiveSubjectWrapper? wrapper))\n        {\n            ((Subject<TMessage>)wrapper.Subject).OnNext(message);\n        }\n\n        Task.Run(async () =>\n        {\n            try\n            {\n                await _subscriptionManager.PublishAsync(message, CancellationToken.None);\n            }\n            catch (Exception ex)\n            {\n                Serilog.Log.Error(ex, \"[MESSAGE-BUS] Exception during fire-and-forget message publication. MessageType: {MessageType}\",\n                    typeof(TMessage).Name);\n            }\n        }).ContinueWith(\n            task =>\n            {\n                if (task.IsFaulted && task.Exception != null)\n                {\n                    Serilog.Log.Error(task.Exception, \"[MESSAGE-BUS] Unhandled exception in message publication\");\n                }\n            },\n            TaskScheduler.Default);\n\n        Interlocked.Increment(ref _totalMessagesPublished);\n    }\n\n    public async Task PublishAsync<TMessage>(TMessage message, CancellationToken cancellationToken = default)\n        where TMessage : class\n    {\n        if (_reactiveSubjects.TryGetValue(typeof(TMessage), out ReactiveSubjectWrapper? wrapper))\n        {\n            ((Subject<TMessage>)wrapper.Subject).OnNext(message);\n        }\n\n        await _subscriptionManager.PublishAsync(message, cancellationToken);\n\n        Interlocked.Increment(ref _totalMessagesPublished);\n    }\n\n    public IDisposable Subscribe<TMessage>(\n        Func<TMessage, Task> handler,\n        SubscriptionLifetime lifetime = SubscriptionLifetime.Strong) where TMessage : class\n    {\n        return Subscribe<TMessage>(_ => true, handler, lifetime, 0);\n    }\n\n    private IDisposable Subscribe<TMessage>(\n        Func<TMessage, bool> filter,\n        Func<TMessage, Task> handler,\n        SubscriptionLifetime lifetime = SubscriptionLifetime.Strong,\n        int priority = 0) where TMessage : class\n    {\n        return _subscriptionManager.Subscribe(filter, handler, lifetime, priority);\n    }\n\n    public async Task<TResponse?> RequestAsync<TRequest, TResponse>(\n        TRequest request,\n        TimeSpan timeout = default,\n        CancellationToken cancellationToken = default)\n        where TRequest : class, IMessageRequest\n        where TResponse : class, IMessageResponse\n    {\n        if (timeout == TimeSpan.Zero)\n        {\n            timeout = request.Timeout;\n        }\n\n        TaskCompletionSource<IMessageResponse> tcs = new();\n        _pendingRequests[request.MessageId] = request;\n\n        try\n        {\n            using CancellationTokenSource timeoutCts =\n                CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);\n            timeoutCts.CancelAfter(timeout);\n\n            IDisposable responseSubscription = Subscribe<TResponse>(\n                response => response.CorrelationId == request.MessageId,\n                response =>\n                {\n                    tcs.SetResult(response);\n                    return Task.CompletedTask;\n                },\n                SubscriptionLifetime.Scoped);\n\n            await PublishAsync(request, cancellationToken);\n\n            Task<IMessageResponse> responseTask = tcs.Task;\n            Task timeoutTask = Task.Delay(timeout, timeoutCts.Token);\n\n            Task completedTask = await Task.WhenAny(responseTask, timeoutTask);\n\n            responseSubscription.Dispose();\n\n            if (completedTask == timeoutTask)\n            {\n                return null;\n            }\n\n            IMessageResponse response = await responseTask;\n            Interlocked.Increment(ref _totalRequestsProcessed);\n\n            return response as TResponse;\n        }\n        finally\n        {\n            _pendingRequests.TryRemove(request.MessageId, out _);\n        }\n    }\n\n    private void CleanupUnusedSubjects(object? state)\n    {\n        if (_disposed)\n        {\n            return;\n        }\n\n        foreach (KeyValuePair<Type, ReactiveSubjectWrapper> kvp in _reactiveSubjects.ToArray())\n        {\n            if (kvp.Value.ReferenceCount == 0 && kvp.Value.IsExpired &&\n                _reactiveSubjects.TryRemove(kvp.Key, out ReactiveSubjectWrapper? removed))\n            {\n                removed.Dispose();\n            }\n        }\n    }\n\n    public void Dispose()\n    {\n        if (!_disposed)\n        {\n            _disposed = true;\n\n            _subjectCleanupTimer?.Dispose();\n\n            foreach (ReactiveSubjectWrapper wrapper in _reactiveSubjects.Values)\n            {\n                wrapper.Dispose();\n            }\n\n            _reactiveSubjects.Clear();\n\n            _subscriptionManager.Dispose();\n\n            _pendingRequests.Clear();\n        }\n    }\n}\n\ninternal sealed class ReactiveSubjectWrapper(object subject) : IDisposable\n{\n    private int _referenceCount;\n    private readonly DateTime _createdAt = DateTime.UtcNow;\n    private bool _disposed;\n\n    public object Subject { get; } = subject;\n    public int ReferenceCount => _referenceCount;\n    public bool IsExpired => DateTime.UtcNow - _createdAt > TimeSpan.FromMinutes(5);\n\n    public void IncrementReference()\n    {\n        if (!_disposed)\n        {\n            Interlocked.Increment(ref _referenceCount);\n        }\n    }\n\n    public void DecrementReference()\n    {\n        if (!_disposed)\n        {\n            Interlocked.Decrement(ref _referenceCount);\n        }\n    }\n\n    public void Dispose()\n    {\n        if (!_disposed)\n        {\n            _disposed = true;\n            if (Subject is Subject<object> typedSubject)\n            {\n                typedSubject.OnCompleted();\n                typedSubject.Dispose();\n            }\n        }\n    }\n}\n"
  }
}
 [2025-11-04T12:57:53.383] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/MessageBus.cs with new text:
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Reactive.Subjects;
using System.Threading;
using System.Threading.Tasks;
using Ecliptix.Core.Core.Messaging.Subscriptions;
using Ecliptix.Core.Core.Utilities;

namespace Ecliptix.Core.Core.Messaging;

public sealed class MessageBus : IMessageBus
{
    private readonly SubscriptionManager _subscriptionManager;
    private readonly ConcurrentDictionary<string, IMessageRequest> _pendingRequests = new();

    private readonly ConcurrentDictionary<Type, ReactiveSubjectWrapper> _reactiveSubjects = new();
    private readonly Timer _subjectCleanupTimer;

    private long _totalMessagesPublished;
    private long _totalRequestsProcessed;

    private bool _disposed;
    public bool IsDisposed => _disposed;

    public MessageBus()
    {
        _subscriptionManager = new SubscriptionManager();

        _subjectCleanupTimer = new Timer(CleanupUnusedSubjects, null, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(2));
    }

    public IObservable<TMessage> GetEvent<TMessage>() where TMessage : class
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(nameof(MessageBus));
        }

        ReactiveSubjectWrapper wrapper = _reactiveSubjects.GetOrAdd(
            typeof(TMessage),
            _ => new ReactiveSubjectWrapper(new Subject<TMessage>()));

        wrapper.IncrementReference();

        IObservable<TMessage> observable = ((Subject<TMessage>)wrapper.Subject).AsObservable();

        return Observable.Create<TMessage>(observer =>
        {
            IDisposable subscription = observable.Subscribe(observer);
            return new CompositeDisposable(subscription, new DisposableAction(() => wrapper.DecrementReference()));
        });
    }

    public void Publish<TMessage>(TMessage message) where TMessage : class
    {
        if (_disposed)
        {
            return;
        }

        if (_reactiveSubjects.TryGetValue(typeof(TMessage), out ReactiveSubjectWrapper? wrapper))
        {
            ((Subject<TMessage>)wrapper.Subject).OnNext(message);
        }

        Task.Run(async () =>
        {
            try
            {
                await _subscriptionManager.PublishAsync(message, CancellationToken.None);
            }
            catch (Exception ex)
            {
                Serilog.Log.Error(ex, "[MESSAGE-BUS] Exception during fire-and-forget message publication. MessageType: {MessageType}",
                    typeof(TMessage).Name);
            }
        }).ContinueWith(
            task =>
            {
                if (task.IsFaulted && task.Exception != null)
                {
                    Serilog.Log.Error(task.Exception, "[MESSAGE-BUS] Unhandled exception in message publication");
                }
            },
            TaskScheduler.Default);

        Interlocked.Increment(ref _totalMessagesPublished);
    }

    public async Task PublishAsync<TMessage>(TMessage message, CancellationToken cancellationToken = default)
        where TMessage : class
    {
        if (_reactiveSubjects.TryGetValue(typeof(TMessage), out ReactiveSubjectWrapper? wrapper))
        {
            ((Subject<TMessage>)wrapper.Subject).OnNext(message);
        }

        await _subscriptionManager.PublishAsync(message, cancellationToken);

        Interlocked.Increment(ref _totalMessagesPublished);
    }

    public IDisposable Subscribe<TMessage>(
        Func<TMessage, Task> handler,
        SubscriptionLifetime lifetime = SubscriptionLifetime.Strong) where TMessage : class
    {
        return Subscribe<TMessage>(_ => true, handler, lifetime, 0);
    }

    private IDisposable Subscribe<TMessage>(
        Func<TMessage, bool> filter,
        Func<TMessage, Task> handler,
        SubscriptionLifetime lifetime = SubscriptionLifetime.Strong,
        int priority = 0) where TMessage : class
    {
        return _subscriptionManager.Subscribe(filter, handler, lifetime, priority);
    }

    public async Task<TResponse?> RequestAsync<TRequest, TResponse>(
        TRequest request,
        TimeSpan timeout = default,
        CancellationToken cancellationToken = default)
        where TRequest : class, IMessageRequest
        where TResponse : class, IMessageResponse
    {
        if (timeout == TimeSpan.Zero)
        {
            timeout = request.Timeout;
        }

        TaskCompletionSource<IMessageResponse> tcs = new();
        _pendingRequests[request.MessageId] = request;

        try
        {
            using CancellationTokenSource timeoutCts =
                CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            timeoutCts.CancelAfter(timeout);

            IDisposable responseSubscription = Subscribe<TResponse>(
                response => response.CorrelationId == request.MessageId,
                response =>
                {
                    tcs.SetResult(response);
                    return Task.CompletedTask;
                },
                SubscriptionLifetime.Scoped);

            await PublishAsync(request, cancellationToken);

            Task<IMessageResponse> responseTask = tcs.Task;
            Task timeoutTask = Task.Delay(timeout, timeoutCts.Token);

            Task completedTask = await Task.WhenAny(responseTask, timeoutTask);

            responseSubscription.Dispose();

            if (completedTask == timeoutTask)
            {
                return null;
            }

            IMessageResponse response = await responseTask;
            Interlocked.Increment(ref _totalRequestsProcessed);

            return response as TResponse;
        }
        finally
        {
            _pendingRequests.TryRemove(request.MessageId, out _);
        }
    }

    private void CleanupUnusedSubjects(object? state)
    {
        if (_disposed)
        {
            return;
        }

        foreach (KeyValuePair<Type, ReactiveSubjectWrapper> kvp in _reactiveSubjects.ToArray())
        {
            if (kvp.Value.ReferenceCount == 0 && kvp.Value.IsExpired &&
                _reactiveSubjects.TryRemove(kvp.Key, out ReactiveSubjectWrapper? removed))
            {
                removed.Dispose();
            }
        }
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;

            _subjectCleanupTimer?.Dispose();

            foreach (ReactiveSubjectWrapper wrapper in _reactiveSubjects.Values)
            {
                wrapper.Dispose();
            }

            _reactiveSubjects.Clear();

            _subscriptionManager.Dispose();

            _pendingRequests.Clear();
        }
    }
}

internal sealed class ReactiveSubjectWrapper(object subject) : IDisposable
{
    private int _referenceCount;
    private readonly DateTime _createdAt = DateTime.UtcNow;
    private bool _disposed;

    public object Subject { get; } = subject;
    public int ReferenceCount => _referenceCount;
    public bool IsExpired => DateTime.UtcNow - _createdAt > TimeSpan.FromMinutes(5);

    public void IncrementReference()
    {
        if (!_disposed)
        {
            Interlocked.Increment(ref _referenceCount);
        }
    }

    public void DecrementReference()
    {
        if (!_disposed)
        {
            Interlocked.Decrement(ref _referenceCount);
        }
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;
            if (Subject is Subject<object> typedSubject)
            {
                typedSubject.OnCompleted();
                typedSubject.Dispose();
            }
        }
    }
}

 [2025-11-04T12:57:53.384] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3921ms) ************
{
  "Request_seq": 9373,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550048,
  "Type": "response"
}
 [2025-11-04T12:57:53.384] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9374,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/MessageBus.cs"
  }
}
 [2025-11-04T12:57:53.537] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (153.6429ms) ************
{
  "Request_seq": 9374,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550052,
  "Type": "response"
}
 [2025-11-04T12:57:53.544] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9375,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/ReceiveStreamRpcServices.cs",
    "Buffer": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reactive.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Ecliptix.Core.Services.Abstractions.Network;\nusing Ecliptix.Protobuf.Common;\nusing Ecliptix.Protobuf.Membership;\nusing Ecliptix.Utilities;\nusing Ecliptix.Utilities.Failures.Network;\nusing Grpc.Core;\n\nnamespace Ecliptix.Core.Services.Network.Rpc;\n\npublic sealed class ReceiveStreamRpcServices : IReceiveStreamRpcServices\n{\n    private readonly\n        Dictionary<RpcServiceType, Func<ServiceRequest, CancellationToken, Result<RpcFlow, NetworkFailure>>>\n        _serviceHandlers;\n\n    private readonly AuthVerificationServices.AuthVerificationServicesClient _authenticationServicesClient;\n    private readonly IGrpcErrorProcessor _errorProcessor;\n    private readonly IGrpcCallOptionsFactory _callOptionsFactory;\n\n    public ReceiveStreamRpcServices(\n        AuthVerificationServices.AuthVerificationServicesClient authenticationServicesClient,\n        IGrpcErrorProcessor errorProcessor,\n        IGrpcCallOptionsFactory callOptionsFactory)\n    {\n        _authenticationServicesClient = authenticationServicesClient;\n        _errorProcessor = errorProcessor;\n        _callOptionsFactory = callOptionsFactory;\n        _serviceHandlers =\n            new Dictionary<RpcServiceType, Func<ServiceRequest, CancellationToken, Result<RpcFlow, NetworkFailure>>>\n            {\n                { RpcServiceType.InitiateVerification, InitiateVerification }\n            };\n    }\n\n    public Task<Result<RpcFlow, NetworkFailure>> ProcessRequest(ServiceRequest request,\n        CancellationToken token)\n    {\n        if (_serviceHandlers.TryGetValue(\n                request.RpcServiceMethod,\n                out Func<ServiceRequest, CancellationToken, Result<RpcFlow, NetworkFailure>>? handler))\n        {\n            try\n            {\n                Result<RpcFlow, NetworkFailure> result = handler(request, token);\n                return Task.FromResult(result);\n            }\n            catch (RpcException rpcEx)\n            {\n                return Task.FromResult(Result<RpcFlow, NetworkFailure>.Err(_errorProcessor.Process(rpcEx)));\n            }\n            catch (Exception ex)\n            {\n                return Task.FromResult(Result<RpcFlow, NetworkFailure>.Err(\n                    NetworkFailure.DataCenterNotResponding(ex.Message, ex)\n                ));\n            }\n        }\n\n        return Task.FromResult(Result<RpcFlow, NetworkFailure>.Err(\n            NetworkFailure.InvalidRequestType(NetworkServiceMessages.RpcService.UnsupportedServiceMethod)\n        ));\n    }\n\n    private Result<RpcFlow, NetworkFailure> InitiateVerification(ServiceRequest request,\n        CancellationToken token)\n    {\n        try\n        {\n            CallOptions callOptions = _callOptionsFactory.Create(\n                RpcServiceType.InitiateVerification,\n                request.RequestContext,\n                token);\n\n            AsyncServerStreamingCall<SecureEnvelope> streamingCall =\n                _authenticationServicesClient.InitiateVerification(request.Payload, callOptions);\n\n            IAsyncEnumerable<Result<SecureEnvelope, NetworkFailure>> stream =\n                streamingCall.ResponseStream.ReadAllAsync(token)\n                    .ToObservable()\n                    .Select(Result<SecureEnvelope, NetworkFailure>.Ok)\n                    .Catch<Result<SecureEnvelope, NetworkFailure>, RpcException>(rpcEx =>\n                        Observable.Return(Result<SecureEnvelope, NetworkFailure>.Err(\n                            _errorProcessor.Process(rpcEx))))\n                    .Catch<Result<SecureEnvelope, NetworkFailure>, Exception>(ex =>\n                        Observable.Return(Result<SecureEnvelope, NetworkFailure>.Err(\n                            NetworkFailure.DataCenterNotResponding(ex.Message, ex))))\n                    .ToAsyncEnumerable();\n\n            return Result<RpcFlow, NetworkFailure>.Ok(new RpcFlow.InboundStream(stream));\n        }\n        catch (RpcException rpcEx)\n        {\n            return Result<RpcFlow, NetworkFailure>.Err(_errorProcessor.Process(rpcEx));\n        }\n        catch (Exception ex)\n        {\n            return Result<RpcFlow, NetworkFailure>.Err(\n                NetworkFailure.DataCenterNotResponding(ex.Message, ex));\n        }\n    }\n}\n"
  }
}
 [2025-11-04T12:57:53.544] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/ReceiveStreamRpcServices.cs with new text:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;
using Ecliptix.Core.Services.Abstractions.Network;
using Ecliptix.Protobuf.Common;
using Ecliptix.Protobuf.Membership;
using Ecliptix.Utilities;
using Ecliptix.Utilities.Failures.Network;
using Grpc.Core;

namespace Ecliptix.Core.Services.Network.Rpc;

public sealed class ReceiveStreamRpcServices : IReceiveStreamRpcServices
{
    private readonly
        Dictionary<RpcServiceType, Func<ServiceRequest, CancellationToken, Result<RpcFlow, NetworkFailure>>>
        _serviceHandlers;

    private readonly AuthVerificationServices.AuthVerificationServicesClient _authenticationServicesClient;
    private readonly IGrpcErrorProcessor _errorProcessor;
    private readonly IGrpcCallOptionsFactory _callOptionsFactory;

    public ReceiveStreamRpcServices(
        AuthVerificationServices.AuthVerificationServicesClient authenticationServicesClient,
        IGrpcErrorProcessor errorProcessor,
        IGrpcCallOptionsFactory callOptionsFactory)
    {
        _authenticationServicesClient = authenticationServicesClient;
        _errorProcessor = errorProcessor;
        _callOptionsFactory = callOptionsFactory;
        _serviceHandlers =
            new Dictionary<RpcServiceType, Func<ServiceRequest, CancellationToken, Result<RpcFlow, NetworkFailure>>>
            {
                { RpcServiceType.InitiateVerification, InitiateVerification }
            };
    }

    public Task<Result<RpcFlow, NetworkFailure>> ProcessRequest(ServiceRequest request,
        CancellationToken token)
    {
        if (_serviceHandlers.TryGetValue(
                request.RpcServiceMethod,
                out Func<ServiceRequest, CancellationToken, Result<RpcFlow, NetworkFailure>>? handler))
        {
            try
            {
                Result<RpcFlow, NetworkFailure> result = handler(request, token);
                return Task.FromResult(result);
            }
            catch (RpcException rpcEx)
            {
                return Task.FromResult(Result<RpcFlow, NetworkFailure>.Err(_errorProcessor.Process(rpcEx)));
            }
            catch (Exception ex)
            {
                return Task.FromResult(Result<RpcFlow, NetworkFailure>.Err(
                    NetworkFailure.DataCenterNotResponding(ex.Message, ex)
                ));
            }
        }

        return Task.FromResult(Result<RpcFlow, NetworkFailure>.Err(
            NetworkFailure.InvalidRequestType(NetworkServiceMessages.RpcService.UnsupportedServiceMethod)
        ));
    }

    private Result<RpcFlow, NetworkFailure> InitiateVerification(ServiceRequest request,
        CancellationToken token)
    {
        try
        {
            CallOptions callOptions = _callOptionsFactory.Create(
                RpcServiceType.InitiateVerification,
                request.RequestContext,
                token);

            AsyncServerStreamingCall<SecureEnvelope> streamingCall =
                _authenticationServicesClient.InitiateVerification(request.Payload, callOptions);

            IAsyncEnumerable<Result<SecureEnvelope, NetworkFailure>> stream =
                streamingCall.ResponseStream.ReadAllAsync(token)
                    .ToObservable()
                    .Select(Result<SecureEnvelope, NetworkFailure>.Ok)
                    .Catch<Result<SecureEnvelope, NetworkFailure>, RpcException>(rpcEx =>
                        Observable.Return(Result<SecureEnvelope, NetworkFailure>.Err(
                            _errorProcessor.Process(rpcEx))))
                    .Catch<Result<SecureEnvelope, NetworkFailure>, Exception>(ex =>
                        Observable.Return(Result<SecureEnvelope, NetworkFailure>.Err(
                            NetworkFailure.DataCenterNotResponding(ex.Message, ex))))
                    .ToAsyncEnumerable();

            return Result<RpcFlow, NetworkFailure>.Ok(new RpcFlow.InboundStream(stream));
        }
        catch (RpcException rpcEx)
        {
            return Result<RpcFlow, NetworkFailure>.Err(_errorProcessor.Process(rpcEx));
        }
        catch (Exception ex)
        {
            return Result<RpcFlow, NetworkFailure>.Err(
                NetworkFailure.DataCenterNotResponding(ex.Message, ex));
        }
    }
}

 [2025-11-04T12:57:53.544] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (5.3485ms) ************
{
  "Request_seq": 9375,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550057,
  "Type": "response"
}
 [2025-11-04T12:57:53.544] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9376,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/ReceiveStreamRpcServices.cs"
  }
}
 [2025-11-04T12:57:53.596] [sonarlint-finding-streamer] DEBUG sonarlint - Reporting 455 issues for configuration scope /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/.idea/.idea.Ecliptix-Desktop/.idea/misc.xml_rider.module
 [2025-11-04T12:57:53.667] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (123.4625ms) ************
{
  "Request_seq": 9376,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550061,
  "Type": "response"
}
 [2025-11-04T12:57:53.669] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9377,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/MainModule.cs",
    "Buffer": "using System.Threading.Tasks;\nusing Ecliptix.Core.Core.Abstractions;\nusing Ecliptix.Core.Core.Communication;\nusing Ecliptix.Core.Core.Modularity;\nusing Microsoft.Extensions.Logging;\nusing Serilog;\n\nnamespace Ecliptix.Core.Features.Main;\n\npublic record MainModuleManifest() : ModuleManifest(\n    Priority: 20,\n    LoadingStrategy: ModuleLoadingStrategy.Lazy,\n    Dependencies: []\n);\n\npublic class MainModule : ModuleBase<MainModuleManifest>\n{\n    public override ModuleIdentifier Id => ModuleIdentifier.Main;\n    public override MainModuleManifest Manifest { get; } = new();\n\n    public override async Task SetupMessageHandlersAsync(IModuleMessageBus messageBus)\n    {\n        await messageBus.PublishAsync(new ModuleInitializedEvent\n        {\n            ModuleName = Id.ToName()\n        });\n\n        Log.Information(\"Main module message handlers setup completed\");\n    }\n}\n"
  }
}
 [2025-11-04T12:57:53.669] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/MainModule.cs with new text:
using System.Threading.Tasks;
using Ecliptix.Core.Core.Abstractions;
using Ecliptix.Core.Core.Communication;
using Ecliptix.Core.Core.Modularity;
using Microsoft.Extensions.Logging;
using Serilog;

namespace Ecliptix.Core.Features.Main;

public record MainModuleManifest() : ModuleManifest(
    Priority: 20,
    LoadingStrategy: ModuleLoadingStrategy.Lazy,
    Dependencies: []
);

public class MainModule : ModuleBase<MainModuleManifest>
{
    public override ModuleIdentifier Id => ModuleIdentifier.Main;
    public override MainModuleManifest Manifest { get; } = new();

    public override async Task SetupMessageHandlersAsync(IModuleMessageBus messageBus)
    {
        await messageBus.PublishAsync(new ModuleInitializedEvent
        {
            ModuleName = Id.ToName()
        });

        Log.Information("Main module message handlers setup completed");
    }
}

 [2025-11-04T12:57:53.669] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.5245ms) ************
{
  "Request_seq": 9377,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550065,
  "Type": "response"
}
 [2025-11-04T12:57:53.669] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9378,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/MainModule.cs"
  }
}
 [2025-11-04T12:57:53.775] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (105.4708ms) ************
{
  "Request_seq": 9378,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550069,
  "Type": "response"
}
 [2025-11-04T12:57:53.776] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9379,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Sodium/SodiumFailureExtensions.cs",
    "Buffer": "using Ecliptix.Utilities.Failures.EcliptixProtocol;\n\nnamespace Ecliptix.Utilities.Failures.Sodium;\n\npublic static class SodiumFailureExtensions\n{\n    public static EcliptixProtocolFailure ToEcliptixProtocolFailure(this SodiumFailure sodiumFailure)\n    {\n        return sodiumFailure.Type switch\n        {\n            SodiumFailureType.InitializationFailed => EcliptixProtocolFailure.Generic(sodiumFailure.Message,\n                sodiumFailure.InnerException),\n            SodiumFailureType.LibraryNotFound => EcliptixProtocolFailure.Generic(sodiumFailure.Message,\n                sodiumFailure.InnerException),\n            SodiumFailureType.AllocationFailed => EcliptixProtocolFailure.AllocationFailed(sodiumFailure.Message,\n                sodiumFailure.InnerException),\n            SodiumFailureType.MemoryPinningFailed => EcliptixProtocolFailure.PinningFailure(sodiumFailure.Message,\n                sodiumFailure.InnerException),\n            SodiumFailureType.SecureWipeFailed => EcliptixProtocolFailure.MemoryBufferError(sodiumFailure.Message,\n                sodiumFailure.InnerException),\n            SodiumFailureType.MemoryProtectionFailed => EcliptixProtocolFailure.MemoryBufferError(sodiumFailure.Message,\n                sodiumFailure.InnerException),\n            SodiumFailureType.NullPointer => EcliptixProtocolFailure.ObjectDisposed(sodiumFailure.Message),\n            SodiumFailureType.InvalidBufferSize => EcliptixProtocolFailure.InvalidInput(sodiumFailure.Message),\n            SodiumFailureType.BufferTooSmall => EcliptixProtocolFailure.BufferTooSmall(sodiumFailure.Message),\n            SodiumFailureType.BufferTooLarge => EcliptixProtocolFailure.DataTooLarge(sodiumFailure.Message),\n            _ => EcliptixProtocolFailure.Generic(sodiumFailure.Message, sodiumFailure.InnerException)\n        };\n    }\n}\n\npublic static class ResultSodiumExtensions\n{\n    public static Result<T, EcliptixProtocolFailure> MapSodiumFailure<T>(this Result<T, SodiumFailure> result)\n    {\n        return result.IsOk\n            ? Result<T, EcliptixProtocolFailure>.Ok(result.Unwrap())\n            : Result<T, EcliptixProtocolFailure>.Err(result.UnwrapErr().ToEcliptixProtocolFailure());\n    }\n}\n"
  }
}
 [2025-11-04T12:57:53.776] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Sodium/SodiumFailureExtensions.cs with new text:
using Ecliptix.Utilities.Failures.EcliptixProtocol;

namespace Ecliptix.Utilities.Failures.Sodium;

public static class SodiumFailureExtensions
{
    public static EcliptixProtocolFailure ToEcliptixProtocolFailure(this SodiumFailure sodiumFailure)
    {
        return sodiumFailure.Type switch
        {
            SodiumFailureType.InitializationFailed => EcliptixProtocolFailure.Generic(sodiumFailure.Message,
                sodiumFailure.InnerException),
            SodiumFailureType.LibraryNotFound => EcliptixProtocolFailure.Generic(sodiumFailure.Message,
                sodiumFailure.InnerException),
            SodiumFailureType.AllocationFailed => EcliptixProtocolFailure.AllocationFailed(sodiumFailure.Message,
                sodiumFailure.InnerException),
            SodiumFailureType.MemoryPinningFailed => EcliptixProtocolFailure.PinningFailure(sodiumFailure.Message,
                sodiumFailure.InnerException),
            SodiumFailureType.SecureWipeFailed => EcliptixProtocolFailure.MemoryBufferError(sodiumFailure.Message,
                sodiumFailure.InnerException),
            SodiumFailureType.MemoryProtectionFailed => EcliptixProtocolFailure.MemoryBufferError(sodiumFailure.Message,
                sodiumFailure.InnerException),
            SodiumFailureType.NullPointer => EcliptixProtocolFailure.ObjectDisposed(sodiumFailure.Message),
            SodiumFailureType.InvalidBufferSize => EcliptixProtocolFailure.InvalidInput(sodiumFailure.Message),
            SodiumFailureType.BufferTooSmall => EcliptixProtocolFailure.BufferTooSmall(sodiumFailure.Message),
            SodiumFailureType.BufferTooLarge => EcliptixProtocolFailure.DataTooLarge(sodiumFailure.Message),
            _ => EcliptixProtocolFailure.Generic(sodiumFailure.Message, sodiumFailure.InnerException)
        };
    }
}

public static class ResultSodiumExtensions
{
    public static Result<T, EcliptixProtocolFailure> MapSodiumFailure<T>(this Result<T, SodiumFailure> result)
    {
        return result.IsOk
            ? Result<T, EcliptixProtocolFailure>.Ok(result.Unwrap())
            : Result<T, EcliptixProtocolFailure>.Err(result.UnwrapErr().ToEcliptixProtocolFailure());
    }
}

 [2025-11-04T12:57:53.776] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2775ms) ************
{
  "Request_seq": 9379,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550073,
  "Type": "response"
}
 [2025-11-04T12:57:53.776] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9380,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Sodium/SodiumFailureExtensions.cs"
  }
}
 [2025-11-04T12:57:53.837] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (60.6231ms) ************
{
  "Request_seq": 9380,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550077,
  "Type": "response"
}
 [2025-11-04T12:57:53.837] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9381,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Network/ISecrecyChannelRpcServices.cs",
    "Buffer": "using System.Threading;\nusing System.Threading.Tasks;\nusing Ecliptix.Core.Core.Messaging.Services;\nusing Ecliptix.Protobuf.Common;\nusing Ecliptix.Protobuf.Device;\nusing Ecliptix.Protobuf.Protocol;\nusing Ecliptix.Utilities;\nusing Ecliptix.Utilities.Failures.Network;\n\nnamespace Ecliptix.Core.Services.Abstractions.Network;\n\npublic interface ISecrecyChannelRpcServices\n{\n    Task<Result<SecureEnvelope, NetworkFailure>> EstablishAppDeviceSecrecyChannelAsync(\n        IConnectivityService connectivityService,\n        SecureEnvelope request,\n        PubKeyExchangeType? exchangeType = null,\n        CancellationToken cancellationToken = default);\n\n    Task<Result<RestoreChannelResponse, NetworkFailure>> RestoreAppDeviceSecrecyChannelAsync(\n        IConnectivityService connectivityService,\n        RestoreChannelRequest request,\n        CancellationToken cancellationToken = default);\n\n    Task<Result<SecureEnvelope, NetworkFailure>> AuthenticatedEstablishSecureChannelAsync(\n        IConnectivityService connectivityService,\n        AuthenticatedEstablishRequest request,\n        CancellationToken cancellationToken = default);\n}\n"
  }
}
 [2025-11-04T12:57:53.837] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Network/ISecrecyChannelRpcServices.cs with new text:
using System.Threading;
using System.Threading.Tasks;
using Ecliptix.Core.Core.Messaging.Services;
using Ecliptix.Protobuf.Common;
using Ecliptix.Protobuf.Device;
using Ecliptix.Protobuf.Protocol;
using Ecliptix.Utilities;
using Ecliptix.Utilities.Failures.Network;

namespace Ecliptix.Core.Services.Abstractions.Network;

public interface ISecrecyChannelRpcServices
{
    Task<Result<SecureEnvelope, NetworkFailure>> EstablishAppDeviceSecrecyChannelAsync(
        IConnectivityService connectivityService,
        SecureEnvelope request,
        PubKeyExchangeType? exchangeType = null,
        CancellationToken cancellationToken = default);

    Task<Result<RestoreChannelResponse, NetworkFailure>> RestoreAppDeviceSecrecyChannelAsync(
        IConnectivityService connectivityService,
        RestoreChannelRequest request,
        CancellationToken cancellationToken = default);

    Task<Result<SecureEnvelope, NetworkFailure>> AuthenticatedEstablishSecureChannelAsync(
        IConnectivityService connectivityService,
        AuthenticatedEstablishRequest request,
        CancellationToken cancellationToken = default);
}

 [2025-11-04T12:57:53.837] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3843ms) ************
{
  "Request_seq": 9381,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550081,
  "Type": "response"
}
 [2025-11-04T12:57:53.837] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9382,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Network/ISecrecyChannelRpcServices.cs"
  }
}
 [2025-11-04T12:57:53.94] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (102.4657ms) ************
{
  "Request_seq": 9382,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550085,
  "Type": "response"
}
 [2025-11-04T12:57:53.941] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9383,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecureMemoryUtils.cs",
    "Buffer": "using System.Runtime.CompilerServices;\nusing System.Security.Cryptography;\nusing Ecliptix.Utilities;\nusing Ecliptix.Utilities.Failures.Sodium;\n\nnamespace Ecliptix.Protocol.System.Utilities;\n\ninternal static class SecureMemoryUtils\n{\n    private static readonly SecureMemoryPool DefaultPool = new(ProtocolSystemConstants.MemoryPool.DefaultBufferSize, ProtocolSystemConstants.MemoryPool.MaxPoolSize);\n\n    public static Result<TResult, TError> WithSecureBuffer<TResult, TError>(\n        int size,\n        Func<Span<byte>, Result<TResult, TError>> operation)\n        where TError : class\n    {\n        using SecureMemoryBuffer buffer = DefaultPool.Rent(size);\n\n        byte[] fullBuffer = new byte[buffer.AllocatedSize];\n        Result<Unit, SodiumFailure> readResult = buffer.Read(fullBuffer);\n        if (readResult.IsErr)\n        {\n            throw new InvalidOperationException(ProtocolSystemConstants.ErrorMessages.FailedToReadSecureMemory + readResult.UnwrapErr());\n        }\n\n        Span<byte> span = fullBuffer.AsSpan(0, size);\n\n        try\n        {\n            return operation(span);\n        }\n        finally\n        {\n            CryptographicOperations.ZeroMemory(fullBuffer);\n        }\n    }\n\n    public static Result<TResult, TError> WithSecureBuffers<TResult, TError>(\n        int[] sizes,\n        Func<SecureMemoryBuffer[], Result<TResult, TError>> operation)\n        where TError : class\n    {\n        SecureMemoryBuffer[] buffers = new SecureMemoryBuffer[sizes.Length];\n\n        try\n        {\n            for (int i = 0; i < sizes.Length; i++)\n            {\n                buffers[i] = DefaultPool.Rent(sizes[i]);\n            }\n\n            return operation(buffers);\n        }\n        finally\n        {\n            foreach (SecureMemoryBuffer buffer in buffers)\n            {\n                buffer?.Dispose();\n            }\n        }\n    }\n\n    [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]\n    public static bool ConstantTimeEquals(ReadOnlySpan<byte> a, ReadOnlySpan<byte> b)\n    {\n        if (a.Length != b.Length)\n        {\n            return false;\n        }\n\n        return CryptographicOperations.FixedTimeEquals(a, b);\n    }\n}\n"
  }
}
 [2025-11-04T12:57:53.941] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecureMemoryUtils.cs with new text:
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using Ecliptix.Utilities;
using Ecliptix.Utilities.Failures.Sodium;

namespace Ecliptix.Protocol.System.Utilities;

internal static class SecureMemoryUtils
{
    private static readonly SecureMemoryPool DefaultPool = new(ProtocolSystemConstants.MemoryPool.DefaultBufferSize, ProtocolSystemConstants.MemoryPool.MaxPoolSize);

    public static Result<TResult, TError> WithSecureBuffer<TResult, TError>(
        int size,
        Func<Span<byte>, Result<TResult, TError>> operation)
        where TError : class
    {
        using SecureMemoryBuffer buffer = DefaultPool.Rent(size);

        byte[] fullBuffer = new byte[buffer.AllocatedSize];
        Result<Unit, SodiumFailure> readResult = buffer.Read(fullBuffer);
        if (readResult.IsErr)
        {
            throw new InvalidOperationException(ProtocolSystemConstants.ErrorMessages.FailedToReadSecureMemory + readResult.UnwrapErr());
        }

        Span<byte> span = fullBuffer.AsSpan(0, size);

        try
        {
            return operation(span);
        }
        finally
        {
            CryptographicOperations.ZeroMemory(fullBuffer);
        }
    }

    public static Result<TResult, TError> WithSecureBuffers<TResult, TError>(
        int[] sizes,
        Func<SecureMemoryBuffer[], Result<TResult, TError>> operation)
        where TError : class
    {
        SecureMemoryBuffer[] buffers = new SecureMemoryBuffer[sizes.Length];

        try
        {
            for (int i = 0; i < sizes.Length; i++)
            {
                buffers[i] = DefaultPool.Rent(sizes[i]);
            }

            return operation(buffers);
        }
        finally
        {
            foreach (SecureMemoryBuffer buffer in buffers)
            {
                buffer?.Dispose();
            }
        }
    }

    [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
    public static bool ConstantTimeEquals(ReadOnlySpan<byte> a, ReadOnlySpan<byte> b)
    {
        if (a.Length != b.Length)
        {
            return false;
        }

        return CryptographicOperations.FixedTimeEquals(a, b);
    }
}

 [2025-11-04T12:57:53.941] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2119ms) ************
{
  "Request_seq": 9383,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550089,
  "Type": "response"
}
 [2025-11-04T12:57:53.941] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9384,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecureMemoryUtils.cs"
  }
}
 [2025-11-04T12:57:54.014] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (72.7031ms) ************
{
  "Request_seq": 9384,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550093,
  "Type": "response"
}
 [2025-11-04T12:57:54.015] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9385,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Core/ApplicationStateManager.cs",
    "Buffer": "using System;\nusing System.Reactive.Subjects;\nusing System.Threading.Tasks;\nusing Ecliptix.Core.Services.Abstractions.Core;\nusing Ecliptix.Utilities;\nusing Serilog;\n\nnamespace Ecliptix.Core.Services.Core;\n\npublic sealed class ApplicationStateManager : IApplicationStateManager, IDisposable\n{\n    private readonly BehaviorSubject<ApplicationState> _stateSubject = new(ApplicationState.Initializing);\n    private Option<string> _currentMembershipId = Option<string>.None;\n    private bool _disposed;\n\n    public ApplicationState CurrentState => _stateSubject.Value;\n\n    public IObservable<ApplicationState> StateChanges => _stateSubject;\n\n    public Option<string> CurrentMembershipId => _currentMembershipId;\n\n    public Task TransitionToAnonymousAsync()\n    {\n        _currentMembershipId = Option<string>.None;\n        _stateSubject.OnNext(ApplicationState.Anonymous);\n        return Task.CompletedTask;\n    }\n\n    public Task TransitionToAuthenticatedAsync(string membershipId)\n    {\n        if (string.IsNullOrEmpty(membershipId))\n        {\n            throw new ArgumentException(\"Membership ID cannot be null or empty\", nameof(membershipId));\n        }\n\n        _currentMembershipId = Option<string>.Some(membershipId);\n        _stateSubject.OnNext(ApplicationState.Authenticated);\n        return Task.CompletedTask;\n    }\n\n    public void Dispose()\n    {\n        if (_disposed)\n        {\n            return;\n        }\n\n        _stateSubject?.Dispose();\n        _disposed = true;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:54.016] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Core/ApplicationStateManager.cs with new text:
using System;
using System.Reactive.Subjects;
using System.Threading.Tasks;
using Ecliptix.Core.Services.Abstractions.Core;
using Ecliptix.Utilities;
using Serilog;

namespace Ecliptix.Core.Services.Core;

public sealed class ApplicationStateManager : IApplicationStateManager, IDisposable
{
    private readonly BehaviorSubject<ApplicationState> _stateSubject = new(ApplicationState.Initializing);
    private Option<string> _currentMembershipId = Option<string>.None;
    private bool _disposed;

    public ApplicationState CurrentState => _stateSubject.Value;

    public IObservable<ApplicationState> StateChanges => _stateSubject;

    public Option<string> CurrentMembershipId => _currentMembershipId;

    public Task TransitionToAnonymousAsync()
    {
        _currentMembershipId = Option<string>.None;
        _stateSubject.OnNext(ApplicationState.Anonymous);
        return Task.CompletedTask;
    }

    public Task TransitionToAuthenticatedAsync(string membershipId)
    {
        if (string.IsNullOrEmpty(membershipId))
        {
            throw new ArgumentException("Membership ID cannot be null or empty", nameof(membershipId));
        }

        _currentMembershipId = Option<string>.Some(membershipId);
        _stateSubject.OnNext(ApplicationState.Authenticated);
        return Task.CompletedTask;
    }

    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        _stateSubject?.Dispose();
        _disposed = true;
    }
}

 [2025-11-04T12:57:54.016] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.4080ms) ************
{
  "Request_seq": 9385,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550097,
  "Type": "response"
}
 [2025-11-04T12:57:54.016] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9386,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Core/ApplicationStateManager.cs"
  }
}
 [2025-11-04T12:57:54.126] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (109.8347ms) ************
{
  "Request_seq": 9386,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550101,
  "Type": "response"
}
 [2025-11-04T12:57:54.126] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9387,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/authentication/AuthServices.cs",
    "Buffer": "// <auto-generated>\n//     Generated by the protocol buffer compiler.  DO NOT EDIT!\n//     source: authentication/auth_services.proto\n// </auto-generated>\n#pragma warning disable 1591, 0612, 3021, 8981\n#region Designer generated code\n\nusing pb = global::Google.Protobuf;\nusing pbc = global::Google.Protobuf.Collections;\nusing pbr = global::Google.Protobuf.Reflection;\nusing scg = global::System.Collections.Generic;\nnamespace Ecliptix.Protobuf.Membership {\n\n  /// <summary>Holder for reflection information generated from authentication/auth_services.proto</summary>\n  public static partial class AuthServicesReflection {\n\n    #region Descriptor\n    /// <summary>File descriptor for authentication/auth_services.proto</summary>\n    public static pbr::FileDescriptor Descriptor {\n      get { return descriptor; }\n    }\n    private static pbr::FileDescriptor descriptor;\n\n    static AuthServicesReflection() {\n      byte[] descriptorData = global::System.Convert.FromBase64String(\n          string.Concat(\n            \"CiJhdXRoZW50aWNhdGlvbi9hdXRoX3NlcnZpY2VzLnByb3RvEhllY2xpcHRp\",\n            \"eC5wcm90by5tZW1iZXJzaGlwGhxjb21tb24vc2VjdXJlX2VudmVsb3BlLnBy\",\n            \"b3RvMqcEChhBdXRoVmVyaWZpY2F0aW9uU2VydmljZXMSZgoUSW5pdGlhdGVW\",\n            \"ZXJpZmljYXRpb24SJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJlRW52\",\n            \"ZWxvcGUaJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJlRW52ZWxvcGUw\",\n            \"ARJZCglWZXJpZnlPdHASJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJl\",\n            \"RW52ZWxvcGUaJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJlRW52ZWxv\",\n            \"cGUSZAoUVmFsaWRhdGVNb2JpbGVOdW1iZXISJS5lY2xpcHRpeC5wcm90by5j\",\n            \"b21tb24uU2VjdXJlRW52ZWxvcGUaJS5lY2xpcHRpeC5wcm90by5jb21tb24u\",\n            \"U2VjdXJlRW52ZWxvcGUScwojUmVjb3ZlcnlTZWNyZXRLZXlNb2JpbGVWZXJp\",\n            \"ZmljYXRpb24SJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJlRW52ZWxv\",\n            \"cGUaJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJlRW52ZWxvcGUSbQod\",\n            \"Q2hlY2tNb2JpbGVOdW1iZXJBdmFpbGFiaWxpdHkSJS5lY2xpcHRpeC5wcm90\",\n            \"by5jb21tb24uU2VjdXJlRW52ZWxvcGUaJS5lY2xpcHRpeC5wcm90by5jb21t\",\n            \"b24uU2VjdXJlRW52ZWxvcGVCH6oCHEVjbGlwdGl4LlByb3RvYnVmLk1lbWJl\",\n            \"cnNoaXBiBnByb3RvMw==\"));\n      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,\n          new pbr::FileDescriptor[] { global::Ecliptix.Protobuf.Common.SecureEnvelopeReflection.Descriptor, },\n          new pbr::GeneratedClrTypeInfo(null, null, null));\n    }\n    #endregion\n\n  }\n}\n\n#endregion Designer generated code\n"
  }
}
 [2025-11-04T12:57:54.126] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/authentication/AuthServices.cs with new text:
// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: authentication/auth_services.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Ecliptix.Protobuf.Membership {

  /// <summary>Holder for reflection information generated from authentication/auth_services.proto</summary>
  public static partial class AuthServicesReflection {

    #region Descriptor
    /// <summary>File descriptor for authentication/auth_services.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static AuthServicesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiJhdXRoZW50aWNhdGlvbi9hdXRoX3NlcnZpY2VzLnByb3RvEhllY2xpcHRp",
            "eC5wcm90by5tZW1iZXJzaGlwGhxjb21tb24vc2VjdXJlX2VudmVsb3BlLnBy",
            "b3RvMqcEChhBdXRoVmVyaWZpY2F0aW9uU2VydmljZXMSZgoUSW5pdGlhdGVW",
            "ZXJpZmljYXRpb24SJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJlRW52",
            "ZWxvcGUaJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJlRW52ZWxvcGUw",
            "ARJZCglWZXJpZnlPdHASJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJl",
            "RW52ZWxvcGUaJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJlRW52ZWxv",
            "cGUSZAoUVmFsaWRhdGVNb2JpbGVOdW1iZXISJS5lY2xpcHRpeC5wcm90by5j",
            "b21tb24uU2VjdXJlRW52ZWxvcGUaJS5lY2xpcHRpeC5wcm90by5jb21tb24u",
            "U2VjdXJlRW52ZWxvcGUScwojUmVjb3ZlcnlTZWNyZXRLZXlNb2JpbGVWZXJp",
            "ZmljYXRpb24SJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJlRW52ZWxv",
            "cGUaJS5lY2xpcHRpeC5wcm90by5jb21tb24uU2VjdXJlRW52ZWxvcGUSbQod",
            "Q2hlY2tNb2JpbGVOdW1iZXJBdmFpbGFiaWxpdHkSJS5lY2xpcHRpeC5wcm90",
            "by5jb21tb24uU2VjdXJlRW52ZWxvcGUaJS5lY2xpcHRpeC5wcm90by5jb21t",
            "b24uU2VjdXJlRW52ZWxvcGVCH6oCHEVjbGlwdGl4LlByb3RvYnVmLk1lbWJl",
            "cnNoaXBiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Ecliptix.Protobuf.Common.SecureEnvelopeReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, null));
    }
    #endregion

  }
}

#endregion Designer generated code

 [2025-11-04T12:57:54.127] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2591ms) ************
{
  "Request_seq": 9387,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550105,
  "Type": "response"
}
 [2025-11-04T12:57:54.127] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9388,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/authentication/AuthServices.cs"
  }
}
 [2025-11-04T12:57:54.179] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (52.3982ms) ************
{
  "Request_seq": 9388,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550109,
  "Type": "response"
}
 [2025-11-04T12:57:54.18] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9389,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/ScopedSecureMemory.cs",
    "Buffer": "using System.Security.Cryptography;\n\nnamespace Ecliptix.Protocol.System.Utilities;\n\ninternal sealed class ScopedSecureMemory : IDisposable\n{\n    private byte[]? _data;\n    private readonly bool _clearOnDispose;\n    private bool _disposed;\n\n    private ScopedSecureMemory(byte[] data, bool clearOnDispose = true)\n    {\n        _data = data;\n        _clearOnDispose = clearOnDispose;\n    }\n\n    public static ScopedSecureMemory Allocate(int size)\n    {\n        return size <= 0 ? throw new ArgumentException(ProtocolSystemConstants.ErrorMessages.SizePositive, nameof(size)) : new ScopedSecureMemory(new byte[size]);\n    }\n\n    public static ScopedSecureMemory Wrap(byte[] data, bool clearOnDispose = true)\n    {\n        return new ScopedSecureMemory(data, clearOnDispose);\n    }\n\n    public Span<byte> AsSpan()\n    {\n        ObjectDisposedException.ThrowIf(_disposed, this);\n        return _data!.AsSpan();\n    }\n\n    public void Dispose()\n    {\n        if (_disposed)\n        {\n            return;\n        }\n\n        if (_data != null && _clearOnDispose)\n        {\n            CryptographicOperations.ZeroMemory(_data);\n        }\n\n        _data = null;\n        _disposed = true;\n    }\n}\n"
  }
}
 [2025-11-04T12:57:54.18] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/ScopedSecureMemory.cs with new text:
using System.Security.Cryptography;

namespace Ecliptix.Protocol.System.Utilities;

internal sealed class ScopedSecureMemory : IDisposable
{
    private byte[]? _data;
    private readonly bool _clearOnDispose;
    private bool _disposed;

    private ScopedSecureMemory(byte[] data, bool clearOnDispose = true)
    {
        _data = data;
        _clearOnDispose = clearOnDispose;
    }

    public static ScopedSecureMemory Allocate(int size)
    {
        return size <= 0 ? throw new ArgumentException(ProtocolSystemConstants.ErrorMessages.SizePositive, nameof(size)) : new ScopedSecureMemory(new byte[size]);
    }

    public static ScopedSecureMemory Wrap(byte[] data, bool clearOnDispose = true)
    {
        return new ScopedSecureMemory(data, clearOnDispose);
    }

    public Span<byte> AsSpan()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        return _data!.AsSpan();
    }

    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        if (_data != null && _clearOnDispose)
        {
            CryptographicOperations.ZeroMemory(_data);
        }

        _data = null;
        _disposed = true;
    }
}

 [2025-11-04T12:57:54.181] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2294ms) ************
{
  "Request_seq": 9389,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550112,
  "Type": "response"
}
 [2025-11-04T12:57:54.181] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9390,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/ScopedSecureMemory.cs"
  }
}
 [2025-11-04T12:57:54.282] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (101.4471ms) ************
{
  "Request_seq": 9390,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550116,
  "Type": "response"
}
 [2025-11-04T12:57:54.282] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9391,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Constants/ApplicationErrorMessages.cs",
    "Buffer": "namespace Ecliptix.Core.Constants;\n\npublic static class ApplicationErrorMessages\n{\n    public static class ApplicationRouter\n    {\n        public const string CannotNavigateWindowNull = \"Cannot navigate: current window is null\";\n        public const string FailedToLoadAuthModule = \"Failed to load Authentication module\";\n        public const string FailedToCreateMembershipViewModel = \"Failed to create AuthenticationViewModel\";\n        public const string FailedToLoadMainModule = \"Failed to load Main module\";\n        public const string FailedToCreateMainViewModel = \"Failed to create MainViewModel\";\n        public const string FailedToLoadMainModuleFromSplash = \"Failed to load Main module from splash\";\n        public const string FailedToLoadAuthModuleFromSplash = \"Failed to load Authentication module from splash\";\n    }\n\n    public static class SecureStorageProvider\n    {\n        public const string SecureStorageDirectoryCreationFailed = \"Could not create secure storage directory: {0}\";\n        public const string ApplicationSettingsNotFound = \"Application instance settings not found.\";\n        public const string CorruptSettingsData = \"Corrupt settings data in secure storage.\";\n        public const string FailedToEncryptData = \"Failed to encrypt data for storage.\";\n        public const string FailedToWriteToStorage = \"Failed to write to secure storage.\";\n        public const string FailedToDecryptData = \"Failed to decrypt data.\";\n        public const string FailedToAccessStorage = \"Failed to access secure storage.\";\n        public const string FailedToDeleteFromStorage = \"Failed to delete from secure storage.\";\n    }\n\n    public static class SecureProtocolStateStorage\n    {\n        public const string StorageDisposed = \"Storage is disposed\";\n        public const string StateFileNotFound = \"State file not found\";\n        public const string TamperedStateDetected = \"Security violation: tampered state detected\";\n        public const string AssociatedDataMismatch = \"Associated data mismatch\";\n        public const string InvalidContainerFormat = \"Invalid container format\";\n        public const string UnsupportedVersion = \"Unsupported version: {0}\";\n        public const string SaveFailed = \"Save failed: {0}\";\n        public const string LoadFailed = \"Load failed: {0}\";\n        public const string DeleteFailed = \"Delete failed: {0}\";\n    }\n}\n"
  }
}
 [2025-11-04T12:57:54.282] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Constants/ApplicationErrorMessages.cs with new text:
namespace Ecliptix.Core.Constants;

public static class ApplicationErrorMessages
{
    public static class ApplicationRouter
    {
        public const string CannotNavigateWindowNull = "Cannot navigate: current window is null";
        public const string FailedToLoadAuthModule = "Failed to load Authentication module";
        public const string FailedToCreateMembershipViewModel = "Failed to create AuthenticationViewModel";
        public const string FailedToLoadMainModule = "Failed to load Main module";
        public const string FailedToCreateMainViewModel = "Failed to create MainViewModel";
        public const string FailedToLoadMainModuleFromSplash = "Failed to load Main module from splash";
        public const string FailedToLoadAuthModuleFromSplash = "Failed to load Authentication module from splash";
    }

    public static class SecureStorageProvider
    {
        public const string SecureStorageDirectoryCreationFailed = "Could not create secure storage directory: {0}";
        public const string ApplicationSettingsNotFound = "Application instance settings not found.";
        public const string CorruptSettingsData = "Corrupt settings data in secure storage.";
        public const string FailedToEncryptData = "Failed to encrypt data for storage.";
        public const string FailedToWriteToStorage = "Failed to write to secure storage.";
        public const string FailedToDecryptData = "Failed to decrypt data.";
        public const string FailedToAccessStorage = "Failed to access secure storage.";
        public const string FailedToDeleteFromStorage = "Failed to delete from secure storage.";
    }

    public static class SecureProtocolStateStorage
    {
        public const string StorageDisposed = "Storage is disposed";
        public const string StateFileNotFound = "State file not found";
        public const string TamperedStateDetected = "Security violation: tampered state detected";
        public const string AssociatedDataMismatch = "Associated data mismatch";
        public const string InvalidContainerFormat = "Invalid container format";
        public const string UnsupportedVersion = "Unsupported version: {0}";
        public const string SaveFailed = "Save failed: {0}";
        public const string LoadFailed = "Load failed: {0}";
        public const string DeleteFailed = "Delete failed: {0}";
    }
}

 [2025-11-04T12:57:54.283] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3652ms) ************
{
  "Request_seq": 9391,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550120,
  "Type": "response"
}
 [2025-11-04T12:57:54.283] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9392,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Constants/ApplicationErrorMessages.cs"
  }
}
 [2025-11-04T12:57:54.498] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (215.5394ms) ************
{
  "Request_seq": 9392,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550124,
  "Type": "response"
}
 [2025-11-04T12:57:54.499] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9393,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/Constants/ApplicationConstants.cs",
    "Buffer": "using System;\nusing System.IO;\n\nnamespace Ecliptix.Core.Desktop.Constants;\n\npublic static class ApplicationConstants\n{\n    public static class ApplicationSettings\n    {\n        public const string ApplicationName = \"Ecliptix\";\n        public const string EnvironmentKey = \"AppSettings:Environment\";\n        public const string DevelopmentEnvironment = \"Development\";\n        public const string ProductionEnvironment = \"Production\";\n        public const string DotNetEnvironmentKey = \"DOTNET_ENVIRONMENT\";\n        public const string MutexNameFormat = \"EcliptixDesktop_{0}\";\n    }\n\n    public static class Configuration\n    {\n        public const string AppSettingsFile = \"appsettings.json\";\n        public const string EnvironmentAppSettingsPattern = \"appsettings.{0}.json\";\n        public const string DefaultAppSettingsSection = \"DefaultAppSettings\";\n        public const string SecureStoreOptionsSection = \"SecureStoreOptions\";\n        public const string SecureStorageSection = \"SecureStorage\";\n        public const string SecrecyChannelRetryPolicySection = \"SecrecyChannelRetryPolicy\";\n        public const string SerilogSection = \"Serilog\";\n        public const string MinimumLevelDefaultKey = \"MinimumLevel:Default\";\n        public const string PathSeparator = \":\";\n    }\n\n    public static class Storage\n    {\n        public const string DataProtectionKeysPath = \"%APPDATA%/Storage/DataProtection-Keys\";\n        public const string DefaultStatePath = \"Storage/state\";\n        public const string EcliptixDirectoryName = \"Ecliptix\";\n        public const string LocalShareDirectory = \".local/share\";\n        public const string ApplicationSupportDirectory = \"Library/Application Support\";\n        public const string LogsDirectory = \"logs\";\n        public const string LogFilePattern = \"ecliptix-.log\";\n        public const string AppDataEnvironmentVariable = \"%APPDATA%\";\n    }\n\n    public static class Timeouts\n    {\n        public static readonly TimeSpan DefaultKeyLifetime = TimeSpan.FromDays(90);\n        public static readonly TimeSpan HttpClientLifetime = TimeSpan.FromMinutes(5);\n        public static readonly TimeSpan HttpTimeout = TimeSpan.FromSeconds(5);\n        public static readonly TimeSpan DefaultPollingInterval = TimeSpan.FromSeconds(10);\n        public static readonly TimeSpan DefaultInitialRetryDelay = TimeSpan.FromSeconds(5);\n        public static readonly TimeSpan DefaultMaxRetryDelay = TimeSpan.FromMinutes(2);\n    }\n\n    public static class Thresholds\n    {\n        public const int DefaultFailureThreshold = 2;\n        public const int DefaultSuccessThreshold = 1;\n        public const int DefaultMaxRetries = 10;\n        public const int RetryAttempts = 3;\n        public const int ExponentialBackoffBase = 2;\n    }\n\n    public static class ConfigurationKeys\n    {\n        public const string DefaultTheme = \"DefaultTheme\";\n        public const string Environment = \"Environment\";\n        public const string DataCenterConnectionString = \"DataCenterConnectionString\";\n        public const string CountryCodeApi = \"CountryCodeApi\";\n        public const string DomainName = \"DomainName\";\n        public const string Culture = \"Culture\";\n        public const string EncryptedStatePath = \"EncryptedStatePath\";\n        public const string StatePath = \"StatePath\";\n        public const string InitialRetryDelay = \"InitialRetryDelay\";\n        public const string MaxRetryDelay = \"MaxRetryDelay\";\n        public const string MaxRetries = \"MaxRetries\";\n        public const string PerAttemptTimeout = \"PerAttemptTimeout\";\n        public const string UseAdaptiveRetry = \"UseAdaptiveRetry\";\n    }\n\n    public static class Logging\n    {\n        public const string StartupMessage = \"Starting Ecliptix application...\";\n        public const string ShutdownMessage = \"Application shutting down\";\n        public const string FatalErrorMessage = \"Application terminated unexpectedly during startup or runtime\";\n        public const string PermissionsSetMessage = \"Set secure permissions (700) on directory {Path}\";\n        public const string PermissionsFailMessage = \"Failed to set permissions for directory {Path}\";\n        public const string GrpcEndpointErrorMessage = \"gRPC endpoint URL is not configured in appsettings.json.\";\n        public const string PathEmptyErrorMessage = \"Path cannot be empty.\";\n    }\n\n    public static class FilePermissions\n    {\n        public const UnixFileMode SecureDirectoryMode =\n            UnixFileMode.UserRead | UnixFileMode.UserWrite | UnixFileMode.UserExecute;\n    }\n\n    public static class ExitCodes\n    {\n        public const int FatalError = 1;\n    }\n\n    public static class LogLevels\n    {\n        public const string Debug = \"Debug\";\n        public const string Information = \"Information\";\n        public const string Warning = \"Warning\";\n        public const string Error = \"Error\";\n        public const string Fatal = \"Fatal\";\n    }\n}\n"
  }
}
 [2025-11-04T12:57:54.499] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/Constants/ApplicationConstants.cs with new text:
using System;
using System.IO;

namespace Ecliptix.Core.Desktop.Constants;

public static class ApplicationConstants
{
    public static class ApplicationSettings
    {
        public const string ApplicationName = "Ecliptix";
        public const string EnvironmentKey = "AppSettings:Environment";
        public const string DevelopmentEnvironment = "Development";
        public const string ProductionEnvironment = "Production";
        public const string DotNetEnvironmentKey = "DOTNET_ENVIRONMENT";
        public const string MutexNameFormat = "EcliptixDesktop_{0}";
    }

    public static class Configuration
    {
        public const string AppSettingsFile = "appsettings.json";
        public const string EnvironmentAppSettingsPattern = "appsettings.{0}.json";
        public const string DefaultAppSettingsSection = "DefaultAppSettings";
        public const string SecureStoreOptionsSection = "SecureStoreOptions";
        public const string SecureStorageSection = "SecureStorage";
        public const string SecrecyChannelRetryPolicySection = "SecrecyChannelRetryPolicy";
        public const string SerilogSection = "Serilog";
        public const string MinimumLevelDefaultKey = "MinimumLevel:Default";
        public const string PathSeparator = ":";
    }

    public static class Storage
    {
        public const string DataProtectionKeysPath = "%APPDATA%/Storage/DataProtection-Keys";
        public const string DefaultStatePath = "Storage/state";
        public const string EcliptixDirectoryName = "Ecliptix";
        public const string LocalShareDirectory = ".local/share";
        public const string ApplicationSupportDirectory = "Library/Application Support";
        public const string LogsDirectory = "logs";
        public const string LogFilePattern = "ecliptix-.log";
        public const string AppDataEnvironmentVariable = "%APPDATA%";
    }

    public static class Timeouts
    {
        public static readonly TimeSpan DefaultKeyLifetime = TimeSpan.FromDays(90);
        public static readonly TimeSpan HttpClientLifetime = TimeSpan.FromMinutes(5);
        public static readonly TimeSpan HttpTimeout = TimeSpan.FromSeconds(5);
        public static readonly TimeSpan DefaultPollingInterval = TimeSpan.FromSeconds(10);
        public static readonly TimeSpan DefaultInitialRetryDelay = TimeSpan.FromSeconds(5);
        public static readonly TimeSpan DefaultMaxRetryDelay = TimeSpan.FromMinutes(2);
    }

    public static class Thresholds
    {
        public const int DefaultFailureThreshold = 2;
        public const int DefaultSuccessThreshold = 1;
        public const int DefaultMaxRetries = 10;
        public const int RetryAttempts = 3;
        public const int ExponentialBackoffBase = 2;
    }

    public static class ConfigurationKeys
    {
        public const string DefaultTheme = "DefaultTheme";
        public const string Environment = "Environment";
        public const string DataCenterConnectionString = "DataCenterConnectionString";
        public const string CountryCodeApi = "CountryCodeApi";
        public const string DomainName = "DomainName";
        public const string Culture = "Culture";
        public const string EncryptedStatePath = "EncryptedStatePath";
        public const string StatePath = "StatePath";
        public const string InitialRetryDelay = "InitialRetryDelay";
        public const string MaxRetryDelay = "MaxRetryDelay";
        public const string MaxRetries = "MaxRetries";
        public const string PerAttemptTimeout = "PerAttemptTimeout";
        public const string UseAdaptiveRetry = "UseAdaptiveRetry";
    }

    public static class Logging
    {
        public const string StartupMessage = "Starting Ecliptix application...";
        public const string ShutdownMessage = "Application shutting down";
        public const string FatalErrorMessage = "Application terminated unexpectedly during startup or runtime";
        public const string PermissionsSetMessage = "Set secure permissions (700) on directory {Path}";
        public const string PermissionsFailMessage = "Failed to set permissions for directory {Path}";
        public const string GrpcEndpointErrorMessage = "gRPC endpoint URL is not configured in appsettings.json.";
        public const string PathEmptyErrorMessage = "Path cannot be empty.";
    }

    public static class FilePermissions
    {
        public const UnixFileMode SecureDirectoryMode =
            UnixFileMode.UserRead | UnixFileMode.UserWrite | UnixFileMode.UserExecute;
    }

    public static class ExitCodes
    {
        public const int FatalError = 1;
    }

    public static class LogLevels
    {
        public const string Debug = "Debug";
        public const string Information = "Information";
        public const string Warning = "Warning";
        public const string Error = "Error";
        public const string Fatal = "Fatal";
    }
}

 [2025-11-04T12:57:54.499] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.2585ms) ************
{
  "Request_seq": 9393,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550129,
  "Type": "response"
}
 [2025-11-04T12:57:54.499] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9394,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/Constants/ApplicationConstants.cs"
  }
}
 [2025-11-04T12:57:54.611] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (111.7159ms) ************
{
  "Request_seq": 9394,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550133,
  "Type": "response"
}
 [2025-11-04T12:57:54.612] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9395,
  "Command": "/updatebuffer",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/Views/MasterView.axaml.cs",
    "Buffer": "using Avalonia.Controls;\nusing Avalonia.Markup.Xaml;\nusing Ecliptix.Core.Services;\nusing Ecliptix.Core.Services.Core;\n\nnamespace Ecliptix.Core.Features.Main.Views;\n\npublic partial class MasterView : UserControl\n{\n    public MasterView()\n    {\n        AvaloniaXamlLoader.Load(this);\n    }\n}\n"
  }
}
 [2025-11-04T12:57:54.612] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] Updating file /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/Views/MasterView.axaml.cs with new text:
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using Ecliptix.Core.Services;
using Ecliptix.Core.Services.Core;

namespace Ecliptix.Core.Features.Main.Views;

public partial class MasterView : UserControl
{
    public MasterView()
    {
        AvaloniaXamlLoader.Load(this);
    }
}

 [2025-11-04T12:57:54.618] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (0.3867ms) ************
{
  "Request_seq": 9395,
  "Command": "/updatebuffer",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": true,
  "Seq": 550137,
  "Type": "response"
}
 [2025-11-04T12:57:54.618] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************ Request ************
{
  "Type": "request",
  "Seq": 9396,
  "Command": "/sonarlint/codecheck",
  "Arguments": {
    "FileName": "/Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/Views/MasterView.axaml.cs"
  }
}
 [2025-11-04T12:57:54.709] [omnisharp-stdout-stream-consumer-45256] DEBUG org.sonarsource.sonarlint.omnisharp.protocol.OmnisharpResponseProcessor - Omnisharp: [DEBUG] ************  Response (90.7850ms) ************
{
  "Request_seq": 9396,
  "Command": "/sonarlint/codecheck",
  "Running": true,
  "Success": true,
  "Message": null,
  "Body": {
    "QuickFixes": []
  },
  "Seq": 550142,
  "Type": "response"
}
 [2025-11-04T12:57:54.709] [Report about progress of OmniSharp analyzer] INFO org.sonarsource.analyzer.commons.ProgressReport - 337/337 source files have been analyzed
 [2025-11-04T12:57:54.711] [sonarlint-analysis-scheduler] DEBUG sonarlint - 'JavaScript/TypeScript analysis' skipped because there are no related files in the current project
 [2025-11-04T12:57:54.711] [sonarlint-analysis-scheduler] DEBUG sonarlint - 'JavaScript inside YAML analysis' skipped because there are no related files in the current project
 [2025-11-04T12:57:54.711] [sonarlint-analysis-scheduler] DEBUG sonarlint - 'JavaScript inside HTML analysis' skipped because there are no related files in the current project
 [2025-11-04T12:57:54.711] [sonarlint-analysis-scheduler] DEBUG sonarlint - Execute Sensor: CSS Rules
 [2025-11-04T12:57:54.712] [sonarlint-analysis-scheduler] INFO org.sonar.plugins.javascript.analysis.CssRuleSensor - No CSS, PHP, HTML or VueJS files are found in the project. CSS analysis is skipped.
 [2025-11-04T12:57:54.712] [sonarlint-analysis-scheduler] DEBUG sonarlint - 'IaC YAML Sensor' skipped because there are no related files in the current project
 [2025-11-04T12:57:54.712] [sonarlint-analysis-scheduler] DEBUG sonarlint - Execute Sensor: IaC JSON Sensor
 [2025-11-04T12:57:54.713] [sonarlint-analysis-scheduler] DEBUG com.sonar.iac.A.D.A - Sensor for language "JSON" is disabled
 [2025-11-04T12:57:54.713] [sonarlint-analysis-scheduler] DEBUG sonarlint - Execute Sensor: EnterpriseTextAndSecretsSensor
 [2025-11-04T12:57:54.716] [sonarlint-analysis-scheduler] INFO org.sonar.plugins.common.TextAndSecretsSensor - Available processors: 10
 [2025-11-04T12:57:54.716] [sonarlint-analysis-scheduler] INFO org.sonar.plugins.common.TextAndSecretsSensor - Using 10 threads for analysis.
 [2025-11-04T12:57:54.716] [sonarlint-analysis-scheduler] DEBUG org.sonar.plugins.secrets.configuration.SecretsSpecificationContainer - SecretsStateContainer is already initialized, skipping re-initialization.
 [2025-11-04T12:57:54.749] [sonarlint-analysis-scheduler] DEBUG org.sonar.plugins.secrets.utils.CheckContainer - ChecksContainer is already initialized, skipping re-initialization.
 [2025-11-04T12:57:54.749] [sonarlint-analysis-scheduler] INFO org.sonar.plugins.common.TextAndSecretsSensor - Start fetching files for the text and secrets analysis
 [2025-11-04T12:57:54.749] [sonarlint-analysis-scheduler] INFO org.sonar.plugins.common.TextAndSecretsSensor - Retrieving all except binary files
 [2025-11-04T12:57:54.75] [sonarlint-analysis-scheduler] INFO org.sonar.plugins.common.analyzer.Analyzer - Starting the text and secrets analysis
 [2025-11-04T12:57:54.75] [Progress of the text and secrets analysis] INFO org.sonar.plugins.common.MultiFileProgressReport - 400 source files to be analyzed for the text and secrets analysis
 [2025-11-04T12:57:54.751] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Resilience/RetryPolicyProvider.cs
 [2025-11-04T12:57:54.752] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/LanguageSelector/LanguageSelectorView.axaml.cs
 [2025-11-04T12:57:54.752] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Sodium/SodiumInterop.cs
 [2025-11-04T12:57:54.753] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Services/IBottomSheetService.cs
 [2025-11-04T12:57:54.754] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Security.Certificate.Pinning/Services/CertificatePinningBoolResult.cs
 [2025-11-04T12:57:54.759] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/obj/Debug/net9.0/Ecliptix.Protocol.System.GeneratedMSBuildEditorConfig.editorconfig
 [2025-11-04T12:57:54.76] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Network/NetworkServiceMessages.cs
 [2025-11-04T12:57:54.762] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/LogoutService.cs
 [2025-11-04T12:57:54.763] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Constants/SegmentedTextBoxConstants.cs
 [2025-11-04T12:57:54.763] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/SecureKeyValidator.cs
 [2025-11-04T12:57:54.763] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/DetectLanguageDialog.axaml.cs
 [2025-11-04T12:57:54.763] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Network/IUnaryRpcServices.cs
 [2025-11-04T12:57:54.763] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/DetectLanguageDialogViewModel.cs
 [2025-11-04T12:57:54.763] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Security.Certificate.Pinning/obj/Debug/net9.0/Ecliptix.Security.Certificate.Pinning.AssemblyInfo.cs
 [2025-11-04T12:57:54.764] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/obj/Debug/net9.0/Ecliptix.Core.AssemblyInfo.cs
 [2025-11-04T12:57:54.765] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/RatchetRecovery.cs
 [2025-11-04T12:57:54.765] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Membership/ILogoutService.cs
 [2025-11-04T12:57:54.765] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecurePooledArray.cs
 [2025-11-04T12:57:54.765] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Events/BottomSheetEvents.cs
 [2025-11-04T12:57:54.765] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Core/Connectivity/InternetConnectivityBridge.cs
 [2025-11-04T12:57:54.766] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/SecureEnvelopeGrpc.cs
 [2025-11-04T12:57:54.766] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Directory.Build.props
 [2025-11-04T12:57:54.767] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Registration/SecureKeyConfirmationView.axaml
 [2025-11-04T12:57:54.767] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Styles/Core/Animations.axaml
 [2025-11-04T12:57:54.768] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/IMessageBus.cs
 [2025-11-04T12:57:54.768] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Security/Crypto/RatchetStateHasher.cs
 [2025-11-04T12:57:54.768] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/HealthCheckGrpc.cs
 [2025-11-04T12:57:54.768] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Resilience/GrpcErrorClassifier.cs
 [2025-11-04T12:57:54.769] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/AssemblyInfo.cs
 [2025-11-04T12:57:54.769] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/ProtocolState.cs
 [2025-11-04T12:57:54.771] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Registration/PassPhaseView.axaml.cs
 [2025-11-04T12:57:54.771] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/account/AccountModelsGrpc.cs
 [2025-11-04T12:57:54.771] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Abstractions/Transport/INetworkProvider.cs
 [2025-11-04T12:57:54.771] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Abstractions/Transport/IOutboundSink.cs
 [2025-11-04T12:57:54.771] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/ScopedSecureMemoryCollection.cs
 [2025-11-04T12:57:54.771] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Network/IRetryStrategy.cs
 [2025-11-04T12:57:54.772] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/EventArgs/CharacterRejectedEventArgs.cs
 [2025-11-04T12:57:54.773] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Data/Abstractions/IApplicationSecureStorageProvider.cs
 [2025-11-04T12:57:54.774] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Abstractions/Transport/IRpcMetaDataProvider.cs
 [2025-11-04T12:57:54.774] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Settings/AppCultureSettings.cs
 [2025-11-04T12:57:54.775] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/EcliptixProtocolChainStep.cs
 [2025-11-04T12:57:54.776] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/DetectLanguageDialog.axaml
 [2025-11-04T12:57:54.807] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/RedirectNotificationViewModel.cs
 [2025-11-04T12:57:54.807] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/MVVM/ViewModelBase.cs
 [2025-11-04T12:57:54.808] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Network/NetworkFailure.cs
 [2025-11-04T12:57:54.808] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/RpcMetaData/MetaDataSystemFailure.cs
 [2025-11-04T12:57:54.808] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/obj/Debug/net9.0/osx-arm64/Ecliptix.Core.Desktop.GeneratedMSBuildEditorConfig.editorconfig
 [2025-11-04T12:57:54.809] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Core/ConnectivityNotificationView.axaml.cs
 [2025-11-04T12:57:54.809] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Opaque.Protocol/OpaqueClient.cs
 [2025-11-04T12:57:54.81] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Security.Certificate.Pinning/Services/CertificatePinningByteArrayResult.cs
 [2025-11-04T12:57:54.81] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IModuleScope.cs
 [2025-11-04T12:57:54.81] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Hosts/AuthenticationView.axaml
 [2025-11-04T12:57:54.811] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Authentication/Constants/AuthenticationConstants.cs
 [2025-11-04T12:57:54.812] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Assets/Icons/UI/lamp.svg
 [2025-11-04T12:57:54.812] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Security/Crypto/RsaChunkEncryptor.cs
 [2025-11-04T12:57:54.813] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IViewLocator.cs
 [2025-11-04T12:57:54.813] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Registration/SecureKeyConfirmationView.axaml.cs
 [2025-11-04T12:57:54.814] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/UnaryRpcServices.cs
 [2025-11-04T12:57:54.815] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Assets/Branding/Logos/ecliptix_logo.svg
 [2025-11-04T12:57:54.816] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Controls/ModuleContentControl.cs
 [2025-11-04T12:57:54.816] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Resilience/RetryPolicyHelpers.cs
 [2025-11-04T12:57:54.816] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/ViewModels/Registration/MobileVerificationViewModel.cs
 [2025-11-04T12:57:54.819] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/RpcMetaData/MetaDataSystemFailureType.cs
 [2025-11-04T12:57:54.821] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Security/IServerPublicKeyProvider.cs
 [2025-11-04T12:57:54.823] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Authentication/ISecureKeyRecoveryService.cs
 [2025-11-04T12:57:54.823] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/SecureStorageConstants.cs
 [2025-11-04T12:57:54.824] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/.editorconfig
 [2025-11-04T12:57:54.824] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/GrpcErrorDescriptor.cs
 [2025-11-04T12:57:54.825] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Styles/Main/MainStyles.axaml
 [2025-11-04T12:57:54.825] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Serialization/EcliptixJsonSerializerContext.cs
 [2025-11-04T12:57:54.825] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/MembershipServicesGrpc.cs
 [2025-11-04T12:57:54.826] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecureArrayPool.cs
 [2025-11-04T12:57:54.826] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/ApplicationStartup.cs
 [2025-11-04T12:57:54.826] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Core/Constants/GrpcErrorMetadataKeys.cs
 [2025-11-04T12:57:54.827] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Security/ServerPublicKeyProvider.cs
 [2025-11-04T12:57:54.827] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/RpcServiceType.cs
 [2025-11-04T12:57:54.827] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/device/DeviceServicesGrpc.cs
 [2025-11-04T12:57:54.828] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/rd.xml
 [2025-11-04T12:57:54.828] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Core/ApplicationRouter.cs
 [2025-11-04T12:57:54.828] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IModuleMessageBus.cs
 [2025-11-04T12:57:54.828] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Data/PendingLogoutRequestStorage.cs
 [2025-11-04T12:57:54.829] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IModuleManager.cs
 [2025-11-04T12:57:54.829] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/ViewModels/Registration/PassPhaseViewModel.cs
 [2025-11-04T12:57:54.829] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/BottomSheetModal/BottomSheetControl.axaml
 [2025-11-04T12:57:54.83] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/app.manifest
 [2025-11-04T12:57:54.83] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/Views/MasterView.axaml
 [2025-11-04T12:57:54.83] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Utilities/DisposableAction.cs
 [2025-11-04T12:57:54.83] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Core/HintedTextBox.axaml
 [2025-11-04T12:57:54.831] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/ViewModels/Registration/VerifyOtpViewModel.cs
 [2025-11-04T12:57:54.832] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Membership/LogoutFailure.cs
 [2025-11-04T12:57:54.832] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IModuleMessage.cs
 [2025-11-04T12:57:54.832] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Styles/Core/Typography.axaml
 [2025-11-04T12:57:54.833] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Sodium/SodiumSecureMemoryHandle.cs
 [2025-11-04T12:57:54.833] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/obj/Debug/net9.0/osx-arm64/Ecliptix.Core.Desktop.AssemblyInfo.cs
 [2025-11-04T12:57:54.833] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecureByteStringInterop.cs
 [2025-11-04T12:57:54.833] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/ViewModels/Registration/SecureKeyVerifierViewModel.cs
 [2025-11-04T12:57:54.834] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Assets/Icons/Flags/ukraine_flag.svg
 [2025-11-04T12:57:54.835] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Core/ILocalizationService.cs
 [2025-11-04T12:57:54.835] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Views/Memberships/Components/TitleBar.axaml
 [2025-11-04T12:57:54.836] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Resilience/FailureClassification.cs
 [2025-11-04T12:57:54.836] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/ViewModels/MasterViewModel.cs
 [2025-11-04T12:57:54.836] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/Views/Components/WelcomeView.axaml
 [2025-11-04T12:57:54.836] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Network/IReceiveStreamRpcServices.cs
 [2025-11-04T12:57:54.837] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Core/SegmentedTextBox.axaml.cs
 [2025-11-04T12:57:54.837] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Shared/Converters/MathConverters.cs
 [2025-11-04T12:57:54.837] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/CertificatePinning/CertificatePinningFailure.cs
 [2025-11-04T12:57:54.837] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Registration/MobileVerificationView.axaml
 [2025-11-04T12:57:54.838] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Ecliptix.Protocol.System.csproj
 [2025-11-04T12:57:54.838] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Core/Localization/LocalizationService.cs
 [2025-11-04T12:57:54.839] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Authentication/IOpaqueRegistrationService.cs
 [2025-11-04T12:57:54.84] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/device/ApplicationSettings.cs
 [2025-11-04T12:57:54.84] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/RetryBehavior.cs
 [2025-11-04T12:57:54.841] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/OneTimePreKeyRecord.cs
 [2025-11-04T12:57:54.841] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Connectivity/ConnectivitySource.cs
 [2025-11-04T12:57:54.841] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Services/ILanguageDetectionService.cs
 [2025-11-04T12:57:54.841] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Authentication/SensitiveBytes.cs
 [2025-11-04T12:57:54.841] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/account/AccountModels.cs
 [2025-11-04T12:57:54.842] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Opaque.Protocol/NativeLibraries/macos/libopaque_client.dylib.backup
 [2025-11-04T12:57:54.843] [pool-1923-thread-7] WARN sonarlint - Invalid character encountered in file 'file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Opaque.Protocol/NativeLibraries/macos/libopaque_client.dylib.backup' at line 1 for encoding UTF-8. Please fix file content or configure the encoding.
 [2025-11-04T12:57:54.848] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/ModuleIdentifier.cs
 [2025-11-04T12:57:54.848] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/RedirectNotificationView.axaml.cs
 [2025-11-04T12:57:54.848] [pool-1923-thread-7] WARN org.sonar.plugins.common.analyzer.TextAndSecretsAnalyzer - The file '[uri=file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Opaque.Protocol/NativeLibraries/macos/libopaque_client.dylib.backup]' contains binary data and will not be included in the text and secrets analysis.
 [2025-11-04T12:57:54.848] [pool-1923-thread-7] WARN org.sonar.plugins.common.analyzer.TextAndSecretsAnalyzer - Please check this file and/or remove the extension from the 'sonar.text.inclusions' property.
 [2025-11-04T12:57:54.848] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Infrastructure/PendingRequestManager.cs
 [2025-11-04T12:57:54.848] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Constants.cs
 [2025-11-04T12:57:54.849] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/IOperationTimeoutProvider.cs
 [2025-11-04T12:57:54.849] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Settings/DefaultSystemSettings.cs
 [2025-11-04T12:57:54.849] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/RpcFlow.cs
 [2025-11-04T12:57:54.849] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Network/UserFacingError.cs
 [2025-11-04T12:57:54.849] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/Ecliptix.Protobufs.GeneratedMSBuildEditorConfig.editorconfig
 [2025-11-04T12:57:54.849] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Security.Certificate.Pinning/obj/Debug/net9.0/Ecliptix.Security.Certificate.Pinning.GlobalUsings.g.cs
 [2025-11-04T12:57:54.849] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Security.Certificate.Pinning/Native/CertificatePinningNativeResult.cs
 [2025-11-04T12:57:54.85] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/Ecliptix.Protobufs.csproj
 [2025-11-04T12:57:54.85] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Authentication/SecureKeyRecoveryService.cs
 [2025-11-04T12:57:54.85] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/Ecliptix.Core.Desktop.csproj
 [2025-11-04T12:57:54.851] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Helpers.cs
 [2025-11-04T12:57:54.851] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Security.Certificate.Pinning/Services/CertificatePinningServiceFactory.cs
 [2025-11-04T12:57:54.851] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Opaque.Protocol/obj/Debug/net9.0/Ecliptix.Opaque.Protocol.GeneratedMSBuildEditorConfig.editorconfig
 [2025-11-04T12:57:54.852] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Services/ConnectivityService.cs
 [2025-11-04T12:57:54.852] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/authentication/AuthServicesGrpc.cs
 [2025-11-04T12:57:54.854] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Opaque.Protocol/Ecliptix.Opaque.Protocol.csproj
 [2025-11-04T12:57:54.854] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Connectivity/ConnectivityModels.cs
 [2025-11-04T12:57:54.855] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/.env
 [2025-11-04T12:57:54.856] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Authentication/AuthenticationFailureType.cs
 [2025-11-04T12:57:54.856] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Models/Membership/LogoutReason.cs
 [2025-11-04T12:57:54.857] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/LogoutKeyDerivation.cs
 [2025-11-04T12:57:54.857] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/GrpcDeadlineProvider.cs
 [2025-11-04T12:57:54.857] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Abstractions/Core/IInternetConnectivityObserver.cs
 [2025-11-04T12:57:54.858] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/CertificatePinning/CertificatePinningFailureMessages.cs
 [2025-11-04T12:57:54.858] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Security.Certificate.Pinning/Services/CertificatePinningOperationResult.cs
 [2025-11-04T12:57:54.858] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/OpaqueModelsGrpc.cs
 [2025-11-04T12:57:54.858] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/ErrorCode.cs
 [2025-11-04T12:57:54.859] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Views/Memberships/Components/TitleBar.axaml.cs
 [2025-11-04T12:57:54.859] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/MasterKeyDerivation.cs
 [2025-11-04T12:57:54.86] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/MembershipCore.cs
 [2025-11-04T12:57:54.861] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Registration/VerificationCodeEntryView.axaml.cs
 [2025-11-04T12:57:54.861] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/RedirectNotificationView.axaml
 [2025-11-04T12:57:54.862] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Constants/HintedTextBoxConstants.cs
 [2025-11-04T12:57:54.863] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleManager.cs
 [2025-11-04T12:57:54.863] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Authentication/IdentityService.cs
 [2025-11-04T12:57:54.864] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Connectivity/ConnectivityPublisher.cs
 [2025-11-04T12:57:54.865] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/device/DeviceServices.cs
 [2025-11-04T12:57:54.865] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IModuleViewFactory.cs
 [2025-11-04T12:57:54.865] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Core/Connectivity/InternetConnectivityObserverOptions.cs
 [2025-11-04T12:57:54.866] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Transport/Grpc/Interceptors/RequestMetaDataInterceptor.cs
 [2025-11-04T12:57:54.866] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/CryptographicConstants.cs
 [2025-11-04T12:57:54.866] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/KeyMaterialsGrpc.cs
 [2025-11-04T12:57:54.866] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Communication/CommonMessages.cs
 [2025-11-04T12:57:54.867] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Data/SecureStorage/Configuration/SecureStoreOptions.cs
 [2025-11-04T12:57:54.867] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/device/DeviceModels.cs
 [2025-11-04T12:57:54.868] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Common/CharacterWarningType.cs
 [2025-11-04T12:57:54.868] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/SecureEnvelope.cs
 [2025-11-04T12:57:54.87] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Styles/Core/Colors.axaml
 [2025-11-04T12:57:54.87] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Core/ConnectivityNotificationView.axaml
 [2025-11-04T12:57:54.871] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/KeyExchangeGrpc.cs
 [2025-11-04T12:57:54.873] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/Types.cs
 [2025-11-04T12:57:54.875] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Events/NetworkEvents.cs
 [2025-11-04T12:57:54.876] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Security/Abstractions/ISecureProtocolStateStorage.cs
 [2025-11-04T12:57:54.876] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/ViewModels/Hosts/AuthenticationViewModel.cs
 [2025-11-04T12:57:54.877] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Sodium/SodiumFailure.cs
 [2025-11-04T12:57:54.877] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/obj/Debug/net9.0/Ecliptix.Protocol.System.GlobalUsings.g.cs
 [2025-11-04T12:57:54.878] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/EventArgs/SecureKeyCharactersRemovedEventArgs.cs
 [2025-11-04T12:57:54.878] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/authentication/VerificationModels.cs
 [2025-11-04T12:57:54.881] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Authentication/SignInResult.cs
 [2025-11-04T12:57:54.881] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Sodium/SodiumFailureMessages.cs
 [2025-11-04T12:57:54.881] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/BottomSheetModal/BottomSheetAnimationConstants.cs
 [2025-11-04T12:57:54.881] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Security.Certificate.Pinning/Constants/CertificatePinningConstants.cs
 [2025-11-04T12:57:54.882] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/App.axaml
 [2025-11-04T12:57:54.882] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/GrpcCallOptionsFactory.cs
 [2025-11-04T12:57:54.882] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/MVVM/ModuleViewFactory.cs
 [2025-11-04T12:57:54.883] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Splash/Views/SplashWindow.axaml
 [2025-11-04T12:57:54.883] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Security.Certificate.Pinning/Services/ICertificatePinningServiceFactory.cs
 [2025-11-04T12:57:54.883] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Authentication/AuthenticationFailure.cs
 [2025-11-04T12:57:54.884] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Opaque.Protocol/obj/Debug/net9.0/Ecliptix.Opaque.Protocol.AssemblyInfo.cs
 [2025-11-04T12:57:54.884] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/ProtocolSystemConstants.cs
 [2025-11-04T12:57:54.884] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix-Desktop.sln
 [2025-11-04T12:57:54.885] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Security.Certificate.Pinning/obj/Debug/net9.0/Ecliptix.Security.Certificate.Pinning.GeneratedMSBuildEditorConfig.editorconfig
 [2025-11-04T12:57:54.885] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/ChainStepType.cs
 [2025-11-04T12:57:54.885] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Network/NetworkFailureType.cs
 [2025-11-04T12:57:54.886] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Hosts/AuthenticationView.axaml.cs
 [2025-11-04T12:57:54.886] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/EcliptixProtocol/EcliptixProtocolFailureMessages.cs
 [2025-11-04T12:57:54.886] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/EcliptixProtocol/EcliptixProtocolFailure.cs
 [2025-11-04T12:57:54.886] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Splash/ViewModels/SplashWindowViewModel.cs
 [2025-11-04T12:57:54.887] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/HealthCheck.cs
 [2025-11-04T12:57:54.887] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/External/IIpGeolocationService.cs
 [2025-11-04T12:57:54.888] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Events/MembershipLoggedOutEvent.cs
 [2025-11-04T12:57:54.888] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Splash/Views/SplashWindow.axaml.cs
 [2025-11-04T12:57:54.888] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Events/LanguageDetectionEvents.cs
 [2025-11-04T12:57:54.889] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/External/IpGeolocation/IpCountry.cs
 [2025-11-04T12:57:54.889] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Ecliptix.Utilities.csproj
 [2025-11-04T12:57:54.889] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/KeyMaterials.cs
 [2025-11-04T12:57:54.89] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/obj/Debug/net9.0/Ecliptix.Protocol.System.AssemblyInfo.cs
 [2025-11-04T12:57:54.89] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/obj/Debug/net9.0/Ecliptix.Utilities.AssemblyInfo.cs
 [2025-11-04T12:57:54.891] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/appsettings.json
 [2025-11-04T12:57:54.891] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/obj/Debug/net9.0/Ecliptix.Core.GeneratedMSBuildEditorConfig.editorconfig
 [2025-11-04T12:57:54.891] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Security/Platform/CrossPlatformSecurityProvider.cs
 [2025-11-04T12:57:54.891] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Connectivity/ConnectivityStatus.cs
 [2025-11-04T12:57:54.892] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/SignIn/SignInView.axaml.cs
 [2025-11-04T12:57:54.892] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Authentication/IIdentityService.cs
 [2025-11-04T12:57:54.893] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Styles/Core/Dimensions.axaml
 [2025-11-04T12:57:54.893] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Core/Localization/LocalizationData.cs
 [2025-11-04T12:57:54.894] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Network/IRetryPolicyProvider.cs
 [2025-11-04T12:57:54.895] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/SecrecyChannelRpcServices.cs
 [2025-11-04T12:57:54.895] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/IGrpcErrorProcessor.cs
 [2025-11-04T12:57:54.896] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Security/Crypto/IRsaChunkEncryptor.cs
 [2025-11-04T12:57:54.898] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/MembershipServices.cs
 [2025-11-04T12:57:54.898] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/authentication/VerificationModelsGrpc.cs
 [2025-11-04T12:57:54.898] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/AuthenticationModule.cs
 [2025-11-04T12:57:54.899] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Core/IApplicationInitializer.cs
 [2025-11-04T12:57:54.899] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Core/Connectivity/InternetConnectivityObserver.cs
 [2025-11-04T12:57:54.9] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/FodyWeavers.xml
 [2025-11-04T12:57:54.9] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Data/SecureStorage/ApplicationSecureStorageProvider.cs
 [2025-11-04T12:57:54.9] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleBase.cs
 [2025-11-04T12:57:54.901] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Common/InternalServiceApiFailureType.cs
 [2025-11-04T12:57:54.901] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Membership/LogoutFailureType.cs
 [2025-11-04T12:57:54.901] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/UserRequestErrorView.axaml.cs
 [2025-11-04T12:57:54.902] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/ResultMappingExtensions.cs
 [2025-11-04T12:57:54.902] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Authentication/IAuthenticationService.cs
 [2025-11-04T12:57:54.902] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Unit.cs
 [2025-11-04T12:57:54.903] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IModuleManifest.cs
 [2025-11-04T12:57:54.903] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/ViewModels/SignIn/SignInViewModel.cs
 [2025-11-04T12:57:54.904] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/OperationTimeoutProvider.cs
 [2025-11-04T12:57:54.905] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/.sonarlint/Ecliptix-Desktop.json
 [2025-11-04T12:57:54.905] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/MVVM/StaticViewMapper.cs
 [2025-11-04T12:57:54.906] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Opaque.Protocol/obj/Debug/net9.0/Ecliptix.Opaque.Protocol.GlobalUsings.g.cs
 [2025-11-04T12:57:54.906] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Resilience/RetryStrategyConfiguration.cs
 [2025-11-04T12:57:54.907] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/obj/Debug/net9.0/Ecliptix.Utilities.GlobalUsings.g.cs
 [2025-11-04T12:57:54.907] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Security/Abstractions/IPlatformSecurityProvider.cs
 [2025-11-04T12:57:54.907] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Ecliptix.Core.csproj
 [2025-11-04T12:57:54.908] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/TypesGrpc.cs
 [2025-11-04T12:57:54.908] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/obj/Debug/net9.0/Ecliptix.Utilities.GeneratedMSBuildEditorConfig.editorconfig
 [2025-11-04T12:57:54.909] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/device/ApplicationSettingsGrpc.cs
 [2025-11-04T12:57:54.909] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/AssemblyInfo.cs
 [2025-11-04T12:57:54.909] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Network/IRpcServiceManager.cs
 [2025-11-04T12:57:54.91] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/device/DeviceModelsGrpc.cs
 [2025-11-04T12:57:54.91] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IModule.cs
 [2025-11-04T12:57:54.913] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Styles/Components/Buttons.axaml
 [2025-11-04T12:57:54.915] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/CertificatePinning/CertificatePinningFailureType.cs
 [2025-11-04T12:57:54.916] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecureMemoryBuffer.cs
 [2025-11-04T12:57:54.918] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Security.Certificate.Pinning/Ecliptix.Security.Certificate.Pinning.csproj
 [2025-11-04T12:57:54.918] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Directory.Build.props
 [2025-11-04T12:57:54.919] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/ReplayProtection.cs
 [2025-11-04T12:57:54.919] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/ServiceFlowType.cs
 [2025-11-04T12:57:54.92] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/IGrpcCallOptionsFactory.cs
 [2025-11-04T12:57:54.921] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/IProtocolEventHandler.cs
 [2025-11-04T12:57:54.922] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/Ecliptix.Protobufs.AssemblyInfo.cs
 [2025-11-04T12:57:54.923] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/KeySplittingFailure.cs
 [2025-11-04T12:57:54.923] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Sodium/SodiumFailureType.cs
 [2025-11-04T12:57:54.924] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Core/IStateCleanupService.cs
 [2025-11-04T12:57:54.924] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Transport/Grpc/GrpcClientServiceExtensions.cs
 [2025-11-04T12:57:54.924] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/ViewModels/Welcome/WelcomeViewModel.cs
 [2025-11-04T12:57:54.926] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Welcome/WelcomeView.axaml
 [2025-11-04T12:57:54.927] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/EventArgs/SecureKeyCharactersAddedEventArgs.cs
 [2025-11-04T12:57:54.927] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Registration/PassPhaseView.axaml
 [2025-11-04T12:57:54.928] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Transport/RpcMetaDataProvider.cs
 [2025-11-04T12:57:54.93] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Shared/Converters/EqualityConverter.cs
 [2025-11-04T12:57:54.932] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/LanguageSelector/LanguageItem.cs
 [2025-11-04T12:57:54.934] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Services/IConnectivityService.cs
 [2025-11-04T12:57:54.935] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/appsettings.Production.json
 [2025-11-04T12:57:54.936] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Core/IApplicationStateManager.cs
 [2025-11-04T12:57:54.937] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/UserRequestErrorView.axaml
 [2025-11-04T12:57:54.938] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Subscriptions/SubscriptionManager.cs
 [2025-11-04T12:57:54.94] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/Ecliptix.Protobufs.GlobalUsings.g.cs
 [2025-11-04T12:57:54.941] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/Constants/SecureKeyValidatorConstants.cs
 [2025-11-04T12:57:54.942] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Views/Core/MainWindow.axaml
 [2025-11-04T12:57:54.942] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/RatchetConfig.cs
 [2025-11-04T12:57:54.942] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/appsettings.Development.json
 [2025-11-04T12:57:54.943] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Core/EcliptixProtocolSystem.cs
 [2025-11-04T12:57:54.943] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleCatalog.cs
 [2025-11-04T12:57:54.943] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Welcome/WelcomeView.axaml.cs
 [2025-11-04T12:57:54.944] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/App.axaml.cs
 [2025-11-04T12:57:54.945] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/VersionHelper.cs
 [2025-11-04T12:57:54.946] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Network/Core/Constants/NetworkConstants.cs
 [2025-11-04T12:57:54.946] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModulePriorityQueue.cs
 [2025-11-04T12:57:54.947] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Assets/Icons/Flags/usa_flag.svg
 [2025-11-04T12:57:54.948] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/UserRequestErrorViewModel.cs
 [2025-11-04T12:57:54.948] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/CryptographicHelpers.cs
 [2025-11-04T12:57:54.949] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/Connectivity/ConnectivityReason.cs
 [2025-11-04T12:57:54.95] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Core/StateCleanupService.cs
 [2025-11-04T12:57:54.95] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/SignIn/SignInView.axaml
 [2025-11-04T12:57:54.95] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/MembershipCoreGrpc.cs
 [2025-11-04T12:57:54.951] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Common/AuthenticationFlowContext.cs
 [2025-11-04T12:57:54.951] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/RpcRequestContext.cs
 [2025-11-04T12:57:54.952] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Modularity/ModuleLoadingContext.cs
 [2025-11-04T12:57:54.952] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/MVVM/ViewLocator.cs
 [2025-11-04T12:57:54.952] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Option.cs
 [2025-11-04T12:57:54.952] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/ServiceRequest.cs
 [2025-11-04T12:57:54.953] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Registration/VerificationCodeEntryView.axaml
 [2025-11-04T12:57:54.953] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///usr/local/share/dotnet/sdk/9.0.101/Sdks/Microsoft.NET.Sdk/analyzers/build/config/analysislevel_9_default.globalconfig
 [2025-11-04T12:57:54.953] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/RpcServiceManager.cs
 [2025-11-04T12:57:54.954] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Views/Registration/MobileVerificationView.axaml.cs
 [2025-11-04T12:57:54.954] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/EncryptionGrpc.cs
 [2025-11-04T12:57:54.954] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/FailureBase.cs
 [2025-11-04T12:57:54.954] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Authentication/Common/MembershipViewType.cs
 [2025-11-04T12:57:54.954] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/LogoutProofHandler.cs
 [2025-11-04T12:57:54.955] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Abstractions/IResettable.cs
 [2025-11-04T12:57:54.955] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/common/Encryption.cs
 [2025-11-04T12:57:54.955] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/obj/Debug/net9.0/Avalonia/resources
 [2025-11-04T12:57:54.955] [pool-1923-thread-2] WARN sonarlint - Invalid character encountered in file 'file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/obj/Debug/net9.0/Avalonia/resources' at line 1 for encoding UTF-8. Please fix file content or configure the encoding.
 [2025-11-04T12:57:55.385] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Styles/Components/TrafficLights.axaml
 [2025-11-04T12:57:55.385] [pool-1923-thread-2] WARN org.sonar.plugins.common.analyzer.TextAndSecretsAnalyzer - The file '[uri=file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/obj/Debug/net9.0/Avalonia/resources]' contains binary data and will not be included in the text and secrets analysis.
 [2025-11-04T12:57:55.385] [pool-1923-thread-2] WARN org.sonar.plugins.common.analyzer.TextAndSecretsAnalyzer - Please check this file and/or remove the extension from the 'sonar.text.inclusions' property.
 [2025-11-04T12:57:55.386] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/UtilityConstants.cs
 [2025-11-04T12:57:55.386] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Authentication/SecureTextBuffer.cs
 [2025-11-04T12:57:55.386] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Core/IApplicationRouter.cs
 [2025-11-04T12:57:55.386] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/IGrpcDeadlineProvider.cs
 [2025-11-04T12:57:55.387] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Common/InternalServiceApiFailure.cs
 [2025-11-04T12:57:55.387] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Core/SegmentedTextBox.axaml
 [2025-11-04T12:57:55.387] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Views/Core/MainWindow.cs
 [2025-11-04T12:57:55.387] [pool-1923-thread-3] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/KeyExchange.cs
 [2025-11-04T12:57:55.388] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecureMemoryPool.cs
 [2025-11-04T12:57:55.388] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Infrastructure/Security/KeySplitting/IHardenedKeyDerivation.cs
 [2025-11-04T12:57:55.388] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/EcliptixProtocol/EcliptixProtocolFailureType.cs
 [2025-11-04T12:57:55.388] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Shared/Converters/BooleanToOpacityConverter.cs
 [2025-11-04T12:57:55.388] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/StorageKeyConstants.cs
 [2025-11-04T12:57:55.389] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/AssemblyInfo.cs
 [2025-11-04T12:57:55.389] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/protocol/ProtocolStateGrpc.cs
 [2025-11-04T12:57:55.389] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/BottomSheetModal/BottomSheetViewModel.cs
 [2025-11-04T12:57:55.389] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/Constants/MobileNumberValidatorConstants.cs
 [2025-11-04T12:57:55.389] [pool-1923-thread-7] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/membership/OpaqueModels.cs
 [2025-11-04T12:57:55.392] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Sodium/SodiumExceptionMessagePatterns.cs
 [2025-11-04T12:57:55.392] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Validations/ValidationFailure.cs
 [2025-11-04T12:57:55.392] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Assets/Icons/UI/LampIcon.axaml
 [2025-11-04T12:57:55.392] [pool-1923-thread-8] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/Messaging/MessageBus.cs
 [2025-11-04T12:57:55.392] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/SecureKeyStrength.cs
 [2025-11-04T12:57:55.392] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Core/MVVM/ReactiveUIViewLocatorAdapter.cs
 [2025-11-04T12:57:55.393] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/Views/Components/WelcomeView.axaml.cs
 [2025-11-04T12:57:55.393] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Membership/MobileNumberValidator.cs
 [2025-11-04T12:57:55.393] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/Modals/BottomSheetModal/DefaultBottomSheetVariables.cs
 [2025-11-04T12:57:55.393] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Network/Rpc/ReceiveStreamRpcServices.cs
 [2025-11-04T12:57:55.393] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/MainModule.cs
 [2025-11-04T12:57:55.393] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Utilities/Failures/Sodium/SodiumFailureExtensions.cs
 [2025-11-04T12:57:55.394] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Abstractions/Network/ISecrecyChannelRpcServices.cs
 [2025-11-04T12:57:55.394] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Services/Core/ApplicationStateManager.cs
 [2025-11-04T12:57:55.394] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/SecureMemoryUtils.cs
 [2025-11-04T12:57:55.394] [pool-1923-thread-1] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protobufs/obj/Debug/net9.0/authentication/AuthServices.cs
 [2025-11-04T12:57:55.394] [pool-1923-thread-4] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Controls/LanguageSelector/LanguageSelectorView.axaml
 [2025-11-04T12:57:55.395] [pool-1923-thread-2] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core.Desktop/Constants/ApplicationConstants.cs
 [2025-11-04T12:57:55.395] [pool-1923-thread-5] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Constants/ApplicationErrorMessages.cs
 [2025-11-04T12:57:55.395] [pool-1923-thread-9] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Protocol.System/Utilities/ScopedSecureMemory.cs
 [2025-11-04T12:57:55.395] [pool-1923-thread-10] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/Features/Main/Views/MasterView.axaml.cs
 [2025-11-04T12:57:55.395] [pool-1923-thread-6] DEBUG sonarlint - Initializing metadata of file file:///Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/Ecliptix.Core/Ecliptix.Core/SLog.txt
 [2025-11-04T12:57:57.992] [Progress of the text and secrets analysis] INFO org.sonar.plugins.common.MultiFileProgressReport - 400/400 source files have been analyzed for the text and secrets analysis
 [2025-11-04T12:57:57.992] [sonarlint-analysis-scheduler] DEBUG org.sonar.plugins.common.analyzer.Analyzer - Analyzed files for the text and secrets analysis: 398
 [2025-11-04T12:57:57.992] [sonarlint-analysis-scheduler] INFO com.sonar.plugins.common.DETextAndSecretsSensor - Start fetching files for the binary file analysis
 [2025-11-04T12:57:57.992] [sonarlint-analysis-scheduler] INFO org.sonar.plugins.common.analyzer.Analyzer - There are no files to be analyzed for the binary file analysis
 [2025-11-04T12:57:57.993] [sonarlint-analysis-scheduler] INFO sonarlint - Analysis detected 141 issues and 0 Security Hotspots in 55845ms
 [2025-11-04T12:57:58.437] [sonarlint-server-tracking-issue-updater] DEBUG sonarlint - GET 200 https://sonarcloud.io/batch/issues?key=oleksandrmelnychenko_ecliptix-desktop&branch=main | response time=444ms
 [2025-11-04T12:57:58.44] [sonarlint-server-tracking-issue-updater] DEBUG sonarlint - Downloaded issues in 446ms
 [2025-11-04T12:57:58.654] [sonarlint-server-tracking-issue-updater] DEBUG sonarlint - Wrote 721 issues in store | took 212ms
 [2025-11-04T12:57:59.234] [sonarlint-server-tracking-issue-updater] DEBUG sonarlint - GET 200 https://sonarcloud.io/api/hotspots/search.protobuf?projectKey=oleksandrmelnychenko_ecliptix-desktop&branch=main&ps=500&p=1 | response time=578ms
 [2025-11-04T12:57:59.236] [sonarlint-server-tracking-issue-updater] DEBUG sonarlint - Page downloaded in 581ms
 [2025-11-04T12:57:59.258] [sonarlint-server-tracking-issue-updater] DEBUG sonarlint - Wrote 35 hotspots in store | took 21ms
 [2025-11-04T12:57:59.32] [sonarlint-analysis-scheduler] DEBUG sonarlint - Reporting 455 issues for configuration scope /Users/oleksandrmelnychenko/RiderProjects/ecliptix-desktop/.idea/.idea.Ecliptix-Desktop/.idea/misc.xml_rider.module
